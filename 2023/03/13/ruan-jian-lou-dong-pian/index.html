<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>软件漏洞篇 | Jan&#39;s Blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
    <script>
        var themeModelId = '';
        if (themeModelId) {
            localStorage.setItem('modelId', themeModelId);
        }
    </script>
    
    <script src="https://cdn.jsdelivr.net/gh/yuang01/live2d-widget@latest/autoload.js"></script>
    <script>
        var live2dOpen = eval('true') || false;
        if (!live2dOpen) {
            localStorage.setItem('waifu-display', 1609323474481);
        }
    </script>
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Jan's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

  
  <!-- 依赖于jquery和vue -->
  
    
<script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>

  

  
    
<script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>

  
  
  <!-- 预加载动画 -->
  <!-- 页面预加载动画 -->

  
    <div class="preloader_2" id="loader">
  <div class="loader"></div>
</div>

  
<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
</script>

  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">Jan&#39;s Blog</h3>
      <h5 class="drawer-box-head_desc">千磨万击还坚劲，任尔东西南北风</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/" class="drawer-menu-item-link">
                  
                    <i class="fas fa-home" aria-hidden="true"></i>
                  
                  <span class="name">首页</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/archives" class="drawer-menu-item-link">
                  
                    <i class="fas fa-archive" aria-hidden="true"></i>
                  
                  <span class="name">归档</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/tags" class="drawer-menu-item-link">
                  
                    <i class="fas fa-tags" aria-hidden="true"></i>
                  
                  <span class="name">标签</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/categories" class="drawer-menu-item-link">
                  
                    <i class="fas fa-bookmark" aria-hidden="true"></i>
                  
                  <span class="name">分类</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/about" class="drawer-menu-item-link">
                  
                  <span class="name">关于</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/resume" class="drawer-menu-item-link">
                  
                  <span class="name">简历</span>
                </a>
              
            </li>
          
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/Jan-nku/Jan-nku.github.io">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">Jan&#39;s Blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/" class="menu-item-link" title="首页">
                  
                    <i class="fas fa-home" aria-hidden="true"></i>
                  
                  <span class="name">首页</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/archives" class="menu-item-link" title="归档">
                  
                    <i class="fas fa-archive" aria-hidden="true"></i>
                  
                  <span class="name">归档</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/tags" class="menu-item-link" title="标签">
                  
                    <i class="fas fa-tags" aria-hidden="true"></i>
                  
                  <span class="name">标签</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/categories" class="menu-item-link" title="分类">
                  
                    <i class="fas fa-bookmark" aria-hidden="true"></i>
                  
                  <span class="name">分类</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/about" class="menu-item-link" title="关于">
                  
                  <span class="name">关于</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/resume" class="menu-item-link" title="简历">
                  
                  <span class="name">简历</span>
                </a>
              
            </li>
          
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/Jan-nku/Jan-nku.github.io" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        软件漏洞篇
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2023-03-13 |
        </span>
      

      
        <span class="post-detail-header_categories">
          <i class="iconfont iconbookmark1"></i> 分类：
          
            <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" class="post-detail-header_category">
              软件安全
            </a>
          
        </span>
      

      
        <div class="post-detail-header_wordcount">
          <span class="totalcount">
            <i class="fas fa-file-text-o"></i> 字数统计: 10.9k |
          </span>
  
          <span class="min2read">
            <i class="fas fa-clock"></i> 阅读时长: 41分钟 |
          </span>
  
          
            <span class="reading">
              <i class="fas fa-eye"></i> 阅读量：<span id="busuanzi_value_page_pv"></span>
            </span>
          
        </div>
      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>漏洞也称为<strong>脆弱性</strong>(Vulnerability)，是计算机系统的硬件、软件、协议在系统设计、具体实现、系统配置或安全策略上存在的缺陷。</p>
<p>缺陷一旦被发现并被<u>恶意利用</u>，就会使攻击者在未授权的情况下访问或破坏系统，从而影响计算机系统的正常运行甚至造成安全损害。</p>
<p><code>对于漏洞有多种称呼，包括Hole, Error, Fault, Weakness, Failure等，这些称呼都不能涵盖漏洞的含义（脆弱性）。</code></p>
<p>软件漏洞专指计算机系统中的<strong>软件系统漏洞</strong>。</p>
<h1 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>缓冲区</strong></p>
<p>缓冲区是一块连续的内存区域，用于存放程序运行时加载到内存的运行代码和数据。</p>
<p><strong>缓冲区溢出</strong></p>
<p>缓冲区溢出是指程序运行时，向固定大小的缓冲区写入超过其容量的数据，多余的数据会越过缓冲区的边界覆盖相邻内存空间，从而造成溢出。 </p>
<p>缓冲区的大小是由用户输入的数据决定的，如果程序<strong>不对用户输入的超长数据作长度检查</strong>，同时用户又对程序进行了<strong>非法操作或者错误输入</strong>，就会造成缓冲区溢出。</p>
<p><strong>缓冲区溢出攻击</strong></p>
<p>缓冲区溢出攻击是指发生缓冲区溢出时，溢出的数据会覆盖相邻内存空间的返回地址、函数指针、堆管理结构等合法数据，从而使程序运行失败、或者发生转向去执行其它程序代码、或者<strong>执行预先注入到内存缓冲区中的代码</strong>。</p>
<p><code>缓冲区溢出后执行的代码，会以原有程序的身份权限运行。</code></p>
<p><strong>造成缓冲区溢出的根本原因</strong></p>
<p>是<strong>缺乏类型安全功能的程序设计语言</strong>（C、C++等）出于效率的考虑，<strong>部分函数不对数组边界条件和函数指针引用等进行边界检查</strong>。例如，C 标准库中和字符串操作有关的函数，像strcpy，strcat，sprintf，gets等函数中，<strong>数组和指针都没有自动边界检查</strong>。</p>
<p>程序员开发时必须自己<u>进行边界检查，防范数据溢出</u>，否则所开发的程序就存在缓冲区溢出的安全隐患，而实际上这一行为往往被程序员忽略或者检查不充分。</p>
<p>缓冲区溢出通常包括<em>栈溢出</em>、<em>堆溢出</em>、<em>异常处理SEH结构溢出</em>、<em>单字节溢出</em>等。</p>
<h2 id="栈溢出漏洞"><a href="#栈溢出漏洞" class="headerlink" title="栈溢出漏洞"></a>栈溢出漏洞</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>栈溢出漏洞</strong>，即发生在栈区的溢出漏洞。被调用的子函数中写入数据的长度，大于栈帧的基址到esp之间预留的保存局部变量的空间时，就会发生栈的溢出。要写入数据的填充方向是从低地址向高地址增长，多余的数据就会越过栈帧的基址，覆盖基址以上的地址空间。</p>
<h3 id="栈溢出漏洞示例"><a href="#栈溢出漏洞示例" class="headerlink" title="栈溢出漏洞示例"></a>栈溢出漏洞示例</h3><p>下面的程序演示了一个溢出漏洞，代码如下 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">why_here</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;why u r here?!\n&quot;</span>); </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> buff[<span class="number">1</span>];</span><br><span class="line">       buff[<span class="number">2</span>] = (<span class="type">int</span>)why_here;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如程序所示，主函数将调用函数f，并没有调用why_here函数，但是运行结果如下：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/8ea39856bbbe4a16845fea8f906e96bb.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/8ea39856bbbe4a16845fea8f906e96bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在函数f中，所声明的数组buff长度为1，但是由于没有对访问下标的值进行校验，程序中<strong>对数组外的内存进行了读写</strong>，这是一个典型的溢出漏洞。</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/31f362c510b71e12cd2eaec670fc9f1c.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/31f362c510b71e12cd2eaec670fc9f1c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">why_here</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;why u r here?!\n&quot;</span>); </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> buff; <span class="type">int</span> * p = &amp;buff; </span><br><span class="line">       ________= (<span class="type">int</span>)why_here;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：*(p+2)或者p[2]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/c14d0d5f8964a6b0d4d23eafbab7bb10.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/c14d0d5f8964a6b0d4d23eafbab7bb10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="溢出漏洞利用示例"><a href="#溢出漏洞利用示例" class="headerlink" title="溢出漏洞利用示例"></a>溢出漏洞利用示例</h3><h4 id="修改返回地址"><a href="#修改返回地址" class="headerlink" title="修改返回地址"></a>修改返回地址</h4><p>栈的存取采用先进后出的策略，程序用它来保存函数调用时的有关信息，如函数参数、返回地址，函数中的非静态局部变量存放在栈中。如果返回地址被覆盖，当覆盖后的地址是一个无效地址，则程序运行失败。如果<strong>覆盖返回地址的是恶意程序的入口地址，则源程序将转向去执行恶意程序</strong>。</p>
<p>下面以一段程序为例说明栈溢出的原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stack_overflow</span><span class="params">(<span class="type">char</span>* argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> local[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; argument[i];i++)</span><br><span class="line">             local[i] = argument[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数<code>stack_overflow</code>被调用时堆栈布局如下图所示。图中local是栈中保存局部变量的缓冲区，根据char local[4]预先分配的大小为4个字节，当向local中写入超过4个字节的字符时，就会发生溢出。</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/1bc74d210d06304d4d84b985572dbd6b.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/1bc74d210d06304d4d84b985572dbd6b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="覆盖临接变量"><a href="#覆盖临接变量" class="headerlink" title="覆盖临接变量"></a>覆盖临接变量</h4><p>在第三章，我们通过修改机器码实现了软件破解，接下来我们通过在输入上做文章（也是漏洞利用方式），试着覆盖临近变量的值，以便更改程序执行流程。</p>
<p>函数的局部变量在栈中一个挨着一个排列。如果这些局部变量中有<strong>数组之类的缓冲区</strong>，并且程序中<strong>存在数组越界的缺陷</strong>，那么越界的数组元素就有可能破坏栈中相邻变量的值，甚至破坏栈帧中所保存的EBP值、返回地址等重要数据。<br>用一个简单例子来说明破坏栈内局部变量对程序的安全性有什么影响（VC6）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;1234567&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">verify_password</span><span class="params">(<span class="type">char</span> * password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];  <span class="comment">//add local buff to be overflowed</span></span><br><span class="line">    authenticated = <span class="built_in">strcmp</span>(password, PASSWORD);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, password);</span><br><span class="line">    <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> valid_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input password:    &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">        valid_flag = <span class="built_in">verify_password</span>(password);</span><br><span class="line">        <span class="keyword">if</span>(valid_flag)</span><br><span class="line">        &#123;           <span class="built_in">printf</span> (<span class="string">&quot;incorrect password!\n\n&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         &#123;           <span class="built_in">printf</span>(<span class="string">&quot;Congratulation! You have passed the verification!\n&quot;</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>观察一下源代码不难发现，<code>authenticated</code>变量的值来源于<code>strcmp</code>函数的返回值，之后会返回给main函数作为密码验证成功与否的标志变量：<br>当authenticated为0时，表示验证成功；反之，验证不成功。</p>
</blockquote>
<p>如果我们输入的密码超过了7个字符（注意：字符串截断符NULL将占用一个字节），则越界字符的ASCII码会修改掉authenticated的值。如果这段溢出数据恰好把authenticated改为0，则程序流程将被改变。 要<strong>成功覆盖临近变量并使其为0</strong>，有两个条件：</p>
<ul>
<li>输入一个8位的字符串的时候，比如“22334455”，此时，<u>字符串的结束符恰恰是0</u>，则覆盖变量authenticated的高字节并使其为0；</li>
<li>输入的字符串应该大于“12345678”，因为执行strcmp之后要确保变量authenticated的值为1，也就是只有高字节是1，其它字节为0。</li>
</ul>
<h4 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h4><p>打开OllyDBG，装载程序后，会停在程序入口点，单步执行可以定位到<strong>主函数</strong>：第一，主函数通过OllyDBG的信息提示区域，会显示<strong>main函数信息</strong>；第二，Windows控制台程序的主函数参数包含三个，即_argc、_argv和_environ，在函数调用前面的参数入栈环节具有鲜明的特征，如下：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/1fc8a63dbdb8c6cf9150dc515da760df.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/1fc8a63dbdb8c6cf9150dc515da760df.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>此时，选择<strong>步入执行</strong>即可转到主函数。之后继续一步步执行程序，会遇到<code>Scanf</code>函数，弹出对话框，接受用户输入，我们输入“22334455”，然后会回到原来程序，继续单步运行，直到调用<code>verify_password</code>函数后，进入该函数代码区域。</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/1fbff66e84966cedf1c72d238f7590c2.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/1fbff66e84966cedf1c72d238f7590c2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在执行完口令比较后，运行完<code>mov dword part [ebp-4], eax</code>语句，该语句含义为将EAX寄存器的值（刚执行的strcmp函数的返回值）复制给地址ebp-4的局部变量。也就是，将口令比较的结果复制给我们定义的局部变量authenticated。</p>
<p><strong>通过寄存器窗口，可知当前EBP寄存器值为0x0012FB24</strong>，观察此时栈区变化，观察此时ebp-4地址处的变量值，同时，我们将数据窗口定位到地址0x0012FB20处（数据窗口区域，点右键，选择“转到-&gt;表达式”，出现表达式后，输入0x0012FB20或EBP-4，然后选择“跟随表达式”），来观察后续的变化，如下：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/ffaa975b4396692e09039b8471dd5fed.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/ffaa975b4396692e09039b8471dd5fed.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>当程序执行到strcpy溢出覆盖后的“mov eax, dword ptr [ebp-4]”之前，我们可以观察到，溢出成功的覆盖了变量authenticated的值为0x00000000。</p>
<h2 id="堆溢出漏洞"><a href="#堆溢出漏洞" class="headerlink" title="堆溢出漏洞"></a>堆溢出漏洞</h2><h3 id="堆溢出漏洞示例"><a href="#堆溢出漏洞示例" class="headerlink" title="堆溢出漏洞示例"></a>堆溢出漏洞示例</h3><p>堆溢出是指在堆中发生的缓冲区溢出。堆溢出后，数据可以覆盖堆区的不同堆块的数据，带来安全威胁。</p>
<p>我们将通过下面一个简单例子，来演示一个简单的堆溢出漏洞：该漏洞在产生溢出的时候，将覆盖一个目标堆块的块身数据。</p>
<p><strong>示例</strong>：从堆区申请两个堆块，处于低地址的buf1和处于高地址的buf2。buf2存储了一个名为myoutfile 的字符串，用来存储文件名。buf1用来接收输入，同时将这些输入字符在程序执行过程中写入到buf2 存储的文件名myoutfile 所指向的文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;myoutfile&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fd;</span><br><span class="line">    <span class="type">long</span> diff;</span><br><span class="line">    <span class="type">char</span> bufchar[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> *buf1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> *buf2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    diff = (<span class="type">long</span> <span class="type">long</span>)buf2 - (<span class="type">long</span> <span class="type">long</span>)buf1;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf2, FILENAME);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 存储地址:%p\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 存储地址:%p,存储内容为文件名:%s\n&quot;</span>, buf2, buf2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两个地址之间的距离:%d 个字节 \n&quot;</span>, diff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要写入文件%s 的字符串:\n&quot;</span>, buf2);</span><br><span class="line">        <span class="built_in">gets</span>(bufchar);</span><br><span class="line">        <span class="built_in">strcpy</span>(buf1, bufchar);<span class="comment">//很明显，往buf1复制，没有边界检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf1, argv[<span class="number">1</span>]);<span class="comment">//很明显，往buf1复制，没有边界检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//溢出后，导致buf2可能变成设计的目标文件，而非原始文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 存储内容:%s \n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 存储内容:%s \n&quot;</span>, buf2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;将%s\n 写入文件 %s 中\n\n&quot;</span>, buf1, buf2);</span><br><span class="line">    fd = <span class="built_in">fopen</span>(buf2, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd  <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s 打开错误\n&quot;</span>, buf2);</span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= <span class="built_in">strlen</span>(bufchar))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提示:buf1 内存溢出!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fd, <span class="string">&quot;%s\n\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= <span class="built_in">strlen</span>(bufchar))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提示:buf1 已溢出，溢出部分覆盖 buf2 中的 myoutfile\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>malloc</code>命令，申请了两个堆的存储空间。接着定义了diff变量，它记录了buf1和buf2之间的地址距离，也就是说buf1和buf2之间还有多少存储空间。(具体空间大小看编译器应该)</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/3e4e99794a43aab6e66997bac952b5be.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/3e4e99794a43aab6e66997bac952b5be.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>输入字符串的长度为大于72个字节，而且刻意构造一个自定义的字符串“hostility”，是输入为“72字节填充数据”+“hostility”。可见buf1的内容长度是超过了72个字节的，而buf2的内容就变成了hostility。</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/73e3229bfec0038e1b1d0b8c6a1257a7.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/73e3229bfec0038e1b1d0b8c6a1257a7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>fopen语句将buf2指向的文件打开，打开的形式是<strong>追加行</strong>，用了关键字“a”。即打开这个文件后，<strong>如果这个文件是以前存在的，那么写入的文件就添加到已有的内容之后；如果是以前不存在的一个文件，就创建这个文件并写入相应的内容。</strong><br>用fprintf 语句将buf1中已经获得的语句写入到这个文件里。然后关闭文件。</p>
<p><code>因为buf1后面没有字符串结束符，所以读取不会停止！</code></p>
<h3 id="堆溢出漏洞利用"><a href="#堆溢出漏洞利用" class="headerlink" title="堆溢出漏洞利用"></a>堆溢出漏洞利用</h3><p>相比于栈溢出，<strong>堆溢出的实现难度更大</strong>，而且往往要求进程在内存中具备特定的组织结构。然而，堆溢出攻击也已经成为缓冲区溢出攻击的<u>主要方式之一</u>。堆溢出带来的威胁远远不止上面示例演示的那样，结合堆管理结构，<strong>堆溢出漏洞可以在任意位置写入任意数据！</strong></p>
<h3 id="堆管理结构"><a href="#堆管理结构" class="headerlink" title="堆管理结构"></a>堆管理结构</h3><p>在Windows系统中，占有态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表freelist（简称空表）和快速单向链表lookaside（简称快表）。</p>
<p>堆块三类操作：堆块分配、堆块释放和堆块合并，<strong>归根结底是对空表链的修改</strong>。这些修改无外乎要向链表里链入和卸下堆块。根据对链表操作的常识，我们可以知道，从链表上卸载（unlink）一个节点的时候会发生如下操作：</p>
<p><code>node—&gt;blink—&gt;flink = node—&gt;flink ;</code><br><code>node—&gt;flink—&gt;blink = node—&gt;blink ;</code></p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/9bf243ed5dead30b5acb2d195150a416.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/9bf243ed5dead30b5acb2d195150a416.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>具体的，在Windows堆内存分配时会调用函数<code>RtlAllocHeap</code>，该函数从空闲堆链上摘下一空闲堆块，完成双向链表里相关节点的前后指针的变更操作，它会执行如下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//空闲堆块的前向指针（数值）写入到空闲堆块的后向指针（地址）里去</span></span><br><span class="line"></span><br><span class="line">mov dword ptr [edi], ecx ;</span><br><span class="line">mov dword ptr [ecx+<span class="number">4</span>], edi ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ecx相当于node-&gt;flink,edx相当于node-&gt;blink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[edi]相当于node—&gt;blink—&gt;flink,[ecx+4]相当于node—&gt;flink—&gt;blink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ecx]相当于node—&gt;flink—&gt;flink,前向指针的地址在后向指针前面！！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中ecx为<strong>空闲可分配的堆区块的前向指针</strong>，edi为<strong>该堆区块的后向指针</strong>。这两条汇编语句恰好对应了上述两个链表卸载节点对应的前后向指针变化的操作。</p>
<h3 id="Dword-Shoot攻击"><a href="#Dword-Shoot攻击" class="headerlink" title="Dword Shoot攻击"></a>Dword Shoot攻击</h3><p>如果我们通过堆溢出覆写了一个空闲堆块的块首的前向指针flink和后向指针blink，我们可以精心构造一个<u>地址</u>和一个<u>数据</u>，当这个空闲堆块从链表里卸下的时候，就获得一次向内存构造的任意地址写入一个任意数据的机会。这种能够<strong>向内存任意位置写入任意数据</strong>的机会称为<u>“Arbitrary Dword Reset”（又称Dword Shoot）</u>。具体如下图所示。</p>
<p><font color="red">why?</font></p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/14bcf26258852f34bd8da072a45d669c.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/14bcf26258852f34bd8da072a45d669c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>基于Dword Shoot攻击，攻击者甚至可以<strong>劫持进程</strong>，运行植入的恶意代码。比如，当构造的地址为重要函数调用地址、栈帧中函数返回地址、栈帧中SEH的句柄等时，写入的任意数据可能就是恶意代码的入口地址。</p>
<h3 id="Dword-Shoot攻击示例"><a href="#Dword-Shoot攻击示例" class="headerlink" title="Dword Shoot攻击示例"></a>Dword Shoot攻击示例</h3><p><strong>堆溢出漏洞示例</strong>：以下列程序为例，演示堆块分配过程中潜在的Dword Shoot攻击。<br>实验环境：VC6.0、Windows XP SP3、<u>Debug模式</u>。</p>
<p>在讲这个实验之前，先介绍一下Windows的堆使用。<br>在Windows里，可以使用Windows缺省堆，也可以用户自己创建新堆：</p>
<ul>
<li>获取缺省堆可以通过GetProcessHeap函数（无参数）得到句柄；</li>
<li>创建新堆可以用<strong>HeapCreat</strong>函数。</li>
<li>除了malloc、new等函数外，C/C++也提供了<strong>HeapAlloc</strong>、HeapFree等函数用于堆的分配和释放。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    HLOCAL h1, h2,h3,h4,h5,h6;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = <span class="built_in">HeapCreate</span>(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>); <span class="comment">//创建自主管理的堆</span></span><br><span class="line">    h1 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);<span class="comment">//从堆里申请空间</span></span><br><span class="line">    h2 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h3 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h4 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h5 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h6 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">_asm <span class="type">int</span> <span class="number">3</span>  <span class="comment">//手动增加int3中断指令，会让调试器在此处中断</span></span><br><span class="line"><span class="comment">//依次释放奇数堆块，避免堆块合并</span></span><br><span class="line"><span class="built_in">HeapFree</span>(hp,<span class="number">0</span>,h1); <span class="comment">//释放堆块</span></span><br><span class="line"><span class="built_in">HeapFree</span>(hp,<span class="number">0</span>,h3); </span><br><span class="line"><span class="built_in">HeapFree</span>(hp,<span class="number">0</span>,h5); <span class="comment">//现在freelist[2]有3个元素</span></span><br><span class="line"></span><br><span class="line">h1 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="整个流程解析"><a href="#整个流程解析" class="headerlink" title="整个流程解析"></a>整个流程解析</h4><ol>
<li>程序首先创建了一个大小为 0x1000 的堆区，并从其中连续申请了6个块身大小为 8 字节的堆块，加上块首实际上是6个16字节的堆块。</li>
<li>释放奇数次申请的堆块是为了<strong>防止堆块合并的发生</strong>。</li>
<li>三次释放结束后，会形成三个16个字节的空闲堆块放入空表。因为是16个字节，所以会被依次放入freelist[2]所标识的空表，它们依次是h1、h3、h5。</li>
<li>再次申请8字节的堆区内存，加上块首是16个字节，因此会从freelist[2]所标识的空表中摘取第一个空闲堆块出来，即h1。</li>
<li>如果我们<strong>手动修改h1块首中的前后向指针</strong>，能够观察到 DWORD SHOOT 的发生。</li>
</ol>
<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><ul>
<li>执行 HeapFree(hp,0,h1)语句时</li>
</ul>
<p>hp为0x003a0000, h1为0x003a0688，根据堆块结构，我们知道 h1 堆块的<u>块身起始位置为0x003a0688，块首起始位置为0x003a0680</u>。观察该语句执行后，对应的内存变化，如下：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/a1d7bc333512ca33e9c11db9997e67b7.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/a1d7bc333512ca33e9c11db9997e67b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>可见，除了块首状态变化外，0x003a0688开始的<strong>块身位置的前8个字节（Flink 和 Blink）</strong>发生了变化，由0x000000变为具体的有效地址。</p>
<p>注意到，这个是第一个16字节的堆块释放，将<br>被链入到freelist[2]空表中，而此时Flink和Blink的值都是0x003a0198，也是freelist[2]的地址。我们转到0x003a0198处，观察内存为：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/11f8dc7b87b0515b5bb1bcb38fa62830.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/11f8dc7b87b0515b5bb1bcb38fa62830.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>可见，freelist[2]的Flink和Blink都是0x003a0688。意味着，当前 freelist[2]唯一后继节点就是刚刚空闲的h1块（<strong>地址为0x003a0688</strong>），而h1块是唯一前继节点是freelist[2]。其它地址（freelist[3]、freelist[4]、freelist[5]）的Flink和Blink均<strong>指向自身</strong>，说明都是空表。</p>
<ul>
<li>执行HeapFree(hp,0,h3)和HeapFree(hp,0,h5)后</li>
</ul>
<p>可知，此时 freelist[2]链表状态为：freelist[2]&lt;=&gt;h1&lt;=&gt;h3&lt;=&gt;h5。</p>
<ul>
<li>执行HeapAlloc(hp,HEAP_ZERO_MEMORY,8)语句时</li>
</ul>
<p>此时，当再次分配空间的时候，从freelist[2]的双向链表里摘下一块大小为16字节的堆块，首先摘得h1（地址为0x003a0688）。</p>
<p>观察此时：</p>
<ol>
<li>freelist[2]（地址为0x003a0198）所存储的信息为：Flink（前4个字节）为0x003a0688，Blink（后 4 个字节）为0x003a0708。</li>
<li>h1（地址为0x003a0688）所存储的信息为：Flink 为 0x003a06c8，Blink 为 0x003a0198。</li>
<li>h3（地址为0x003a06c8）所存储的信息为：Flink 为0x003a0708，Blink为0x003a0688。摘走h1之后，内存变为：</li>
<li>freelist[2]（地址为0x003a0198）的前 4 个字节变为0x003a06c8，实际发生了将h1 后向指针（值为0x003a0198）地址处的值写为h1前向指针的值。</li>
<li>h3（地址为0x003a06c8）的Blink 变为h1-&gt;Blink，即0x003a0198，实际发生了将 h1 前向指针（值为0x003a06c8）地址处的值写为 h1后向指针的值。</li>
</ol>
<ul>
<li>Dword Shoot 攻击</li>
</ul>
<p>假设在执行该语句之前，<strong>h1的Flink和Blink被改写为特定地址和特定数值</strong>，那么就完成一<br>次Dword Shoot攻击。</p>
<blockquote>
<p>注意：在Windows XP以后的操作系统中，因为<strong>引入地址随机化</strong>等防护措施，使得此类的堆溢出Dowrd Shoot攻击变的越来越难。</p>
</blockquote>
<h2 id="其它溢出漏洞"><a href="#其它溢出漏洞" class="headerlink" title="其它溢出漏洞"></a>其它溢出漏洞</h2><h3 id="SEH结构溢出"><a href="#SEH结构溢出" class="headerlink" title="SEH结构溢出"></a>SEH结构溢出</h3><p>为了保证系统在遇到错误时不至于崩溃，仍能够健壮稳定地继续运行下去，Windows会对运行在其中的程序提供一次补救的机会来处理错误，这种机制就是<strong>异常处理机制</strong>。<br><strong>异常处理结构体SEH</strong>是Windows异常处理机制所采用的重要数据结构:</p>
<ul>
<li>SHE结构体<strong>存放在栈中</strong>，栈中的多个SEH通过<strong>链表指针</strong>在栈内由栈顶向栈底串成单向链表;</li>
<li>位于链表最顶端的SEH通过<strong>线程环境块</strong>（TEB，Thread Environment Block）0字节偏移处的指针标识;</li>
<li>每个SEH包含两个DWORD指针：<u>SEH链表指针和异常处理函数句柄</u>，共8个字节。</li>
</ul>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/4fe8d0e44169e83eed814f14c701a7af.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/4fe8d0e44169e83eed814f14c701a7af.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>SEH结构用作异常处理，主要包括如下三个方面： </p>
<ul>
<li><strong>当线程初始化时，会自动向栈中安装一个SEH，作为线程默认的异常处理。</strong>如果程序源代码中使用了_try{}_except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个SEH来实现异常处理。</li>
<li><strong>当异常发生时，操作系统会中断程序，并首先从TEB的0字节偏移处取出距离栈顶最近的SEH，使用异常处理函数句柄所指向的代码来处理异常</strong>。<u>当最近的异常处理函数运行失败时，将顺着SEH链表依次尝试其他的异常处理函数。</u></li>
<li>如果程序安装的所有异常处理函数<strong>都不能处理这个异常，系统会调用默认的系统处理程序</strong>，通常显示一个对话框，你可以选择关闭或者最后将其附加到调试器上的调试按钮。如果没有调试器能被附加于其上或者调试器也处理不了，系统就调用<code>ExitProcess</code>终结程序。</li>
</ul>
<h3 id="SEH攻击"><a href="#SEH攻击" class="headerlink" title="SEH攻击"></a>SEH攻击</h3><p>SEH攻击是指通过<strong>栈溢出</strong>或者其他漏洞，使用精心构造的数据<strong>覆盖SEH链表的入口地址、异常处理函数句柄或链表指针</strong>等，实现程序执行流程的控制。<br>因为发生异常的时候，程序会基于SEH链表转去执行一个预先设定的回调函数，攻击者可以利用这个结构进行漏洞利用攻击。</p>
<ul>
<li>由于SEH存放在栈中，利用缓冲区溢出可以覆盖SHE。</li>
<li>如果精心设计溢出数据，则有可能把SEH中异常处理函数的入口地址更改为恶意程序的入口地址，实现进程的控制。</li>
</ul>
<h3 id="SEH链表在栈中的实际分布"><a href="#SEH链表在栈中的实际分布" class="headerlink" title="SEH链表在栈中的实际分布"></a>SEH链表在栈中的实际分布</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HackExceptionHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill processn&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">ExitProcess</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">char</span>* input)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    __try    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">        zero = <span class="number">4</span> / zero;</span><br><span class="line">    &#125;__except(<span class="built_in">HackExceptionHandler</span>())</span><br><span class="line">    &#123;    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(shellcode);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拖入OllyDBG动态调试，选择<strong>View下的SEH chain选项</strong>，就能看到当前栈中的SEH的情况。</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/bac98b5900116c2c3eed7dc206112731.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/bac98b5900116c2c3eed7dc206112731.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>从图中能看出，0012FF18是离栈顶最近的SHE（<strong>此时栈顶为0x0012FFC4</strong>）。接着我们在调试的栈窗口去验证存在的SEH链，如下图：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/856a46f639c316d5b9523bfba49dc50f.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/856a46f639c316d5b9523bfba49dc50f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/9cc8723beb1d5cd1a31bf041725d8e1e.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/9cc8723beb1d5cd1a31bf041725d8e1e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="单字节溢出"><a href="#单字节溢出" class="headerlink" title="单字节溢出"></a>单字节溢出</h3><p>单字节溢出是指程序中的缓冲区仅能溢出一个字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">single_func</span><span class="params">(<span class="type">char</span> *src)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= <span class="number">256</span>;i++)</span><br><span class="line">         buf[i] = src[i];            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//感觉是水平不高的程序员写出的程序缺陷...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缓冲区溢出一般是通过覆盖堆栈中的返回地址，使程序跳转到shellcode或指定程序处执行。然而在一定条件下，<strong>单字节溢出</strong>也是可以利用的，它溢出的一个字节必须与栈帧指针紧挨，就是要求必须是函数中首个变量，一般这种情况很难出现。</p>
<h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>格式化串漏洞和普通的栈溢出有相似之处，但又有所不同，都是利用了程序员的疏忽大意来改变程序运行的正常流程。</p>
<p>首先，什么是格式化字符串呢，print()、fprint()等*print()系列的函数可以按照一定的格式将数据进行输出，举个最简单的例子：</p>
<p><code>printf(&quot;My Name is:  %s&quot; , &quot;bingtangguan&quot;)</code></p>
<p>执行该函数后将返回字符串：My Name is：bingtangguan</p>
<p>该printf函数的<strong>第一个参数</strong>就是<strong>格式化字符串</strong>，它来告诉程序<strong>将数据以什么格式输出</strong>。</p>
<hr>
<p>printf()函数的一般形式为：printf(“format”, 输出表列)</p>
<p>format的结构为：%[标志][输出最小宽度][.精度][长度]类型</p>
<p>其中类型有以下常见的几种：</p>
<ul>
<li>％d整型输出，％ld长整型输出，</li>
<li>％o以八进制数形式输出整数，</li>
<li><strong>％x以十六进制数形式输出整数，</strong></li>
<li>％u以十进制数输出unsigned型数据(无符号数)。</li>
<li>％c用来输出一个字符，</li>
<li><strong>％s读取指定地址的内容（我的理解），输出一个字符串，</strong></li>
<li>％f用来输出实数，以小数形式输出。</li>
</ul>
<p>控制format参数之后结合<code>printf()函数特性</code>就可以进行相应攻击。</p>
<h2 id="格式化字符串漏洞的利用—数据泄露"><a href="#格式化字符串漏洞的利用—数据泄露" class="headerlink" title="格式化字符串漏洞的利用—数据泄露"></a>格式化字符串漏洞的利用—数据泄露</h2><p><strong>特性一：格式化函数允许可变参数</strong></p>
<p>C语言中的<strong>格式化函数</strong>（*printf族函数，包括printf，fprintf，sprintf，snprintf等）<strong>允许可变参数</strong>，它根据传入的格式化字符串获知可变参数的个数和类型，并依据格式化符号进行参数的输出。</p>
<p>如果调用这些函数时，给出了格式化符号串，但<strong>没有提供实际对应参数时</strong>，这些<u>函数会将格式化字符串后面的多个栈中的内容取出作为参数，并根据格式化符号将其输出</u>。</p>
<blockquote>
<p>当格式化符号为%x时以16进制的形式<strong>输出堆栈的内容</strong>，为%s时则<strong>输出对应地址所指向的字符串</strong>。（也就是说%s会有地址的跳转而%x只是输出堆栈的内容）</p>
</blockquote>
<p>下面以下述程序样本为例，分析格式化字符串溢出的原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatstring_func1</span><span class="params">(<span class="type">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">char</span> mark[] = “ABCD”;</span><br><span class="line">     <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用时如果传入”%x%x…%x”，则printf会打印出堆栈中的内容，不断增加%x的个数会<strong>逐渐显示堆栈中高地址的数据</strong>，从而导致堆栈中的数据泄漏。</p>
</blockquote>
<h3 id="泄露内存数据"><a href="#泄露内存数据" class="headerlink" title="泄露内存数据"></a>泄露内存数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> buf[]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>,buf,a,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译之后运行（<strong>Debug模式</strong>）： test 1 2 3</p>
<p>增加一个printf()的format参数，改为：<br>printf(“%s %d %d %d %x\n”,buf,a,b,c)，<br>编译后运行（Debug模式）：<br> test 1 2 3 <strong>12C62E</strong></p>
<blockquote>
<p>%s读取buf指定地址的数据，读取出test</p>
<p>考虑栈帧状态，参数入栈（字符串 str 的地址）后，通过%x 依次读参数下面的内存数据时，很快就读到了原来函数的局部变量 str 的数据了。</p>
</blockquote>
<p><strong>原因</strong>：函数调用，是要参数入栈的；printf函数会到入栈的参数位置去取参数；在没有给出%x的参数的时候，将自动将栈区参数的下一个地址作为参数输入。</p>
<h3 id="读取任意内存地址的数据"><a href="#读取任意内存地址的数据" class="headerlink" title="读取任意内存地址的数据"></a>读取任意内存地址的数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">fgets</span>(str,<span class="number">200</span>,stdin);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译后运行（<strong>Release模式</strong>）并输入：AAAA%x%x%x%x</p>
<p><code>建议%x更换为%08x.</code>输出完整的8位地址</p>
<p>我们成功读到了AAAA：AAAA18FE84BB40603041414141（0x41就是ASCII的字母A的值）。</p>
<p><font color=red>思考：这个41414141是怎么读到的？</font></p>
<p>考虑栈帧状态，参数入栈（字符串 str 的地址）后，通过%x 依次读<strong>参数下面的内存数据</strong>时，很快就读到了<strong>原来函数的局部变量 str 的数据了</strong>。</p>
<p>执行printf(str)语句的时候，<u>对比Debug模式和Release模式的栈帧结构</u>：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/f29f928cb0850ae7f4fd7b4990a60022.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/f29f928cb0850ae7f4fd7b4990a60022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>用OllyDBG查看Release模式下栈帧的结构：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/6db07b25ea157300789eb2d8a6361578.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/6db07b25ea157300789eb2d8a6361578.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>Debug 模式下，因为开辟了足够大的栈帧并初始化，char str[200]是从靠近EBP的地址分配空间，如果要读到 str 的地址，需要很多的格式化字符；但是，Relase 模式下，可以看到，并没有严格按照制式的栈帧分配，而是考虑运行性能，在执行到 printf(str)的时候，栈区自顶到底部分为存着“printf 函数参数|fgets 函数参数|str 数组”的内容，在 Main 函数的 retn 语句前，才有一个 add esp XX 的处理。<br>如果将 AAAA 换成地址，第 4 个%x，换成%s的读取参数指定的地址上的数据呢？是不是就可以读取任意内存地址的数据了？<br>比如我们输入：AAAA%x%x%x%s<br>这样就构造了去获取 0x41414141 地址上的数据的输入。</p>
<blockquote>
<p>外话：起初我并不理解格式化字符串是怎么读取栈帧内容的，为了理解我调用了ollydbg查看栈帧结构，原来是printf参数不够，会往栈帧高地址读取，依次读取fgets 函数参数地址的值，然后到str的值。就是这样：）</p>
</blockquote>
<h2 id="格式化字符串漏洞的利用—数据写入"><a href="#格式化字符串漏洞的利用—数据写入" class="headerlink" title="格式化字符串漏洞的利用—数据写入"></a>格式化字符串漏洞的利用—数据写入</h2><h3 id="特性二：利用-n格式符写入数据"><a href="#特性二：利用-n格式符写入数据" class="headerlink" title="特性二：利用%n格式符写入数据"></a>特性二：利用%n格式符写入数据</h3><p>更危险的是<u>格式化符号%n</u>，它的作用是将格式化函数输出字符串的长度，写入函数参数指定的位置。</p>
<p>%n不向printf传递格式化信息，而是<strong>令printf把自己到该点已打出的字符总数放到相应变元指向的整形变量中，</strong>比如：<br>printf(“Jamsa%n”, &amp;first_count)`<br>将向整型变量first_count处写入整数5。</p>
<hr>
<p><code>Sprintf</code>函数的作用是<strong>把格式化的数据写入某个字符串缓冲区</strong>。函数原型为：</p>
<p><code>int sprintf( char *buffer, const char *format, [ argument] … );</code></p>
<p>观察如下程序（Release模式）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">formatstring_func2</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, argv[<span class="number">1</span>]);<span class="comment">//argv[1]有什么用?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果调用这段程序时用”aaaabbbbcc%n”作为命令行参数，将会怎么样？</p>
<p>结果：数值10就会被写入地址为0x61616161（aaaa）的内存单元。</p>
<ul>
<li>首先<blockquote>
<p>“aaaabbbbcc”写入buffer；</p>
</blockquote>
</li>
<li>然后<blockquote>
<p>从堆栈中取下一个参数，并将其当作整数指针使用，由于调用sprintf时<strong>没有传入下一个参数，因而buffer中的前四个字节被当作参数</strong>，这样已输出字串的长度10就被写入内存地址0x61616161处。</p>
</blockquote>
</li>
</ul>
<p>通过这种格式化字符串的利用方式，可以实现<strong>向任意内存写入任意数值</strong>。</p>
<h3 id="特性三：自定义打印字符串宽度"><a href="#特性三：自定义打印字符串宽度" class="headerlink" title="特性三：自定义打印字符串宽度"></a>特性三：自定义打印字符串宽度</h3><p><strong>实验</strong>：利用%n格式化符号和自定义打印字符串宽度，写入某内存地址任意数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：<br>Before: num = 66666666<br>66666666<br>After: num = 8</p>
<p>现在我们已经知道可以利用%n向内存中写入值，<font color=red>如果我们写的值(比如一个返回地址）非常大，怎么来构造这样的值？</font></p>
<p>关于打印字符串宽度的问题，<strong>在格式符中间加上一个十进制整数来表示输出的最少位数</strong>，<u>若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0</u>。我们把上一段代码做一下修改并看一下效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%100d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：<br>Before: num = 66666666</p>
<br/>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">66666666</span><br></pre></td></tr></table></figure>

<p>After: num = 100</p>
<p><em>我们也可以使用%02333d这种形式。在打印数值右侧用0补齐不足位数的方式来补齐，而不是空格。</em></p>
<h1 id="整数溢出漏洞"><a href="#整数溢出漏洞" class="headerlink" title="整数溢出漏洞"></a>整数溢出漏洞</h1><p>高级程序语言中，整数分为无符号数和有符号数两类，其中有符号负整数最高位为1，正整数最高位为0，无符号整数则无此限制。常见的整数类型有8位、16位、32位以及64位等，对应的每种类型整数都包含一定的范围。当对整数进行加、乘等运算时，计算的结果如果大于该类型的整数所表示的范围时，就会发生整数溢出。</p>
<p>根据溢出原理的不同，整数溢出可以分为以下三类：</p>
<ul>
<li>存储溢出<blockquote>
<p><strong>存储溢出</strong>是使用另外的数据类型来存储整型数造成的。例如，把一个大的变量放入一个小变量的存储区域，最终是<strong>只能保留小变量能够存储的位</strong>，其他的位都无法存储，以至于造成安全隐患。</p>
</blockquote>
</li>
<li>运算溢出<blockquote>
<p><strong>运算溢出</strong>是对整型变量进行运算时没有考虑到其<strong>边界范围</strong>，造成运算后的数值范围超出了其存储空间。</p>
</blockquote>
</li>
<li>符号问题<blockquote>
<p>整型数可分为有符号整型数和无符号整型数两种。在开发过程中，一般长度变量使用无符号整型数，然而如果程序员<strong>忽略了符号，在进行安全检查判断的时候就可能出现问题。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="整数溢出示例"><a href="#整数溢出示例" class="headerlink" title="整数溢出示例"></a>整数溢出示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">integer_overflow</span><span class="params">(<span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size = len + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *buffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(!buffer)       </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, data, len);</span><br><span class="line">    buffer[len]=’\’;</span><br><span class="line">      <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将用户输入的数据拷贝到新的缓冲区，并在最后写入结尾符0。如果攻击者将0xFFFFFFFF作为参数传入len，当计算size时会发生整数溢出，malloc会分配大小为0的内存块（<u>将得到有效地址</u>），后面执行memcpy时会发生堆溢出。</p>
<p><code>整数溢出一般不能被单独利用，而是用来绕过目标程序中的条件检测，进而实现其他攻击。</code></p>
<h2 id="分析如下实例"><a href="#分析如下实例" class="headerlink" title="分析如下实例"></a>分析如下实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;shellapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INFO 32767</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;notepad&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,SW_SHOW); </span><br><span class="line">    <span class="comment">//打开记事本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;calc&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,SW_SHOW);  </span><br><span class="line">    <span class="comment">//打开计算器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*fuc_ptr)() = func;</span><br><span class="line">    <span class="type">char</span> info[MAX_INFO];      </span><br><span class="line">    <span class="type">char</span> info1[<span class="number">30000</span>];</span><br><span class="line">    <span class="type">char</span> info2[<span class="number">30000</span>];</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);    </span><br><span class="line">    cin.<span class="built_in">getline</span>(info1,<span class="number">30000</span>,<span class="string">&#x27; &#x27;</span>);     </span><br><span class="line">    cin.<span class="built_in">getline</span>(info2,<span class="number">30000</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> len1 = <span class="built_in">strlen</span>(info1);</span><br><span class="line">    <span class="type">short</span> len2 = <span class="built_in">strlen</span>(info2);</span><br><span class="line">    <span class="type">short</span> all_len = len1 + len2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(all_len&lt;MAX_INFO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(info,info1);</span><br><span class="line">        <span class="built_in">strcat</span>(info,info2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fuc_ptr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>short型整数表示范围为-32768~32767，当len1+len2超过了short型整数的最大范围后会变为一个<strong>负数</strong>，将满足<strong>all_len&lt;MAX_INFO</strong>的判断条件，进而进入if的分支语句。于是继续执行if语句的时候，将info1与info2的内容都写进info中。</p>
<p><font color=red>思考：如何实现fuc_ptr的覆盖，改变程序执行？</font></p>
<h1 id="攻击C-虚函数"><a href="#攻击C-虚函数" class="headerlink" title="攻击C++虚函数"></a>攻击C++虚函数</h1><h2 id="C-面向对象语言的漏洞"><a href="#C-面向对象语言的漏洞" class="headerlink" title="C++面向对象语言的漏洞"></a>C++面向对象语言的漏洞</h2><ul>
<li><strong>多态</strong>是面向对象的一个重要特性，在C++中，这个特性主要靠对虚函数的动态调用来实现。</li>
<li>C++类的成员函数声明时，若使用关键字<code>virtual</code>进行修饰，则被称为虚函数。</li>
<li>虚函数的入口地址被统一保存在<strong>虚表</strong>（Vtable）中。</li>
<li>对象在使用虚函数时，先通过<strong>虚表指针找到虚表</strong>，然后<strong>从虚表中取出最终的函数入口地址进行调用</strong>。</li>
</ul>
<p>C++虚函数和类在内存中的位置关系如图所示：</p>
<p>（1）<strong>虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量</strong>；</p>
<p>（2）<strong>虚函数入口地址被统一存在虚表中</strong>。</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/21e4dd1a15e11e8ef6a6efc88cc7a330.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/21e4dd1a15e11e8ef6a6efc88cc7a330.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="攻击虚函数"><a href="#攻击虚函数" class="headerlink" title="攻击虚函数"></a>攻击虚函数</h2><p>对象使用虚函数时通过</p>
<p>（1）<font color=red>调用虚表指针找到虚表</font>，然后</p>
<p>（2）<font color=red>从虚表中取出最终的函数入口地址进行调用</font>。</p>
<p>如果虚表里存储的<strong>虚函数指针被篡改</strong>，程序调用虚函数的时候就会执行篡改后的指定地址的<strong>shellcode</strong>，就会发动虚函数攻击。</p>
<p>通过下述代码来复现虚函数攻击。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] =“xFC\x68\x6A….. \xA4\x8B\x42\x00”;<span class="comment">// set fake virtual function pointer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failwest</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Failwest overflow, *p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p_vtable;</span><br><span class="line">  p_vtable = overflow.buf – <span class="number">4</span>; </span><br><span class="line">  <span class="comment">//得到虚表指针</span></span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(shellcode);</span><br><span class="line">  __asm <span class="type">int</span> <span class="number">3</span>;  <span class="comment">//人为增加一个断点 </span></span><br><span class="line">  p_vtable[<span class="number">0</span>] = <span class="number">0x54</span>;</span><br><span class="line">  p_vtable[<span class="number">1</span>] = <span class="number">0x8c</span>;</span><br><span class="line">  p_vtable[<span class="number">2</span>] = <span class="number">0x42</span>;</span><br><span class="line">  p_vtable[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">  <span class="comment">//将虚表指针进行修改，修改为 0x00428c54。</span></span><br><span class="line">  <span class="comment">//这个值需要根据实际系统进行重新计算</span></span><br><span class="line">  <span class="built_in">strcpy</span>(overflow.buf, shellcode);</span><br><span class="line">  <span class="comment">//这是我们能利用的缓冲区</span></span><br><span class="line">  <span class="comment">//这意味着，恶意代码shellcode被存储到了overflow.buf位置。</span></span><br><span class="line">  <span class="comment">//shellcode(包含了我们要植入到内存中的恶意代码)</span></span><br><span class="line">  p = &amp;overflow;</span><br><span class="line">  p-&gt;<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们希望通过调用test虚函数的时候，跳转到这个位置去执行恶意代码。但是，怎么让调用test虚函数的时候，<strong>通过虚表指针找到的虚函数指针</strong>就是我们期待的目标呢？</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/195c17615edfa3f9ee341b403e54329d.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/195c17615edfa3f9ee341b403e54329d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="攻击策略"><a href="#攻击策略" class="headerlink" title="攻击策略"></a>攻击策略</h3><p>充分利用<code>overflow.buf</code>这个缓冲区：overflow.buf的地址为<code>0x00428ba4</code> ，其倒数第四个字节开始地址为<code>0x00428c54</code>。Strlen里最后一个字符是0x00，需要加上。</p>
<ul>
<li>修改虚表地址：将对象overflow的虚表地址修改为数组shellcode的倒数第四个字节开始地址。</li>
<li>修改虚函数指针：修改数组shellcode最后4位（虚表）来指向overflow.buf的内存地址，即让虚函数指针指向保存shellcode的overflow.buf区域。</li>
</ul>
<p>VC IDE进行实际调试的时候，在语句“p-&gt;test();”处转入反汇编，继续单步调试，可以看到攻击成功，弹出failwest的对话框：</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/d73c151f780822915ad962d1c896fbbc.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/d73c151f780822915ad962d1c896fbbc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h1 id="其他类型漏洞"><a href="#其他类型漏洞" class="headerlink" title="其他类型漏洞"></a>其他类型漏洞</h1><h2 id="注入类漏洞"><a href="#注入类漏洞" class="headerlink" title="注入类漏洞"></a>注入类漏洞</h2><p>注入类攻击都具备一个共同的特点：<strong>来自外部的输入数据被当作代码或非预期的指令、数据被执行，从而将威胁引入到软件或者系统。</strong><br>根据应用程序的工作方式，将代码注入分为两大类：</p>
<ul>
<li><strong>二进制代码注入</strong>，即将计算机可以执行执行的二进制代码注入到其他应用程序的执行代码中。由于程序中某些缺陷导致<u>程序的控制器被劫持</u>，使得外部代码获得执行机会，从而实现特定的攻击目的；</li>
<li><strong>脚本注入</strong>，即通过特定的<strong>脚本解释类程序</strong>提交可被解释执行的数据。由于应用在输入的过滤上存在缺陷，导致注入的脚本数据被执行。</li>
</ul>
<p>下面介绍几种Web场景下的代码注入攻击。</p>
<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>SQL（Structured query language，结构化查询语言）是操作数据库数据的结构化查询语言，用于读取、更新、增加或删除数据库中保存的信息。应用程序通过SQL语言来完成后台数据库中的数据的增加、删除、修改和查询。<br><strong>SQL注入是将Web页面的<u>原URL、表单域或数据包输入的参数</u>，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。</strong><br>如果Web应用程序的开发人员对用户所输入的数据不进行过滤或验证就直接传输给数据库，就可能导致拼接的异常SQL语句被执行，获取对数据库的信息以及提权，发生SQL注入攻击。</p>
<p><img src="/2023/03/13/ruan-jian-lou-dong-pian/96dcc87cffbb8ff43258ceefb80d3bea.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/96dcc87cffbb8ff43258ceefb80d3bea.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>strKeyword = Request[“keyword”];<br>sqlQuery = “SELECT * FROM Articles WHERE Keywords LIKE ‘%<u>” +strKeyword+ “</u>%’ ”;</p>
<p>输入<code>Hack’; DROP TABLE Aritcles; --</code></p>
<p><code>SELECT * FROM Aritcles WHERE Keywords LIKE ‘%hack’; DROP TABLE Aritcles; --%’</code></p>
<p>–是注释符，<strong>结果是以中间的分号为标志分成两个部分</strong>，执行完<code> “SELECT * FROM Aritcles WHERE Keywords LIKE ‘%hack’”</code>后，将执行<code>” DROP TABLE Aritcles;”</code></p>
<h3 id="操作系统命令注入"><a href="#操作系统命令注入" class="headerlink" title="操作系统命令注入"></a>操作系统命令注入</h3><p>操作系统命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的。<strong>大多数Web服务器都能够使用内置的API与服务器的操作系统进行几乎任何必需的交互，比如PHP中的<code>system</code>、<code>exec</code>和ASP中的<code>wscript</code>类函数。</strong>如果正确使用，这些API可以丰富Web应用的功能。但是，<u>如果应用程序向操作系统命令程序传送用户提交的输入，而且没有对输入进行过滤和检测，就可能遭受命令注入攻击。</u><br>许多定制和非定制web应用程序中都存在这种命令注入缺陷。在为企业服务器或防火墙、打印机和路由器之类的设备提供管理界面的应用程序中，这类缺陷尤其普遍。</p>
<h3 id="Web脚本语言注入"><a href="#Web脚本语言注入" class="headerlink" title="Web脚本语言注入"></a>Web脚本语言注入</h3><p>常用的ASP/PHP/JSP等<u>web脚本解释语言支持动态执行在运行时生成的代码这种特点，可以帮助开发者根据各种数据和条件动态修改程序代码</u>，这对于开发人员来说是有利的，但这也隐藏着巨大的风险。<br>这种类型的漏洞主要来自两个方面：<br>（1）<strong>合并了用户提交数据的代码的动态执行</strong>。攻击者通过提交精心设计输入，使得合并用户提交数据后的代码蕴含设定的非正常业务逻辑来实施特定攻击。<br>（2）<strong>根据用户提交的数据指定的代码文件的动态包含</strong>。<u>多数脚本语言都支持使用包含文件（include file）</u>，这种功能允许开发者把<u>可重复使用的代码插入到单个文件</u>中，在需要的时候再将它们包含到相关代码文件中。如果攻击者能修改这个文件中的代码，就让受此攻击的应用执行攻击者的代码。</p>
<h3 id="SOAP注入"><a href="#SOAP注入" class="headerlink" title="SOAP注入"></a>SOAP注入</h3><p><strong>SOAP（Simple Object Access Protocol，简单对象访问协议），是一个简单的基于XML的协议，它让应用程序跨HTTP进行信息交换。</strong>它主要用在Web服务中，<strong>通过浏览器访问的Web应用程序常常使用SOAP在后端应用程序组件之间进行通信。</strong><br>由于<strong>XML也是一种解释型语言</strong>，因此SOAP也易于遭受代码注入攻击。XML元素通过元字符&lt;&gt;和/以语法形式表示。如果用户提交的数据中包含这些字符，并被直接插入到SOAP消息中，攻击者就能够破坏消息的结构，进而破坏应用程序的逻辑或造成其他不利影响。</p>
<h2 id="权限类漏洞"><a href="#权限类漏洞" class="headerlink" title="权限类漏洞"></a>权限类漏洞</h2><p>绝大多数系统，都具备基于用户角色的访问控制功能，根据不同用户对其权限加以区分。但攻击者为了访问受限资源或使用额外功能，会利用系统存在的缺陷或漏洞，进行自身角色的<u>权限提升或权限扩展</u>。</p>
<p>权限越权又可以分为两种：<strong>水平越权与垂直越权</strong>。</p>
<h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p><strong>水平越权就是相同级别（权限）的用户或者同一角色的不同用户之间，可以越权访问、修改或者删除的非法操作。</strong>如果出现此类漏洞，那么将可能会造成大批量数据泄露，严重的甚至会造成用户信息被恶意篡改。水平权限漏洞一般出现在一个用户对象关联多个其他对象（个人资料、修改密码，订单信息，等）、并且要实现对关联对象的CURD的时候。<br>比如，当web应用程序接收到用户请求时，没有判断数据的所属人，或者在判断数据所属人时是从用户提交的参数中获取了userid，导致攻击者可以自行修改userid修改不属于自己的数据。</p>
<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p><strong>垂直越权又被分为向上越权与向下越权。</strong><br><strong>向上越权是指一个低权限用户或者根本没权限也可以做高权限用户相同的事情；向下越权是一个高级别用户可以访问一个低级别的用户信息。</strong>比如，在web应用中，如果后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。</p>

      </div>
      <div class="post-tags-categories">
        
        <div class="tags">
          
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/" class="">
              软件漏洞
            </a>
          
        </div>
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Jan</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2023/03/13/ruan-jian-lou-dong-pian/" target="_blank" title="软件漏洞篇">https://Jan-nku.github.io/2023/03/13/ruan-jian-lou-dong-pian/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2023/03/14/shu-ju-ren-zheng/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">数据认证</div>
      </div>
      
      <!-- <div class="content">
        散列函数










密码校验和









生日攻击








数字签名标准







双重签
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic4.zhimg.com/80/v2-83ea273b88e119d9615aed0d89aad4ab_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-83ea273b88e119d9615aed0d89aad4ab_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">公钥密码体系的基本概念</div>
      </div>
      <!-- <div class="content">
        公钥密码体系的基本概念
==现有一个带锁扣的盒子(加密算法)，采用传统的邮寄方式（网络通信），Alice如何把机密文件邮
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-ctn"></div> 

<!-- 修改css与js文件如下即可-->
<!-- <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script> -->
<link rel='stylesheet' href='https://unpkg.com/gitment@0.0.3/style/default.css'>


<style>
  .gitment-comment-header {
    margin: 0;
    padding: 5px;
  }
</style>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  
<aside id='l_side'>
  
    
      
        <section class="widget side_blogger">
  <div class='content'>
    
    
      <div class='text'>
        
          <h2>NKU-Jan</h2>
        
        
          <p>CS Blog</p>

        
        
          <p><span id="jinrishici-sentence">Jan's Blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="/jan_nku@163.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="https://github.com/Jan-nku/Jan-nku.github.io"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=2643292013"
              class="social fab fa-qq flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
      </div>
    
  </div>
</section>

      
    
  
  
  
    
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E"><span class="toc-text">漏洞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">缓冲区溢出漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">栈溢出漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E7%A4%BA%E4%BE%8B"><span class="toc-text">栈溢出漏洞示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">溢出漏洞利用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text">修改返回地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%B4%E6%8E%A5%E5%8F%98%E9%87%8F"><span class="toc-text">覆盖临接变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%86%E8%8A%82"><span class="toc-text">实验细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">堆溢出漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E7%A4%BA%E4%BE%8B"><span class="toc-text">堆溢出漏洞示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">堆溢出漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">堆管理结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dword-Shoot%E6%94%BB%E5%87%BB"><span class="toc-text">Dword Shoot攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dword-Shoot%E6%94%BB%E5%87%BB%E7%A4%BA%E4%BE%8B"><span class="toc-text">Dword Shoot攻击示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">整个流程解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">实验过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">其它溢出漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEH%E7%BB%93%E6%9E%84%E6%BA%A2%E5%87%BA"><span class="toc-text">SEH结构溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEH%E6%94%BB%E5%87%BB"><span class="toc-text">SEH攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEH%E9%93%BE%E8%A1%A8%E5%9C%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%88%86%E5%B8%83"><span class="toc-text">SEH链表在栈中的实际分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%AD%97%E8%8A%82%E6%BA%A2%E5%87%BA"><span class="toc-text">单字节溢出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="toc-text">格式化字符串漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E2%80%94%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2"><span class="toc-text">格式化字符串漏洞的利用—数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-text">泄露内存数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%BB%BB%E6%84%8F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">读取任意内存地址的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E2%80%94%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5"><span class="toc-text">格式化字符串漏洞的利用—数据写入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%BA%8C%EF%BC%9A%E5%88%A9%E7%94%A8-n%E6%A0%BC%E5%BC%8F%E7%AC%A6%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">特性二：利用%n格式符写入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%B8%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%BD%E5%BA%A6"><span class="toc-text">特性三：自定义打印字符串宽度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">整数溢出漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E7%A4%BA%E4%BE%8B"><span class="toc-text">整数溢出示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%A6%82%E4%B8%8B%E5%AE%9E%E4%BE%8B"><span class="toc-text">分析如下实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%BB%E5%87%BBC-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">攻击C++虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E6%BC%8F%E6%B4%9E"><span class="toc-text">C++面向对象语言的漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">攻击虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E7%AD%96%E7%95%A5"><span class="toc-text">攻击策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E"><span class="toc-text">其他类型漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E7%B1%BB%E6%BC%8F%E6%B4%9E"><span class="toc-text">注入类漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5"><span class="toc-text">sql注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5"><span class="toc-text">操作系统命令注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E6%B3%A8%E5%85%A5"><span class="toc-text">Web脚本语言注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SOAP%E6%B3%A8%E5%85%A5"><span class="toc-text">SOAP注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%B1%BB%E6%BC%8F%E6%B4%9E"><span class="toc-text">权限类漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83"><span class="toc-text">水平越权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83"><span class="toc-text">垂直越权</span></a></li></ol></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/21/wang-luo-bian-cheng/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-21</span>
                
              </div>
              <a class="post-title" href="/2023/03/21/wang-luo-bian-cheng/">网络编程</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/20/ru-qin-jian-ce-xi-tong/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-20</span>
                
              </div>
              <a class="post-title" href="/2023/03/20/ru-qin-jian-ce-xi-tong/">入侵检测系统</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/19/kang-e-yi-ruan-jian/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-19</span>
                
              </div>
              <a class="post-title" href="/2023/03/19/kang-e-yi-ruan-jian/">抗恶意软件</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/18/wang-luo-bian-fang/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-18</span>
                
              </div>
              <a class="post-title" href="/2023/03/18/wang-luo-bian-fang/">网络边防</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/17/web-shen-tou-shi-zhan/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pica.zhimg.com/80/v2-573ac3e25de03fad9c32add5a05e5cfc_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-573ac3e25de03fad9c32add5a05e5cfc_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-17</span>
                
              </div>
              <a class="post-title" href="/2023/03/17/web-shen-tou-shi-zhan/">WEB渗透实战</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>


  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="/js/fancybox/jquery.fancybox.min.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script src='https://unpkg.com/gitment@0.0.3/dist/gitment.browser.js'></script>

<script>
comment_el = '#gitment-ctn';
load_gitment = function () {
  if ($(comment_el).length) {
    var gitment = new Gitment({
      id: "2023/03/13/ruan-jian-lou-dong-pian/",
      owner: '',
      repo: '',
      oauth: {
        client_id: '',
        client_secret: '',
      },
    })
    gitment.render('gitment-ctn')
  }
}
$(document).ready(load_gitment);
document.addEventListener('pjax:complete', function () {
    load_gitment();
});
</script>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>