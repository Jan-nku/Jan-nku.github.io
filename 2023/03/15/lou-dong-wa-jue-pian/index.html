<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>漏洞挖掘篇 | Jan&#39;s Blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
    <script>
        var themeModelId = '';
        if (themeModelId) {
            localStorage.setItem('modelId', themeModelId);
        }
    </script>
    
    <script src="https://cdn.jsdelivr.net/gh/yuang01/live2d-widget@latest/autoload.js"></script>
    <script>
        var live2dOpen = eval('true') || false;
        if (!live2dOpen) {
            localStorage.setItem('waifu-display', 1609323474481);
        }
    </script>
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Jan's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

  
  <!-- 依赖于jquery和vue -->
  
    
<script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>

  

  
    
<script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>

  
  
  <!-- 预加载动画 -->
  <!-- 页面预加载动画 -->

  
    <div class="preloader_2" id="loader">
  <div class="loader"></div>
</div>

  
<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
</script>

  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">Jan&#39;s Blog</h3>
      <h5 class="drawer-box-head_desc">千磨万击还坚劲，任尔东西南北风</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/" class="drawer-menu-item-link">
                  
                    <i class="fas fa-home" aria-hidden="true"></i>
                  
                  <span class="name">首页</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/archives" class="drawer-menu-item-link">
                  
                    <i class="fas fa-archive" aria-hidden="true"></i>
                  
                  <span class="name">归档</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/tags" class="drawer-menu-item-link">
                  
                    <i class="fas fa-tags" aria-hidden="true"></i>
                  
                  <span class="name">标签</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/categories" class="drawer-menu-item-link">
                  
                    <i class="fas fa-bookmark" aria-hidden="true"></i>
                  
                  <span class="name">分类</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/about" class="drawer-menu-item-link">
                  
                  <span class="name">关于</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/resume" class="drawer-menu-item-link">
                  
                  <span class="name">简历</span>
                </a>
              
            </li>
          
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/Jan-nku/Jan-nku.github.io">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">Jan&#39;s Blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/" class="menu-item-link" title="首页">
                  
                    <i class="fas fa-home" aria-hidden="true"></i>
                  
                  <span class="name">首页</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/archives" class="menu-item-link" title="归档">
                  
                    <i class="fas fa-archive" aria-hidden="true"></i>
                  
                  <span class="name">归档</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/tags" class="menu-item-link" title="标签">
                  
                    <i class="fas fa-tags" aria-hidden="true"></i>
                  
                  <span class="name">标签</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/categories" class="menu-item-link" title="分类">
                  
                    <i class="fas fa-bookmark" aria-hidden="true"></i>
                  
                  <span class="name">分类</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/about" class="menu-item-link" title="关于">
                  
                  <span class="name">关于</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/resume" class="menu-item-link" title="简历">
                  
                  <span class="name">简历</span>
                </a>
              
            </li>
          
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/Jan-nku/Jan-nku.github.io" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        漏洞挖掘篇
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2023-03-15 |
        </span>
      

      
        <span class="post-detail-header_categories">
          <i class="iconfont iconbookmark1"></i> 分类：
          
            <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" class="post-detail-header_category">
              软件安全
            </a>
          
        </span>
      

      
        <div class="post-detail-header_wordcount">
          <span class="totalcount">
            <i class="fas fa-file-text-o"></i> 字数统计: 17.5k |
          </span>
  
          <span class="min2read">
            <i class="fas fa-clock"></i> 阅读时长: 62分钟 |
          </span>
  
          
            <span class="reading">
              <i class="fas fa-eye"></i> 阅读量：<span id="busuanzi_value_page_pv"></span>
            </span>
          
        </div>
      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h1><h2 id="漏洞挖掘方法分类"><a href="#漏洞挖掘方法分类" class="headerlink" title="漏洞挖掘方法分类"></a>漏洞挖掘方法分类</h2><h3 id="静态分析技术"><a href="#静态分析技术" class="headerlink" title="静态分析技术"></a>静态分析技术</h3><p>方法：词法分析、数据流分析、控制流分析、模型检查、定理证明、<strong>符号执行</strong>、<strong>污点传播分析</strong>等。</p>
<p>不需要运行程序、分析效率高、资源消耗低</p>
<h3 id="动态分析技术"><a href="#动态分析技术" class="headerlink" title="动态分析技术"></a>动态分析技术</h3><p>方法：模糊测试、动态<strong>污点分析</strong>、动态<strong>符号执行</strong>等</p>
<p>需要运行程序、准确率非常高、误报率很低</p>
<p>符号执行和污点分析两类技术都分别支持静态分析和动态分析</p>
<h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><strong>符号执行</strong>（Symbolic Execution）的基本思路是<u>使用符号值替代具体值，模拟程序的执行</u>。在模拟程序运行的过程中，符号执行引擎会收集程序中的语义信息，探索程序中的可达路径、分析程序中隐藏的错误。<br>动态符号执行结合了真实执行和传统符号执行技术的优点，在真实执行的过程中同时进行符号执行，可以在保证测试精度的前提下提升了执行效率。</p>
<h3 id="符号执行的基本原理"><a href="#符号执行的基本原理" class="headerlink" title="符号执行的基本原理"></a>符号执行的基本原理</h3><p>符号执行三个关键点是<strong>变量符号化</strong>、<strong>程序执行模拟</strong>和<strong>约束求解</strong>。<br><u>变量符号化</u>是指用一个符号值表示程序中的变量，所有与被符号化的变量相关的变量取值都会用符号值或符号值的表达式表示。<br><u>程序执行模拟</u>最重要的是运算语句和分支语句的模拟：</p>
<ul>
<li>对于运算语句，由于符号执行使用符号值替代具体值，所以无法直接计算得到一个明确的结果，需要<strong>使用符号表达式的方式表示变量的值</strong>。</li>
<li>对于分支语句，每当遇到分支语句，原先的一条路径就会分裂成多条路径，符号执行会记录每条分支路径的约束条件。最终，通过采用合适的路径遍历方法，符号执行可以<strong>收集到所有执行路径的约束条件表达式</strong>。</li>
</ul>
<p><u>约束求解</u>主要负责路径可达性进行判定及测试输入生成的工作。对一条路径的约束表达式，可以采用约束求解器进行求解：</p>
<ul>
<li>如有解，该路径是可达的，可以得到到达该路径的输入</li>
<li>如无解，该路径是不可达的，也无法生成到达该路径的输入</li>
</ul>
<p>符号执行有<u>代价小、效率高</u>的优点，然而由于程序执行的可能路径随着程序规模的增大呈指数级增长，从而导致符号执行技术在分析输入和输出之间关系时，存在一个路径状态空间的<strong>路径爆炸</strong>问题。由于符号执行技术进行路径敏感的遍历式检测，当程序执行路径的数量超过约束求解工具的求解能力时，符号执行技术将难以分析。</p>
<h3 id="符号执行的应用"><a href="#符号执行的应用" class="headerlink" title="符号执行的应用"></a>符号执行的应用</h3><p>符号执行已经广泛应用在软件测试、漏洞挖掘和软件破解等。</p>
<p>在<strong>软件测试</strong>中，符号执行可以获得程序执行路径的集合、路径的约束条件和输出的符号表达式，可以使用约束求解器求解出满足约束条件的各个路径的输入值，用于创建高覆盖率的测试用例。符号执行与模糊测试的结合也是当前流行的软件测试技术。<br>在<strong>漏洞挖掘</strong>中，通过符号执行技术可以获得漏洞监测点的变量符号表达式，结合路径约束条件、变量符号表达式和漏洞分析规则，可以通过约束求解的方法来求解是否存在满足或违反漏洞分析规则的值。<br>符号执行还可以用于搜索特定目标代码的到达路径，进而计算该路径的输入，用在面向特定任务（比如<strong>代码破解</strong>）的程序分析中。</p>
<h3 id="漏洞挖掘-检测是否数组越界"><a href="#漏洞挖掘-检测是否数组越界" class="headerlink" title="漏洞挖掘-检测是否数组越界"></a>漏洞挖掘-检测是否数组越界</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line">if (i &gt; 0) &#123;</span><br><span class="line">  if (i &gt; 10)</span><br><span class="line">    i = i % 10;</span><br><span class="line">  a[i] = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在a[i]=1语句处存在可能数组越界的情况<br>访问越界的约束条件是x&gt;=10 </li>
<li>整段代码存在两个if分支，经过符号执行，知道到达a[i]=1语句处有2条路径：<br>路径约束条件为x&gt;0∧x&lt;=10，此时变量i的符号表达式为x；<br>路径约束条件为x&gt;0∧x&gt;10，此时变量i的符号表达式为x%10。</li>
<li>得到两个判定条件：<br>(x&gt;0∧x&lt;=10)∧(x&gt;=10)   –有解 x=10 满足越界条件** 存在漏洞**<br>(x&gt;0∧x&gt;10)∧x%10&gt;=10)</li>
</ul>
<h2 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h2><p><strong>污点分析</strong>（Taint Analysis）通过<u>标记程序中的数据（外部输入数据或者内部数据）为污点</u>，跟踪程序处理污点数据的内部流程，进而帮助人们进行深入的程序分析和理解。</p>
<p>污点分析可以分为污点传播分析（静态分析）和动态污点分析（动态分析）。静态污点分析技术在检测时<strong>并不真正运行程序</strong>，而是通过模拟程序的执行过程来传播污点标记，而动态污点分析技术需要运行程序，同时<strong>实时传播并检测污点标记</strong>。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><strong>首先，确定污点源</strong>，即污点分析的目标来源。通常来讲，污点源表示了程序外部数据或者用户所关心的程序内部数据，是需要进行标记分析的输入数据。 </p>
<p><strong>然后，标记和分析污点</strong>。对污点源在内存中进行标记、计算涉及到污点的执行过程。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/ad59398cd44ce5524b593fa029934299.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/ad59398cd44ce5524b593fa029934299.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="污点分析核心要素"><a href="#污点分析核心要素" class="headerlink" title="污点分析核心要素"></a>污点分析核心要素</h3><ul>
<li><strong>污点源</strong>：是污点分析的目标来源（<strong>Source点</strong>），通常表示来自程序外部的不可信数据，包括硬盘文件内容、网络数据包等。</li>
<li><strong>传播规则</strong>：是污点分析的计算依据，通常包括<strong>污点扩散规则</strong>和<strong>清除规则</strong>，其中普通赋值语句、计算语句可使用扩散规则，而常值赋值语句则需要利用清除规则进行计算。</li>
<li><strong>污点检测</strong>：是污点分析的功能体现，其通常在程序执行过程中的敏感位置（<strong>Sink点</strong>）进行<strong>污点判定</strong>，而敏感位置主要包括程序跳转和系统函数调用等。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>污点分析的核心是分析输入参数和执行路径之间的关系，它<strong>适用于由输入参数引发漏洞的检测</strong>，比如SQL注入漏洞等。</p>
<p>污点分析技术具有<strong>较高的分析准确率</strong>，然而针对大规模代码的分析，由于<strong>路径数量较多</strong>，因此其分析的性能会受到较大的影响。</p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>词法分析通过对代码<strong>进行基于文本或字符标识的匹配分析对比</strong>，以查找<strong>符合特定特征和词法规则</strong>的危险函数、API或简单语句组合。</p>
<p><strong>主要思想</strong>是将代码文本与归纳好的缺陷模式（比如边界条件检查）进行匹配，以此发现漏洞。<br><strong>优点</strong>：算法简单，检测性能较高<br><strong>缺点</strong>：只能进行表面的词法检测，不能进行语义方面的深层次分析，因此可以检测的安全缺陷和漏洞较少，会出现<strong>较高的漏报和误报</strong>，尤其对于高危漏洞无法进行有效检测。</p>
<h2 id="漏洞挖掘实战"><a href="#漏洞挖掘实战" class="headerlink" title="漏洞挖掘实战"></a>漏洞挖掘实战</h2><h3 id="实践一：基于词法分析和逆向分析的可执行代码静态检测"><a href="#实践一：基于词法分析和逆向分析的可执行代码静态检测" class="headerlink" title="实践一：基于词法分析和逆向分析的可执行代码静态检测"></a>实践一：基于词法分析和逆向分析的可执行代码静态检测</h3><p><strong>核心思想</strong>：根据二进制可执行文件的格式特征，从<strong>二进制文件的头部</strong>、<strong>符号表</strong>以及<strong>调试信息中提取安全敏感信息</strong>（<font color=red>识别危险函数</font>），来分析文件中是否存在安全缺陷。</p>
<ol>
<li>找到敏感函数，比如memcpy、strcpy等</li>
<li>回溯函数的参数</li>
<li>判断栈和操作参数的大小关系，以定位是否发生了<u>溢出漏洞</u></li>
</ol>
<h3 id="实验一：基于IDA-Pro分析给定的可执行文件是否存在溢出漏洞"><a href="#实验一：基于IDA-Pro分析给定的可执行文件是否存在溢出漏洞" class="headerlink" title="实验一：基于IDA Pro分析给定的可执行文件是否存在溢出漏洞"></a>实验一：基于IDA Pro分析给定的可执行文件是否存在溢出漏洞</h3><p>对于<code>findoverflow.exe</code>，是通过vc6代码生成的Release版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void makeoverflow(char *b)&#123;</span><br><span class="line">    char des[5];</span><br><span class="line">    strcpy(des,b);</span><br><span class="line">&#125;</span><br><span class="line">void main(int argc,char *argv[])&#123;</span><br><span class="line">    if(argc&gt;1)    &#123;  </span><br><span class="line">           if(strstr(argv[1],&quot;overflow&quot;)!=0)</span><br><span class="line">                  makeoverflow(argv[1]);</span><br><span class="line">    &#125;   else </span><br><span class="line">          printf(&quot;usage: findoverflow XXXXX\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第一步：通过IDA打开所生成的exe文件"><a href="#第一步：通过IDA打开所生成的exe文件" class="headerlink" title="第一步：通过IDA打开所生成的exe文件"></a>第一步：通过IDA打开所生成的exe文件</h4><p><img src="/2023/03/15/lou-dong-wa-jue-pian/7ddd3d97d4a4808d78cfd78667678a03.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/7ddd3d97d4a4808d78cfd78667678a03.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>通过该视图，可见，主要有一个<code>main</code>函数，在该函数中可能有跳转，调用了<code>sub_401000</code>函数、<code>_strstr</code>函数和<code>_printf</code>函数。此外，还定义了两个字符串常量，<code>aUsageFindoverf</code>，在其上点右键-&gt;Text view，可以看到：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/5bf72c22dafd8a0f4fc6301a2c185af5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/5bf72c22dafd8a0f4fc6301a2c185af5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>打开main函数汇编代码如下：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/6d4227e5df153af22f4dfbd77a95109f.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/6d4227e5df153af22f4dfbd77a95109f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<blockquote>
<p>注意：通常在IDA的反汇编中，arg_x表示函数参数x的位置，var_8表示局部变量的位置；[]是内存寻址，**[x+arg_x]通常表示的就是arg_x的地址值**。</p>
<p>由release和debug生成的汇编代码是截然不同的，release版本非常简洁，执行效率优先，debug版本则严格按照语法结构，而且增加了很多方便调试的附加信息。</p>
</blockquote>
<h4 id="第二步：定位敏感函数"><a href="#第二步：定位敏感函数" class="headerlink" title="第二步：定位敏感函数"></a>第二步：定位敏感函数</h4><p>在主函数中，Printf函数无任何格式化参数存在，因此，敏感函数的可能在于sub_401000函数中，打开该函数的代码如图所示：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/f25857d5f6215bcb986f3acd66bcec2e.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/f25857d5f6215bcb986f3acd66bcec2e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ul>
<li>一个输入参数arg_0，一个局部变量var_8。</li>
<li>通过“lea edx, [esp+8+var_8]”和“mov edi, edx”可知，向目标寄存器存储了目标字符串的地址，为局部变量var_8；</li>
<li>通过“mov edi,[esp+10h+arg_0]”以及后面的“mov esi, edi”，可知，将函数的输入参数作为源字符串。</li>
</ul>
<p>那么到底是否发生了溢出呢？</p>
<p>通过“sub esp 8”可以知道栈大小为8，因此，函数的局部变量var_8的大小最大就是8。这样的话，可以得到sub_401000函数的代码结构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sub_401000(arg_0)</span><br><span class="line">&#123;</span><br><span class="line">    Char var_8[8];</span><br><span class="line">    Strcpy(var_8, arg_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的字符串的长度大于8，就可能发生溢出了——需要验证。</p>
<p><font color=red>为什么是8，而不是源代码里的5？</font></p>
<p>打开DOS对话框，运行示例程序，如果不给任何参数的话，会提示：usage: findoverflow XXXXX<br>如果输入参数，比如：findoverflow ssssssssss。却可以运行成功。<br>这是为什么呢？回顾逆向的反汇编代码，可以知道：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/41ea5fae271f7eebaacef024c2f16dd3.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/41ea5fae271f7eebaacef024c2f16dd3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>由于程序需要先判断是否包含子串overflow，因此，需要构造的输入需要满足这个条件。</p>
<p>输入：findoverflow overflow，此时出现缓冲区溢出的弹出窗口了。<br><strong>基于此溢出漏洞，就可以进行漏洞的利用了。</strong></p>
<h3 id="实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘"><a href="#实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘" class="headerlink" title="实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘"></a>实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘</h3><p>Bugscam是一个IDA工具的idc脚本的轻量级的漏洞分析工具，通过检测栈溢出漏洞的<code>strcpy</code>，<code>sprintf</code>危险函数的位置，然后根据这些函数的参数，确定是否有缓冲区溢出漏洞。</p>
<p>下载网址：<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/bugscam/">https://sourceforge.net/projects/bugscam/</a></p>
<ol>
<li>1、<strong>将Bugscam文件解压放到任意地方</strong>，然后<strong>修改</strong>globalvar.idc文件中头行的bugscam_dir为你的bugscam<strong>目录的全路径</strong>（路径不能含有中文）。</li>
<li>启动ida，<strong>加载任意一个x86程序文件（本例为idc.exe）</strong>，然后<strong>打开脚本文件</strong><code>run_analysis.idc</code>，运行即可，等待分析完毕，最后的分析报告结果保存在reports目录中的html文件中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">void vul(char*bu1)&#123;</span><br><span class="line">    char a[200];</span><br><span class="line">    lstrcpy(a,bu1);</span><br><span class="line">                 printf(&quot;%s&quot;,a);</span><br><span class="line">    return;    &#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">    char b[1024];</span><br><span class="line">    memset(b,&#x27;l&#x27;,sizeof(b));</span><br><span class="line">    vul(b);      &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/15/lou-dong-wa-jue-pian/1e9f22982a27978274eacd6f9cd9e27a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/1e9f22982a27978274eacd6f9cd9e27a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>其中，<u>Severity是威胁等级，越高说明漏洞危险级别越高</u>。本例的程序中，lstrcpyA函数存在溢出漏洞，地址401010处的代码可能将向目标203字节的区域写入1024字节的数据。</p>
<h1 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>数据流分析</strong>是一种用来获取<u>相关数据沿着程序执行路径流动的信息分析技术</u>，分析对象是程序执行路径上的<u>数据流动或可能的取值</u>。</p>
<p>按照分析程序路径的深度，将数据流分析分为<strong>过程内分析</strong>和<strong>过程间分析</strong>。</p>
<h2 id="数据流分析方法分类"><a href="#数据流分析方法分类" class="headerlink" title="数据流分析方法分类"></a>数据流分析方法分类</h2><p><strong>过程内分析</strong>只针对程序中函数内的代码进行分析，又分为：</p>
<ul>
<li>流不敏感分析(flow insensitive)：按代码行号从上而下进行分析；</li>
<li>流敏感分析(flow sensitive)：首先产生<strong>程序控制流图</strong>(Control FLow Graph，CFG)，再按照CFG的拓扑排序正向或逆行分析；</li>
<li>路径敏感分析(path sensitive)：不仅考虑到语句的先后顺序，还会考虑语句可达性，即会沿实际可执行到路径进行分析。</li>
</ul>
<p><strong>过程间分析</strong>则考虑函数之间的数据流，即需要跟踪分析目标数据在函数之间的传递过程。</p>
<ul>
<li>上下文不敏感分析：忽略调用位置和函数取值等函数调用的相关信息。</li>
<li>上下文敏感分析：对不同调用位置调用的同意函数加以区分。</li>
</ul>
<h2 id="程序代码模型"><a href="#程序代码模型" class="headerlink" title="程序代码模型"></a>程序代码模型</h2><p><u>数据流分析使用的程序代码模型</u>主要包括<strong>程序代码的中间表示</strong>以及一些<strong>关键的数据结构</strong>，利用程序代码的中间表示可以对程序语句的指令语义进行分析。</p>
<p><strong>抽象语法树</strong>。是程序抽象语法结构的树状表现形式，其<u>每个内部节点代表一个运算符</u>，该节点的<u>子节点代表这个运算符的运算分量</u>。通过描述控制转移语句的语法结构，抽象语法树在一定程度上也描述了程序的过程内代码的控制流结构。<br>举例，对于表达式“1+3*(4-1)+2”，其抽象语法树为：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/eb993a57d6c3f8ac0783346a45173a47.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/eb993a57d6c3f8ac0783346a45173a47.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>三地址码</strong>。三地址码（Three address code，TAC）是一种<strong>中间语言</strong>，由一组类似于汇编语言的指令组成，每个指令具有不多于三个的运算分量。每个运算分量都像是一个寄存器。</p>
<p>通常的三地址码指令包括下面几种：</p>
<p><code>x = y op z </code>：表示 y 和 z 经过 op 指示的计算将结果存入 x<br><code>x = op y</code> ：表示 y 经过操作 op 的计算将结果存入 x<br><code>x = y</code> ：表示赋值操作<br><code>goto L</code> ：表示无条件跳转<br><code>if x goto L</code> ：表示条件跳转<br><code>x = y[i]</code> ：表示数组赋值操作<br><code>x = &amp;y 、 x = *y</code> ：表示对地址的操作<br><code>param x1, param x2, call p</code>：表示过程调用 p(x1, x2)</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/6fbf143721383084d76afb912e74ad50.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/6fbf143721383084d76afb912e74ad50.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>控制流图</strong>。控制流图(Control FLow Graph，CFG)通常是指用于<strong>描述程序过程内</strong>的控制流的<strong>有向图</strong>。控制流由节点和有向边组成。节点可以是单条语句或程序代码段。有向边表示节点之间存在潜在的控制流路径。</p>
<p>(a)有一个if-then-else语句；(b)有一个while循环;</p>
<p>(c)有两个出口的自然环路;(d)有两个入口的循环。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/8a9ccd6ebfc59baf5cd5e82893b3f1b8.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8a9ccd6ebfc59baf5cd5e82893b3f1b8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>调用图</strong>。调用图(Call Graph，CG)是描述<strong>程序中过程之间</strong>的调用和被调用关系的有向图，满足如下原则：对程序中的每个过程都有一个节点；对每个调用点都有一个节点；如果调用点c调用了过程p，就存在一条从c的节点到p的节点的边。</p>
<h2 id="基于数据流的漏洞分析流程"><a href="#基于数据流的漏洞分析流程" class="headerlink" title="基于数据流的漏洞分析流程"></a>基于数据流的漏洞分析流程</h2><p>基于数据流的漏洞分析技术是通过分析软件代码中<strong>变量的取值变化</strong>和<strong>语句的执行情况</strong>，来<strong>分析数据处理逻辑和程序的控制流关系</strong>，从而分析软件代码的潜在安全缺陷。基于数据流的漏洞分析的一般流程为：</p>
<ul>
<li>首先，进行代码建模，将代码构造为<u>抽象语法树或程序控制流图</u>；</li>
<li>然后，追踪获取变量的变化信息，根据<strong>漏洞分析规则</strong>检测安全缺陷和漏洞。</li>
</ul>
<p>基于数据流的漏洞分析非常<strong>适合检查因控制流信息非法操作而导致的安全问题</strong>，如内存访问越界、常数传播等。由于对于逻辑复杂的软件代码，其数据流复杂，并呈现多样性的特点，因而检测的<u>准确率较低，误报率较高</u>。</p>
<h3 id="示例一：检测指针变量的错误使用"><a href="#示例一：检测指针变量的错误使用" class="headerlink" title="示例一：检测指针变量的错误使用"></a>示例一：检测指针变量的错误使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int contrived(int *p, int *w, int x) &#123;</span><br><span class="line">  int *q;</span><br><span class="line">  if (x) &#123;</span><br><span class="line">    kfree(w); // w free</span><br><span class="line">    q = p;</span><br><span class="line">  &#125;else</span><br><span class="line">    q=w;</span><br><span class="line">  return *q; // p use after free</span><br><span class="line">&#125;</span><br><span class="line">int contrived_caller(int *w, int x, int *p) &#123;</span><br><span class="line">  kfree(p); // p free</span><br><span class="line">  [...]</span><br><span class="line">  int r = contrived(p, w, x);</span><br><span class="line">  [...]</span><br><span class="line">  return *w; // w use after free</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在检测指针变量的错误使用时，我们关心的是变量的状态。左侧代码可能出现<code>use-after-free</code>漏洞。</p>
<p><strong>漏洞分析规则</strong>。下面是用于检测指针变量错误使用的检测规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v 被分配空间 &gt; v.start</span><br><span class="line">v.start: &#123;kfree(v)&#125; &gt; v.free</span><br><span class="line">v.free: &#123;*v&#125; &gt; v.useAfterFree</span><br><span class="line">v.free: &#123;kfree(v)&#125; &gt; v.doubleFree</span><br></pre></td></tr></table></figure>

<p><strong>代码建模</strong>。这里我们采用路径敏感的数据流分析，控制流图如下</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/48972ef60673cc4a87055e8dc83c0c82.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/48972ef60673cc4a87055e8dc83c0c82.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>漏洞分析</strong>。分析过程从函数contrived_caller的入口点开始，可知调用函数contrived的时候p的状态为p.free。分析函数contrived中的两条路径：</p>
<ul>
<li><strong>1-&gt;2-&gt;3-&gt;4-&gt;6</strong>：在进行到6时，6的前置条件是p.free、w.free、q.free，此时语句return *q将触发use-after-free规则并设置q.useAfterFree状态。然后返回到函数contrived_caller的4，其前置条件为p.useAfterFree、w.free，此时语句return *w设置w.useAfterFree。因此，存在use-after-free漏洞。 </li>
<li><strong>1-&gt;2-&gt;5-&gt;6</strong>：该路径是安全的。</li>
</ul>
<h3 id="示例二：检测缓冲区溢出"><a href="#示例二：检测缓冲区溢出" class="headerlink" title="示例二：检测缓冲区溢出"></a>示例二：检测缓冲区溢出</h3><p>在检测缓冲区溢出时，我们<strong>关心的是变量的取值</strong>，并在一些预定义的<strong>敏感操作</strong>所在的程序点上，<strong>对变量的取值进行检查</strong>。下面是一些记录变量的取值的规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char s[n];                    // len(s) = n</span><br><span class="line">strcpy(des, src);          // len(des) &gt; len(src)</span><br><span class="line">strncpy(des, src, n);    // len(des) &gt; min(len(src), n)</span><br><span class="line">s = &quot;foo&quot;;                    // len(s) = 4</span><br><span class="line">strcat(s, suffix);          // len(s) = len(s) + len(suffix) - 1</span><br><span class="line">fgets(s, n, ...);             // len(s) &gt; n</span><br></pre></td></tr></table></figure>

<h1 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>模糊测试(Fuzzing)是一种自动化或半自动化的安全漏洞检测技术，通过向目标软件输入大量的<font color=red>畸形数据</font>并<strong>监测目标系统的异常</strong>来发现潜在的软件漏洞。</li>
<li>模糊测试属于<strong>黑盒测试</strong>的一种，它是一种有效的动态漏洞分析技术，黑客和安全技术人员使用该项技术已经发现了大量的未公开漏洞。</li>
<li>它的缺点是<strong>畸形数据的生成具有随机性</strong>，而随机性造成代码覆盖不充分导致<strong>测试数据覆盖率不高</strong>。</li>
</ul>
<h2 id="模糊测试分类"><a href="#模糊测试分类" class="headerlink" title="模糊测试分类"></a>模糊测试分类</h2><h3 id="基于生成的模糊测试"><a href="#基于生成的模糊测试" class="headerlink" title="基于生成的模糊测试"></a>基于生成的模糊测试</h3><p>它是指<strong>依据特定的文件格式或者协议规范组合生成测试用例</strong>，该方法的关键点在于既要<font color=red>遵守被测程序的输入数据的规范要求</font>，又要能变异出区别于正常的数据。</p>
<h3 id="基于变异的迷糊测试"><a href="#基于变异的迷糊测试" class="headerlink" title="基于变异的迷糊测试"></a>基于变异的迷糊测试</h3><p>它是指<strong>在原有合法的测试用例基础上，通过变异策略生成新的测试用例</strong>。变异策略可以是<u>随机变异策略</u>、<u>边界值变异策略</u>、<u>位变异策略等</u>等，但前提条件是给定的初始测试用例是<strong>合法的输入</strong>。</p>
<h2 id="模糊测试步骤"><a href="#模糊测试步骤" class="headerlink" title="模糊测试步骤"></a>模糊测试步骤</h2><ol>
<li>确定测试对象和输入数据</li>
</ol>
<blockquote>
<p>由于所有可被利用的漏洞都是由于应用程序接受了<strong>用户输入的数据</strong>造成的，并且在处理输入数据时没有首先过滤非法数据或者进行校验确认。对模糊测试来说<strong>首要的问题是确定可能的输入数据，畸形输入数据的枚举对模糊测试至关重要</strong>。</p>
</blockquote>
<ol start="2">
<li>生成模糊测试数据</li>
</ol>
<blockquote>
<p>一旦确定了输入数据，接着就可以生成模糊测试用的畸形数据。根据目标程序及输入数据格式的不同，可相应选择不同的测试数据生成算法。 </p>
</blockquote>
<ol start="3">
<li>检测模糊测试数据</li>
</ol>
<blockquote>
<p>检测模糊测试数据的过程首先要<strong>启动目标程序</strong>，然后<strong>把生成的测试数据输入到应用程序中进行处理</strong>。 </p>
</blockquote>
<ol start="4">
<li>监测程序异常</li>
</ol>
<blockquote>
<p>在模糊测试过程中，一个非常重要但却经常被忽视的步骤是对程序异常的监测。实时监测目标程序的运行，就能追踪到引发目标程序异常的源测试数据。 </p>
</blockquote>
<ol start="5">
<li>确定可利用性</li>
</ol>
<blockquote>
<p>一旦监测到程序出现的异常，还需要<strong>进一步确定所发现的异常情况是否能被进一步利用</strong>。这个步骤不是模糊测试必需的步骤，只是检测这个异常对应的漏洞是否可以被利用。这个步骤<strong>一般由手工完成</strong>，需要分析人员具备深厚的漏洞挖掘和分析经验。</p>
</blockquote>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/cacf4f48856672f612de79e96a8c0962.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/cacf4f48856672f612de79e96a8c0962.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>除了最后一步确定可利用性外，所有其它的四个阶段都是必须的。</p>
<p>尽管模糊测试对安全缺陷和漏洞的检测能力很强，但并不是说它对被测软件都能发现所有的错误，原因就是它测试样本的生成方式具有<strong>随机性</strong>。 </p>
<h2 id="智能模糊测试"><a href="#智能模糊测试" class="headerlink" title="智能模糊测试"></a>智能模糊测试</h2><ul>
<li>模糊测试方法是应用最普遍的动态安全检测方法，但由于模糊测试数据的生成具有随机性，<strong>缺乏对程序的理解</strong>，测试的性能不高，并且难以保证一定的覆盖率。</li>
<li>为了解决这个问题，引入了基于符号执行、污点传播分析等可进行程序理解的方法，在实现<strong>程序理解</strong>的基础上，有针对性的设计测试数据的生成，从而实现了比传统的随机模糊测试更高的效率，这种结合了程序理解和模糊测试的方法，称为<strong>智能模糊测试</strong>(smart Fuzzing)技术。</li>
</ul>
<h3 id="智能模糊测试具体的实现步骤"><a href="#智能模糊测试具体的实现步骤" class="headerlink" title="智能模糊测试具体的实现步骤"></a>智能模糊测试具体的实现步骤</h3><ol>
<li>反汇编</li>
</ol>
<blockquote>
<p>智能模糊测试的前提，是对可执行代码进行输入数据、控制流、执行路径之间相关关系的分析。为此，首先对可执行代码进行反汇编得到<strong>汇编代码</strong>，在汇编代码的基础上才能进行上述分析。</p>
</blockquote>
<ol start="2">
<li>中间语言转换</li>
</ol>
<blockquote>
<p>从汇编代码中直接获取程序运行的内部信息，工作量较大，为此，需要将汇编代码转换成中间语言，由于<strong>中间语言易于理解</strong>，所以为可执行代码的分析提供了一种有效的手段。</p>
</blockquote>
<ol start="3">
<li>采用智能技术分析输入数据和执行路径的关系</li>
</ol>
<blockquote>
<p>这一步是智能模糊测试的关键，它通过符号执行和约束求解技术、污点传播分析、执行路径遍历等技术手段，检测出<strong>可能产生漏洞的程序执行路径集合和输入数据集合</strong>。例如，利用符号执行技术在符号执行过程中记录下输入数据的传播过程和传播后的表达形式，并通过约束求解得到在漏洞触发时执行的路径与原始输入数据之间的联系，从而得到触发执行路径异常的输入数据。</p>
</blockquote>
<ol start="4">
<li>利用分析获得的输入数据集合，对执行路径集合进行测试</li>
</ol>
<blockquote>
<p>采用上述智能技术获得的输入数据集合进行安全检测，<strong>使后续的安全测试检测出安全缺陷和漏洞的机率大大增加</strong>。与传统的随机模糊测试技术相比，这些<strong>智能模糊测试技术</strong>的应用，由于了解了输入数据和执行路径之间的关系，因而<strong>生成的输入数据更有针对性</strong>，减少了大量无关测试数据的生成，提高了测试的效率。此外，在触发漏洞的同时，智能模糊测试技术包含了对漏洞成因的分析，极大减少了分析人员的工作量。</p>
</blockquote>
<h3 id="智能模糊测试的核心思想"><a href="#智能模糊测试的核心思想" class="headerlink" title="智能模糊测试的核心思想"></a>智能模糊测试的核心思想</h3><p><strong>在于以尽可能小的代价找出程序中最有可能产生漏洞的执行路径集合</strong>，从而避免了盲目地对程序进行全路径覆盖测试，使得漏洞分析更有针对性。<br>智能模糊测试技术的提出，反映了软件安全性测试由模糊化测试向精确化测试转变的趋势。是典型的技术融合的漏洞挖掘测试方法。</p>
<h2 id="模糊测试实践"><a href="#模糊测试实践" class="headerlink" title="模糊测试实践"></a>模糊测试实践</h2><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><p>用来实现Fuzzing测试的工具叫做Fuzzer。</p>
<p>成品的Fuzzer工具很多，许多是非常优秀的。Fuzzer根据测试类型可以分为很多类，常见的分类包括：<strong>文件型Fuzzer</strong>、网络型Fuzzer、接口型Fuzzer等。</p>
<p>下方工具可以生成多个文件测试用例，发现了Office2003的典型漏洞。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/51ffe1ce3d9c9227a5be06267f46733b.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/51ffe1ce3d9c9227a5be06267f46733b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="自己动手写Fuzzer"><a href="#自己动手写Fuzzer" class="headerlink" title="自己动手写Fuzzer"></a>自己动手写Fuzzer</h3><p>使用模糊测试工具在很多时候不能解决所有问题：</p>
<ul>
<li>比如：被测试的目标程序对测试数据有一定的要求，而实际的Fuzzer不能灵活调整发送的测试数据；被测试的目标程序过于简单或者难，而<strong>现有的Fuzzer程序不能提供适合的测试</strong>。</li>
<li><strong>作为漏洞发掘者我们最好能学会编写一个Fuzzer</strong>，这样就可以随时随地的进行安全测试。而事实上，<u>目前的多数漏洞挖掘过程，是需要自己手动编写Fuzzer来完成</u>。</li>
</ul>
<p>对于目标的可执行文件overflow.exe文件，是由如下程序生成的exe程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">void overflow(char *b)&#123;</span><br><span class="line">    char des[50];</span><br><span class="line">    strcpy(des,b);</span><br><span class="line">&#125;</span><br><span class="line">void main(int argc,char *argv[])&#123;</span><br><span class="line">    if(argc&gt;1)    &#123; </span><br><span class="line">        overflow(argv[1]);</span><br><span class="line">    &#125;   else </span><br><span class="line">        printf(&quot;usage: overflow XXXXX\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>书写Fuzzer</strong>。在明确了输入的要求和暴力测试的循环条件后，可以写出如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main(int argc,char *argv[])&#123; </span><br><span class="line">    char *testbuf=&quot; &quot;;    char buf[1024];</span><br><span class="line">    memset(buf,0,1024); </span><br><span class="line">    if(argc&gt;1) &#123; </span><br><span class="line">        for(int i=20;i&lt;50;i=i+2) &#123;</span><br><span class="line">          testbuf=new char[i];</span><br><span class="line">           memset(testbuf,&#x27;c&#x27;,i); </span><br><span class="line">          memcpy(buf,testbuf,i);     </span><br><span class="line">          ShellExecute(NULL,&quot;open&quot;,argv[1],buf,NULL,SW_NORMAL);</span><br><span class="line">          delete testbuf;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    else printf(&quot;Fuzzing X \n其中X为被测试目标程序所在路径&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一个<code>for</code>循环（循环次数根据实际情况去设计）<strong>构造不同的字符串作为输入</strong>，通过<code>“ShellExecute(NULL,&quot;open&quot;,argv[1],buf,NULL,SW_NORMAL); “</code>来<strong>实现对目标程序的模糊测试</strong>。<br>上述Fuzzer的调用格式为：Fuzzing X 。X表示目标程序。<br>请完成上述实验并进行结果验证。</p>
<h1 id="AFL模糊测试框架"><a href="#AFL模糊测试框架" class="headerlink" title="AFL模糊测试框架"></a>AFL模糊测试框架</h1><h2 id="AFL模糊测试框架-1"><a href="#AFL模糊测试框架-1" class="headerlink" title="AFL模糊测试框架"></a>AFL模糊测试框架</h2><ul>
<li>AFL是一款<font color=red>基于覆盖引导（Coverage-guided）</font>的模糊测试工具，它通过<strong>记录输入样本的代码覆盖率</strong>，从而调整输入样本以<strong>提高覆盖率</strong>，增加发现漏洞的概率。</li>
<li>AFL主要用于C/C++程序的测试，被测程序有无程序源码均可，有源码时可以对源码进行编译时插桩，无源码可以借助QEMU的User_Mode模式进行二进制插桩。</li>
<li>支持多平台（ARM、X86、X64）、多系统（Linux、BSD、Windows、MacOS），性能高。</li>
</ul>
<h2 id="AFL工作流程"><a href="#AFL工作流程" class="headerlink" title="AFL工作流程"></a>AFL工作流程</h2><ul>
<li>从源码编译程序时进行<strong>插桩</strong>，以<strong>记录代码覆盖率</strong>；</li>
<li>选择一些输入文件作为初始测试集加入输入队列；</li>
<li>将队列中的文件按策略进行<strong>“突变”</strong>；</li>
<li><font color=red>如果经过变异文件更新了覆盖范围，则保留在队列中；</font></li>
<li>循环进行，期间<strong>触发了crash（异常结果）的文件</strong>会被记录下来。</li>
</ul>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/44936da4faf41a7e6095e54730362d1a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/44936da4faf41a7e6095e54730362d1a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="AFL安装"><a href="#AFL安装" class="headerlink" title="AFL安装"></a>AFL安装</h2><p><img src="/2023/03/15/lou-dong-wa-jue-pian/767dfe02556cda1812d7d3d2825a380c.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/767dfe02556cda1812d7d3d2825a380c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="AFL模糊测试"><a href="#AFL模糊测试" class="headerlink" title="AFL模糊测试"></a>AFL模糊测试</h2><p><img src="/2023/03/15/lou-dong-wa-jue-pian/26d5986914d6d2687da4a849a6d87acf.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/26d5986914d6d2687da4a849a6d87acf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>以一个白盒模糊测试为例。</p>
<h3 id="创建本次实验的程序"><a href="#创建本次实验的程序" class="headerlink" title="创建本次实验的程序"></a>创建本次实验的程序</h3><p>新建文件夹demo，并创建实验的程序<code>Test.c</code>，该代码编译后得到的程序如果被传入“deadbeef”则会终止，如果传入其他字符会原样输出。<br>使用afl的编译器编译，可以使模糊测试过程更加高效。<br>命令：<code>afl-gcc -o test test.c</code></p>
<p>编译后会有插桩符号，使用下面的命令可以验证这一点。<br>命令：<code>readelf -s ./test | grep afl</code></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/fefb53ad23e06ec65fc9ed36fd0685d5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/fefb53ad23e06ec65fc9ed36fd0685d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="创建测试用例"><a href="#创建测试用例" class="headerlink" title="创建测试用例"></a>创建测试用例</h3><p>首先，创建两个文件夹in和out，分别存储模糊测试所需的输入和输出相关的内容。<br>命令：<code>mkdir in out</code><br>然后，在输入文件夹中创建一个包含字符串“hello”的文件。<br>命令：<code>echo hello&gt; in/foo</code><br>foo就是我们的测试用例，里面包含初步字符串hello。AFL会通过这个语料进行变异，构造更多的测试用例。</p>
<h3 id="启动模糊测试"><a href="#启动模糊测试" class="headerlink" title="启动模糊测试"></a>启动模糊测试</h3><p>运行如下命令，开始启动模糊测试（@@表示目标程序需要从文件读取输入）：</p>
<p>命令：<code>afl-fuzz -i in -o out -- ./test @@</code></p>
<h3 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h3><p>观察fuzzing结果，如有crash，定位问题。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/01dd17ced6e0b96b2a219c3146416f4a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/01dd17ced6e0b96b2a219c3146416f4a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ul>
<li>在out文件夹的<strong>crashes子文件夹里面是产生crash的样例</strong>，hangs里面是产生超时的样例。</li>
<li>通常，<strong>得到crash样例后，可以将这些样例作为目标测试程序的输入，重新触发异常并跟踪运行状态</strong>，进行分析、定位程序出错的原因或确认存在的漏洞类型。</li>
</ul>
<br/>

<hr>
<h1 id="程序切片技术"><a href="#程序切片技术" class="headerlink" title="程序切片技术"></a>程序切片技术</h1><h2 id="程序切片定义"><a href="#程序切片定义" class="headerlink" title="程序切片定义"></a>程序切片定义</h2><p>程序切片旨在从程序中提取满足一定约束条件的代码片段（<u>对指定变量施加影响的代码指令，或者指令变量所影响的代码片段</u>），是一种重要的程序分解技术。</p>
<p><strong>程序切片可以从大规模程序中精确定位分析员所关心的代码片段</strong>，有效缓解程序规模日益增长带来的分析效率难以同步提高的问题。比如，在漏洞挖掘中，我们可以只关注可执行文件或者源代码某一行敏感函数调用相关的代码片段，来分析是否存在缓冲区溢出漏洞等。</p>
<p><strong>定义</strong>：给定一个切片准则<strong>C=(N, V)<strong>，其中N表示程序P中的<u>指令</u>，V表示<u>变量集</u>，程序P关于C的</strong>映射</strong>即为程序切片。换句话说，一个程序切片是由程序中的一些语句和判定表达式组成的集合。</p>
<p>根据计算方向的不同，程序切片可以分为前向切片和后向切片。<strong>前向切片的计算方向和程序的运行方向是一致的</strong>。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/8529a5b07621bf16927f1e88defcb5c0.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8529a5b07621bf16927f1e88defcb5c0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="控制流图"><a href="#控制流图" class="headerlink" title="控制流图"></a>控制流图</h2><p>控制流图（Control Flow Graph，简称CFG）也叫控制流程图，是一个过程或程序的抽象表现，代表了一个程序执行过程中会遍历到的所有路径。</p>
<p><strong>控制流图</strong>：一个程序的控制流图CFG可以表示为一个四元组，形如G=(V，E，s，e)，其中V表示<strong>变量</strong>的集合，E表示<strong>边</strong>的集合，s表示控制流图的<strong>入口</strong>，e表示控制流图的<strong>出口</strong>。</p>
<p>程序中的每一条指令都映射为CFG上的一个结点，具有控制依赖关系的结点之间用一条边连接。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/68d729007c860e7e99c31d393d18d9bb.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/68d729007c860e7e99c31d393d18d9bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>程序中的控制依赖关系有两种来源：</p>
<ul>
<li>程序上下文</li>
<li>控制指令</li>
</ul>
<p>控制指令对应了分支结构和循环结构，结构里面的所有指令对结构入口的控制指令存在控制依赖关系。如果一条指令不在分支结构或循环结构里面，则该指令依赖于程序的入口。</p>
<h2 id="程序依赖图"><a href="#程序依赖图" class="headerlink" title="程序依赖图"></a>程序依赖图</h2><p><strong>程序依赖图</strong>：(Program Dependence Graph，PDG)可以表示为一个五元组，形如G = (V, DDE, CDE, s, e)，其中V表示<strong>变量</strong>的集合，DDE表示<strong>数据依赖边</strong>的集合，CDE表示<strong>控制依赖边</strong>的集合，每条边连接了图中的两个结点，程序中的每一条指令都映射为PDG上的一个结点。s表示程序依赖图的<strong>入口结点</strong>，e表示程序依赖图的<strong>出口结点</strong>。</p>
<p><strong>控制依赖</strong>：表示两个基本块在程序流程上存在的依赖关系。</p>
<p><strong>数据依赖</strong>：表示程序中引用某变量的基本块（或者语句）对定义该变量的基本块的依赖，即是一种“<strong>定义-引用</strong>”依赖关系。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/33bb811d47c18d11d701a7a5dadcc2b3.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/33bb811d47c18d11d701a7a5dadcc2b3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>控制流图CFG结点之间的边只反映出了程序指令之间的部分控制依赖关系。程序依赖图PDG需要将一个函数中所有的数据依赖和控制依赖关系遍历出来。</p>
<h2 id="系统依赖图"><a href="#系统依赖图" class="headerlink" title="系统依赖图"></a>系统依赖图</h2><p><strong>系统依赖图</strong>（System Dependence Graph，SDG）：可以表示为一个七元组，形如G = (V,DDE, CDE, CE, TDE, s, e)，其中V<strong>变量</strong>的集合，DDE表示<strong>数据依赖边</strong>的集合，CDE表示<strong>控制依赖边</strong>的集合，CE表示<strong>函数调用边</strong>，TDE表示参数传递造成的<strong>传递依赖边</strong>的集合，结点s表示系统依赖图的<strong>入口结点</strong>，结点e表示系统依赖图的<strong>出口结点</strong>。<br>SDG在PDG的基础上进行了扩充，系统依赖图中<u>加入了对函数调用的处理</u>。</p>
<h1 id="程序切片方法"><a href="#程序切片方法" class="headerlink" title="程序切片方法"></a>程序切片方法</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><blockquote>
<p>在实际的程序调试过程中，通常程序员只关注程序的部分行为。</p>
</blockquote>
<p>切片准则包含两个要素，即<strong>切片目标变量</strong>（如变量z），以及<strong>开始切片的代码位置</strong>（如z所在的代码位置：第12行）。严格来说，程序P的切片准则是二元组&lt;n,V&gt;，其中n是程序中一条语句的编号，V是切片所关注的变量集合，该集合是P中变量的一个子集。</p>
<p>切片语句可以利用<strong>数据依赖</strong>和<strong>控制依赖</strong>分析方法来获取。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/9822e2e6dca3240d7105033f4390e2d0.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/9822e2e6dca3240d7105033f4390e2d0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>程序切片通常包括3个步骤：程序依赖关系提取、切片规则制定和切片生成。</p>
<ul>
<li><strong>程序依赖关系提取</strong>主要是从程序中提取各类消息，包括控制流和数据流信息，形成程序依赖图。</li>
<li><strong>切片规则制定</strong>主要是依据具体的程序分析需求设计切片准则。</li>
<li><strong>切片生成</strong>则主要是依据前述的切片准则选择相应的程序切片方法，然后对第一步中提取的依赖关系进行分析处理，从而生成程序切片。</li>
</ul>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/ff7a41b1ae4ceaf7dfbad646ba8357bc.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/ff7a41b1ae4ceaf7dfbad646ba8357bc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="图可达算法"><a href="#图可达算法" class="headerlink" title="图可达算法"></a>图可达算法</h2><p>程序切片技术有多种计算方法，例如：数据流方程算法、图可达性算法、基于波动图的切片算法、基于信息流关系的切片算法等。其中，最常用和最主流的算法是<strong>数据流方程算法</strong>与<strong>图可达性算法</strong>。</p>
<p>图可达性算法根据程序建模的不同分为许多子类，最常用的包括基于程序依赖图的图可达性算法和基于系统依赖图的图可达性算法。</p>
<p>在程序依赖图PDG中，具有直接依赖关系和间接依赖关系的结点都用一条边连结，因此基于 PDG 的图可达性切片算法只需从指定结点遍历每一个具有依赖关系的结点即可，计算过程比较<u>简单直观</u>。</p>
<p>将基于PDG的图可达性切片过程记为PDGSlice，它的详细步骤如下：</p>
<ul>
<li><strong>输入</strong>：结点Node</li>
<li><strong>输出</strong>：结点集VisitedNodes </li>
<li>步骤1：判断Node是否在结点集VisitedNodes，结果为是，则return；结果为否，则进入步骤2； </li>
<li>步骤2：将Node添加到VisitedNodes中；</li>
<li>步骤3：在程序依赖图中<font color=red>遍历Node依赖的结点，得到结点集Pred；</font></li>
<li>步骤4：对于每一个pred∈Pred，<font color=red>迭代调用PDGSlice(pred)</font>。</li>
</ul>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/f19e78f74d39d5f868d5f69c9ff8b135.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/f19e78f74d39d5f868d5f69c9ff8b135.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/0cbab25971f9fb419682e45f34aef7db.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/0cbab25971f9fb419682e45f34aef7db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="动态切片"><a href="#动态切片" class="headerlink" title="动态切片"></a>动态切片</h2><p>从切片角度，切片分为静态程序切片、动态程序切片和条件切片等。</p>
<p>由于静态切片中包含了到达兴趣点的所有可能路径，而对于程序的某一次特定执行，其中的许多路径实际上是不会被执行的。</p>
<p>动态切片需要考虑程序的<strong>特定输入</strong>，切片准则是一个三元组(N, V, I)，其中 N 是指令集合，V 是变量集合，I 是<strong>输入集合</strong>。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/32bcd4d1629571679661715771336dbe.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/32bcd4d1629571679661715771336dbe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>动态切片可以看做静态切片的子集。</p>
<p>当图可达算法应用到动态切片中，可以<strong>通过裁剪程序依赖图</strong>来实现。</p>
<p>条件切片的切片准则也是一个三元组，形为C = (N, V, 𝐹V)，其中 N 和 V 的含义同静态准则相同，𝐹V是 V 中变量的<strong>逻辑约束</strong>。</p>
<p>静态切片和动态切片可以看做条件切片的两个特例：<u>当𝐹V中的约束条件为空时，得到的切片是静态切片；当𝐹V中的约束固定为某一特定条件时，得到的切片是动态切片</u>。</p>
<h1 id="程序插桩技术"><a href="#程序插桩技术" class="headerlink" title="程序插桩技术"></a>程序插桩技术</h1><h2 id="插桩概念"><a href="#插桩概念" class="headerlink" title="插桩概念"></a>插桩概念</h2><p>程序插桩，是借助往被测程序中插入操作，来实现测试目的的方法。简单地说，插桩就是在代码中<strong>插入一段我们自定义的代码</strong>，它的目的在于通过我们插入程序中的自定义的代码，得到<strong>期望得到的信息</strong>，比如程序的控制流和数据流信息，以此来实现测试或者其他目的。</p>
<ul>
<li>最简单的插桩是在程序中插入输出语句，以监测变量的取值或者状态是否符合预期。这种插桩手段在服务类应用程序、基于日志的程序调错等。</li>
<li><strong>断言</strong>是一种特殊的插桩，是在程序的特定部位插入语句来检查变量的特性。</li>
</ul>
<h2 id="插桩分类"><a href="#插桩分类" class="headerlink" title="插桩分类"></a>插桩分类</h2><p><strong>源代码插桩</strong>是指在被测程序运行之前，通过自动化工具或者程序员手动在需要收集信息的地方插入探针，之后重新编译运行被测程序。</p>
<p><strong>静态二进制插桩</strong>和源代码插桩类似，都是在程序运行之前插入探针，与源代码插桩不同是静态二进制插桩直接对程序编译之后的二进制机器码进行插桩。编写难度更大、可移植性更差。</p>
<p><strong>动态二进制插桩</strong>在程序运行时，直接接管被测程序并且截获其二进制指令并插入探针。插桩程序难度更大，程序运行开销也越大。</p>
<h2 id="Pin插桩示例"><a href="#Pin插桩示例" class="headerlink" title="Pin插桩示例"></a>Pin插桩示例</h2><p>动态二进制插桩技术被广泛的用在各个领域。为了解决动态二进制插桩程序编写难度大、抽象层次低的缺点，提高代码的重用性，人们开发了许多<font color=red>动态二进制插桩框架</font>。</p>
<p>Pin是Intel公司开发的动态二进制插桩框架，支持IA-32和x86-64指令集架构，支持windows和linux。</p>
<p>Pin可以监控程序的每一步执行，提供了丰富的API，可以在二进制程序程序运行过程中插入各种函数，比如说我们要统计一个程序<strong>执行了多少条指令</strong>，<strong>每条指令的地址</strong>等信息。</p>
<h3 id="安装及使用Pin"><a href="#安装及使用Pin" class="headerlink" title="安装及使用Pin"></a>安装及使用Pin</h3><blockquote>
<p>解压下载的Windows版本的Pin压缩包，整体文件夹结构如下所示。</p>
</blockquote>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/77772fa0784c81568c7310ff645937b7.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/77772fa0784c81568c7310ff645937b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>文件夹ia32和intel64包含了英特尔不同体系架构下的相关库和可执行文件，文件夹doc包含了Pin相关的用户手册、API文档等，而文件夹<code>source\tools</code>里包含了大量的<code>PinTool</code>。</p>
<p>Pin通过已经定义的tools或者自己开发的tool来完成对目标程序的插桩。通常，PinTool以<strong>动态链接库</strong>方式使用，即Linux下是<code>.so</code>文件，而Windows下是<code>.dll</code>文件。</p>
<h3 id="Pin用法"><a href="#Pin用法" class="headerlink" title="Pin用法"></a>Pin用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pin [OPTION] [-t &lt;tool&gt; [&lt;toolargs&gt;]] -- &lt;command line&gt;</span><br><span class="line">注：&lt;command line&gt;：&lt;App EXE&gt; [App args]</span><br></pre></td></tr></table></figure>

<p>举例，在Linux下使用如下命令来进行动态插桩，并得到输出信息文件：</p>
<p>$ ./pin -t ./source/tools/…/obj-intel64/xxxx.so – TargetApp args</p>
<p>这里的<code>xxxx.so</code>指代所要使用的<code>Pintool</code>，如<code>inscount0.so</code>，“–”之后要输入需要运行的目标程序（TargetApp）和其相关参数（args）。默认输出结果将保存到<code>xxxx.out</code>，也可以使用在Pintool中实现函数<code>KnobOutputFile</code>后通过<code>toolargs：-o filepath</code>指定。 </p>
<h3 id="使用Pintool"><a href="#使用Pintool" class="headerlink" title="使用Pintool"></a>使用Pintool</h3><p>在Pin的安装文件里，在<strong>source\tools</strong>里已经定义了大量PinTool，可以编译后直接使用，也可以自己开发自己的定制的PinTool来完成特定的插桩任务。</p>
<ol>
<li><strong>Linux下编译现有Pintool</strong></li>
</ol>
<p>Linux PinTool编译在Linux下，可以使用通过以下命令可以对所有Pintool进行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd source/tools/ManualExamples</span><br><span class="line">$ make all TARGET=intel64</span><br></pre></td></tr></table></figure>

<p>也可以指定某个具体的Pintool工具，如inscount0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd source/tools/ManualExamples</span><br><span class="line">$ make inscount0.test TARGET=intel64</span><br></pre></td></tr></table></figure>

<p>在pin\source\tools\ManualExamples里，已经定了好了很多PinTool，这些常用的Pintool功能介绍如下表所示：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/da4351c3ef8fb5db1a127b02e7bbb386.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/da4351c3ef8fb5db1a127b02e7bbb386.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ol start="2">
<li><strong>Inscount插桩示例</strong></li>
</ol>
<p>首先，进入source/tools/ManualExamples，对inscount0.cpp进行编译来产生其对应的动态链接库，所使用的命令为：make inscount0.test TARGET=intel64。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/bc499c8640ee52014b593fc91d1f6540.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/bc499c8640ee52014b593fc91d1f6540.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>编写一个简单的控制台程序FirstC.c，并进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux下编译c文件的命令为: <code>gcc –o First FirstC.c</code>。<br>然后，对First可执行程序进行程序插桩的Pin命令为：<br><code>./pin -t ./source/tools/ManualExamples/obj-intel64/inscount0.so -- ../testCPP/First</code></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/413a488b8d7bc8f21c4cafeaf18796f3.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/413a488b8d7bc8f21c4cafeaf18796f3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在pin-3.18路径下增加了一个输出文件<code>inscount.out</code>，文件内容如下：“Count 192994”，即<strong>对指令数进行了插桩</strong>。</p>
<ol start="3">
<li><strong>插桩框架：打开inscout0.cpp</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ofstream OutFile; </span><br><span class="line">static UINT64 icount = 0; // 静态变量，保存运行的指令数的计数</span><br><span class="line">VOID docount() &#123; icount++; &#125; //这个函数在每条指令执行以前被调用</span><br><span class="line">     </span><br><span class="line">VOID Instruction(INS ins, VOID *v) //Pin工具每次遇到一个新指令都会调用该函数</span><br><span class="line">&#123; </span><br><span class="line">//在每个指令之前插入一个函数docount的调用，没有任何参数</span><br><span class="line">    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定输出文件为inscount.out</span><br><span class="line">KNOB&lt;string&gt; KnobOutputFile(KNOB_MODE_WRITEONCE, &quot;pintool&quot;,  &quot;o&quot;, &quot;inscount.out&quot;, &quot;specify output file name&quot;);</span><br><span class="line"> </span><br><span class="line">//当应用退出的时候调用本函数</span><br><span class="line">VOID Fini(INT32 code, VOID *v)</span><br><span class="line">&#123; </span><br><span class="line">    OutFile.setf(ios::showbase);</span><br><span class="line">    OutFile &lt;&lt; &quot;Count &quot; &lt;&lt; icount &lt;&lt; endl;</span><br><span class="line">    OutFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/15/lou-dong-wa-jue-pian/33fc15e6abf4aac31b73a489ab9c51c2.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/33fc15e6abf4aac31b73a489ab9c51c2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ol start="4">
<li><strong>插桩模式</strong></li>
</ol>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/04e0f0371051e28de23e7ad504f7e25b.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/04e0f0371051e28de23e7ad504f7e25b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在各种粒度的插装函数调用时，可以在代码中添加自己的处理函数，程序被加载后，在被插装的代码运行时，自己添加的函数会被调用。</p>
<p><strong>指令级插桩</strong></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/aaee229c491ceb37b52e70ea9b5303b7.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/aaee229c491ceb37b52e70ea9b5303b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/65864a75fdd5de9018ce6383b4950a97.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/65864a75fdd5de9018ce6383b4950a97.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><h2 id="Hook概念"><a href="#Hook概念" class="headerlink" title="Hook概念"></a>Hook概念</h2><p>Hook(钩子)，是一种过滤(或叫挂钩)消息的技术。</p>
<p>Hook的目的是过滤一些关键函数调用，在函数执行前，先执行自己的<strong>挂钩函数</strong>，达到监控函数调用，改变函数功能的目的。</p>
<p>Hook技术已经被广泛应用于安全的多个领域，比如杀毒软件的主动防御功能，涉及到<font color=red>对一些敏感API的监控</font>，就需要对这些API进行Hook；窃取密码的木马病毒，为了接收键盘的输入，需要<strong>Hook键盘消息</strong>；甚至是Windows系统及一些应用程序，在打补丁时也需要用到Hook技术。当然，Hook技术也可以用在软件分析和漏洞挖掘等领域。</p>
<p>Hook技术按照实现原理来分的话，可以分为两种：</p>
<ul>
<li>API Hook：拦截Windows API</li>
<li>消息Hook：拦截Windows 消息</li>
</ul>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/beae9352bd9084e8c535b6325e71d738.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/beae9352bd9084e8c535b6325e71d738.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>Hook方法很多，主要包括调试法和注入法。</p>
<h2 id="消息Hook"><a href="#消息Hook" class="headerlink" title="消息Hook"></a>消息Hook</h2><p>Windows系统建立在<strong>事件驱动机制</strong>上，整个系统通过<strong>消息传递</strong>实现的。在Windows系统里，消息Hook就是一个<strong>Windows消息的拦截机制</strong>，可以拦截单个进程的消息（线程钩子），也可以拦截所有进程的消息（系统钩子），也可以对拦截的消息进行自定义的处理： </p>
<ul>
<li>如果对于同一事件（如鼠标消息）既安装了线程钩子又安装了系统钩子，那么系统会自动<strong>先调用线程钩子，然后调用系统钩子</strong>。 </li>
<li>对同一事件消息可安装多个钩子处理过程，这些钩子处理过程形成了<strong>钩子链</strong>。<u>后加入的有优先控制权</u>。</li>
</ul>
<p>Windows提供了一个官方函数<code>SetWindowsHookEx</code>用于设置消息Hook，编程时只要调用该API就能简单地实现Hook，其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookEx(</span><br><span class="line">int_idHook,          //hook类型</span><br><span class="line">HOOKPROC lpfn,      //hook函数</span><br><span class="line">HINSTANCE hMod,      //hook函数所属DLL的Handle</span><br><span class="line">DWORD dwThreadId  //设定要Hook的线程ID，0表示“全局钩子”(Global Hook)监视所有进程</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="基于消息Hook的DLL注入"><a href="#基于消息Hook的DLL注入" class="headerlink" title="基于消息Hook的DLL注入"></a>基于消息Hook的DLL注入</h3><p><strong>DLL注入技术</strong>是向一个正在运行的进程插入自有DLL的过程。DLL注入的目的是<font color=red>将代码放进另一个进程的地址空间中</font>，现在被广泛应用在软件分析、软件破解、恶意代码等领域，注入方法也很多，比如利用注册表注入、CreateRemoteThread远程线程调用注入等。</p>
<p>在Windows中，利用<code>SetWindowsHookEx</code>函数创建钩子（Hooks）可以实现DLL注入。设计实验如下：<br>编制键盘消息的Hook函数—KeyHook.dll中的KeyboardProc函数<br>通过SetWindowsHookEx创建键盘消息钩子实现DLL注入（执行DLL内部代码）</p>
<h4 id="第一步：编写DLL文件"><a href="#第一步：编写DLL文件" class="headerlink" title="第一步：编写DLL文件"></a>第一步：编写DLL文件</h4><p>新建一个VC 6的动态链接库工程，命名为KeyHook，添加一个代码文件KeyHook.cpp：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/0520aaa7d2964d42f43b129d1615c9a2.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/0520aaa7d2964d42f43b129d1615c9a2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/f39510d5fee3ee9b4f78e3d28af7354d.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/f39510d5fee3ee9b4f78e3d28af7354d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/2d410a395d660409c4f86d3bccd9d551.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/2d410a395d660409c4f86d3bccd9d551.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="第二步：编写DLL注入功能的可执行文件"><a href="#第二步：编写DLL注入功能的可执行文件" class="headerlink" title="第二步：编写DLL注入功能的可执行文件"></a>第二步：编写DLL注入功能的可执行文件</h4><p>新建一个VC6的控制台程序，添加源文件HookMain.cpp如下：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/69df7047eaf9ed30dd370c635c813f06.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/69df7047eaf9ed30dd370c635c813f06.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/4823b32a8a8916d91ac254a91fe327d5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/4823b32a8a8916d91ac254a91fe327d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="第三步：实验验证"><a href="#第三步：实验验证" class="headerlink" title="第三步：实验验证"></a>第三步：实验验证</h4><p>将<code>HookMain.exe</code>和<code>KeyHook.dll</code>放在相同目录下，运行<code>HookMain.exe</code>安装键盘消息Hook后，将实现<code>notepad.exe</code>进程的键盘消息拦截，使之无法显示在记事本中。直到输入“q”才可停止键盘Hook。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/8304d0fbb5410b5cef6b74d450e9dd0f.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8304d0fbb5410b5cef6b74d450e9dd0f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="API-Hook技术"><a href="#API-Hook技术" class="headerlink" title="API Hook技术"></a>API Hook技术</h2><h3 id="API-Hook概念"><a href="#API-Hook概念" class="headerlink" title="API Hook概念"></a>API Hook概念</h3><p>API HOOK技术是<strong>对API函数进行Hook（挂钩）的技术</strong>。API HOOK的基本方法就是通过hook“接触”到需要修改的API函数入口点，<strong>改变它的地址指向</strong>新的自定义的函数。</p>
<p>API Hook方法多种：<u>IAT Hook</u>、<u>代码Hook</u>、<u>EAT Hook</u> </p>
<blockquote>
<p>EAT: export address table，导出地址表</p>
</blockquote>
<p><strong>IAT Hook</strong>：将输入函数地址表IAT内部的API地址更改为Hook函数地址。</p>
<p>优点是实现起来较简单，缺点是无法钩取不在IAT而在程序中使用的API(比如：动态加载并使用DLL时)。</p>
<p><strong>代码Hook</strong>：系统库（*.dll）映射到进程内存时，从中查找API的实际地址，并直接修改代码。</p>
<p>该方法应用范围广泛，具体实现中常通过以下方式：</p>
<ul>
<li>使用JMP指令修改起始代码</li>
<li>复写函数局部</li>
<li>仅修改必需部分的局部</li>
</ul>
<h3 id="修改起始代码示例"><a href="#修改起始代码示例" class="headerlink" title="修改起始代码示例"></a>修改起始代码示例</h3><p>在动态链接库被动态加载到进程的地址空间中后，<strong>将要使用的API函数的所在位置的前几个字节修改为一条跳转指令，跳转到代理函数去执行，在需要调用原API函数时，再将源代码复制过去或者跳转回去。</strong>例如：设自定义函数My_Send的地址为0x0157143F，为了使对Send函数调用转到这里执行，可以嵌入如下汇编代码：<br> mov eax，0157143F； //将自定义函数地址放入寄存器eax，对应机器码B83F145701<br> jmp eax；     //跳转到eax处对应机器码：FFE0<br>CPU仅能识别机器码，所以要将汇编代码对应的最原始的机器码写入到目标API所在内存。上面两行汇编代码对应的机器码为：B83F145701FFE0，一共7个字节。其中第2-5个字节的取值会随自定义函数的地址不同而不同。</p>
<h3 id="IAT-Hook示例"><a href="#IAT-Hook示例" class="headerlink" title="IAT Hook示例"></a>IAT Hook示例</h3><p>实验三：利用API Hook技术对敏感函数<code>lstrcpy函数</code>进行Hook，获取函数的<strong>输入参数</strong>，进行记录分析。<br><strong>步骤</strong>：</p>
<ol>
<li>编写自定义函数：实现检测等需要的功能；</li>
<li>Hook实现：根据PE文件结构寻找IAT，并将IAT中的目标函数的地址更换为自定义的函数地址；</li>
<li>DLL注入：将包含IAT Hook代码及自定义的Hook函数的Dll注入到目标文件中。</li>
</ol>
<p><strong>第一步</strong>：编写一个动态链接库文件，其中编写自己的Hook函数及其逻辑</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/a28948a0b3ff1f310c555ac5f8cad676.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/a28948a0b3ff1f310c555ac5f8cad676.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/12ff54c8c16cd26a718e3f5489602404.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/12ff54c8c16cd26a718e3f5489602404.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/e8ddf7f471feeeeba67b7089950a26d8.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/e8ddf7f471feeeeba67b7089950a26d8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>第二步</strong>：注入DLL文件</p>
<p>新建Windows控制台程序实现DLL文件注入。 </p>
<p>USAGE : InjectDll.exe &lt;i|e&gt; <PID> <dll_path>。 调用InjectDll完成注入。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/0c7d025895e8ad9fcb39c497af0434ef.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/0c7d025895e8ad9fcb39c497af0434ef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/def1869dfb71b0e17768d0a26f6e0546.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/def1869dfb71b0e17768d0a26f6e0546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h1 id="符号执行技术"><a href="#符号执行技术" class="headerlink" title="符号执行技术"></a>符号执行技术</h1><h2 id="符号执行基本原理"><a href="#符号执行基本原理" class="headerlink" title="符号执行基本原理"></a>符号执行基本原理</h2><p>符号执行的三个关键点：</p>
<ul>
<li>变量符号化</li>
<li>程序执行模拟<blockquote>
<p>程序执行模拟，可以收集到哪些信息？程序执行模拟具体是如何工作的？</p>
</blockquote>
</li>
<li>约束求解<blockquote>
<p>约束求解，对谁求解，得到的结果是什么？</p>
</blockquote>
</li>
</ul>
<h3 id="程序执行状态"><a href="#程序执行状态" class="headerlink" title="程序执行状态"></a>程序执行状态</h3><p>符号执行具体执行时，程序状态中通常包括：<strong>程序变量的具体值</strong>、<strong>程序指令计数</strong>和<strong>路径约束条件pc</strong>（path constraint）。<br>pc是符号执行过程中对路径上条件分支走向的选择情况，根据状态中的pc变量就可以确定一次符号执行的完整路径。pc初始值为true。<br>举例来说，假设符号执行过程中经过3个与符号变量相关的if条件语句if1、if2、if3，每个条件表达式如下：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/dce88d2413f83107732380ccc832dbe5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/dce88d2413f83107732380ccc832dbe5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>设引擎在3个if条件分支处分别选择if1：true，if2：true，if3：false，则pc表示为：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/9cee0bbed45b0d57da3bd514b60744ab.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/9cee0bbed45b0d57da3bd514b60744ab.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>假设if处的表达式为R≥0，R是一个与符号变量相关的多项表达式，把R≥0称为q，则程序执行到if处时pc可能会表现为下面两种形式之一：<br>(1) pc包含q          (2) pc包含￢q<br><strong>如果符号执行引擎选择进入then分支</strong>，则R≥0的真值为true，pc表现为(1)的形式记为：<img src="/2023/03/15/lou-dong-wa-jue-pian/3263a70aae415cc47daed84d31810797.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/3263a70aae415cc47daed84d31810797.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><strong>如果选择else分支</strong>，则R≥0的 false真值为，pc表现为(2)的形式，且记为：<img src="/2023/03/15/lou-dong-wa-jue-pian/e9e3eeca059fb8d568dcb1126ad68810.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/e9e3eeca059fb8d568dcb1126ad68810.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<blockquote>
<p>要确定pc对应路径的程序输入参数，只需要使用约束求解器对pc进行求解就可以。</p>
</blockquote>
<h3 id="符号传播"><a href="#符号传播" class="headerlink" title="符号传播"></a>符号传播</h3><p>符号传播主要作用是建立符号变量传播的关系，并且更新映射的关系。在实际操作的过程中，通常是将<u>对应内存地址的数据进行变化</u>。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/cafb036a0fe999f4a3eb4224890dd508.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/cafb036a0fe999f4a3eb4224890dd508.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="符号执行树"><a href="#符号执行树" class="headerlink" title="符号执行树"></a>符号执行树</h3><p>如何形式化地表示符号执行的过程呢？程序的所有执行路径可以表示为树，叫做<strong>执行树</strong>。<u>符号执行过程也是对执行树进行遍历的过程。</u></p>
<ul>
<li>执行树中的一个节点对应程序中的一条语句，程序语句之间的执行顺序或跳转关系对应执行树中节点间的边，对于每个语句会有两条边与其相连，左子树对应的是if语句的true(then)分支，右子树对应if语句的false(else)分支。</li>
<li>执行树中还可以包含指令计数、pc(路径约束条件)、变量符号值等程序执行状态信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 void foobar(int a,int b)&#123;</span><br><span class="line">2  int x=1,y=0;</span><br><span class="line">3  if(a != 0)&#123;</span><br><span class="line">4    y = 3+x; </span><br><span class="line">5    if (b 0)</span><br><span class="line">6         x = 2*(a+b);</span><br><span class="line">7   &#125;</span><br><span class="line">8  assert(x-y ！=0);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/15/lou-dong-wa-jue-pian/679c4c0cd9ab0b565e6849ecea6946d9.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/679c4c0cd9ab0b565e6849ecea6946d9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>符号执行完得到三条路径，可以对路径约束条件pc进行约束求解得到到达该路径的一组输入，结合assert的约束x-y!=0就可以进行求解出触发约束的输入。</p>
<h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>符号执行得到的约束条件，可以通过<strong>约束求解器</strong>进行求解。<br>主流的约束求解器主要有两种理论模型：<strong>SAT求解器</strong>和<strong>SMT求解器</strong>。</p>
<ul>
<li>SAT问题（The Satisfiability Problem，可满足性问题），求解由布尔变量集合组成的布尔表达式，对命题逻辑公式问题适用，但是当前有很多实际应用的问题，并不能直接转换为SAT问题来进行求解。</li>
<li>SMT（Satisfiability Module Theories，可满足性模理论），求解范围从命题逻辑公式扩展为可以解决一阶逻辑所表达的公式。SMT包含很多的求解方法，通过组合这些方法，可以解决很多问题。</li>
<li>Z3就是一个典型的约束求解器。</li>
</ul>
<h3 id="符号执行方法分类"><a href="#符号执行方法分类" class="headerlink" title="符号执行方法分类"></a>符号执行方法分类</h3><p><strong>静态符号执行</strong>本身不会实际执行程序，通过解析程序和符号值模拟执行，有代价小、效率高的优点，但是存在<strong>路径爆炸</strong>、<strong>误报高</strong>的情况。</p>
<p><strong>动态符号执行</strong>也称为混合符号执行，它的基本思想是：以<strong>具体的数值</strong>作为输入执行程序代码，在程序实际执行路径的基础上，用符号执行技术对路径进行分析，提取路径的约束表达式，根据路径搜索策略（深度、广度）对约束表达式进行<strong>变形</strong>，求解变形后的表达式并生成新的测试用例，不断迭代上面的过程，<font color=red>直到完全遍历程序的所有执行路径</font>。动态符号执行结合了真实执行和传统符号执行技术的优点，<strong>在真实执行的过程中同时进行符号执行</strong>，可以在保证测试精度的前提下对程序执行树进行快速遍历。</p>
<p><strong>选择性符号执行</strong>可以对程序员感兴趣的部分进行符号执行，其它的部分使用真实值执行，在特定任务环境下可以进一步提升执行效率。</p>
<h2 id="Z3约束求解器"><a href="#Z3约束求解器" class="headerlink" title="Z3约束求解器"></a>Z3约束求解器</h2><h3 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h3><p>Z3是一个微软出品的<strong>SMT问题</strong>的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以理解为自动解方程组）。<br>Z3在工业应用中常见于软件验证、程序分析等。由于Z3功能实在强大，也被用于很多其他领域：软件/硬件验证和测试、约束解决、混合系统分析、安全性、生物学（计算机模拟分析）和几何问题。著名的<strong>二进制分析框架angr</strong>也内置了一个修改版的Z3。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/80d266fbde3e5608406ecc456797ba47.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/80d266fbde3e5608406ecc456797ba47.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Z3常用API"><a href="#Z3常用API" class="headerlink" title="Z3常用API"></a>Z3常用API</h3><ul>
<li>Solver()：创建一个通用求解器，创建后可以添加约束条件，进行下一步的求解。</li>
<li>add()：添加约束条件，通常在solver()命令之后。</li>
<li>check()：通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会回显sat，无解的时候会回显unsat。</li>
<li>model()：在存在解的时候，该函数会将每个限制条件所对应的解集取交集，进而得出正解。</li>
</ul>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y = Real(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x + y &gt; <span class="number">5</span>, x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s.check())</span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>

<p>打开命令控制台，进入D:\z3-4.8.10\bin\python，执行example.py，如下：</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/3c1c0b43d1085f56337a2dc5c14ca6b7.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/3c1c0b43d1085f56337a2dc5c14ca6b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="Angr应用示例"><a href="#Angr应用示例" class="headerlink" title="Angr应用示例"></a>Angr应用示例</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Angr是一个<strong>基于python的二进制漏洞分析框架</strong>，它将以前多种分析技术集成进来，它能够进行动态的符号执行分析（如KLEE和Mayhem），也能够进行多种静态分析。</p>
<p>Windows下安装Angr。首先安装Python3，如果安装了就忽略。可以到python官方网站下载安装版本，选择将python增加到path中。然后，打开命令控制台，使用PIP命令安装angr：pip install angr。</p>
<p>测试安装。输入命令python，进入python界面，然后输入import angr，如果成功，则说明安装没有问题。</p>
<h3 id="Angr示例"><a href="#Angr示例" class="headerlink" title="Angr示例"></a>Angr示例</h3><p><strong>Angr官方手册</strong>。GitHub上有angr的开源项目<a target="_blank" rel="noopener" href="https://github.com/angr%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E6%A1%A3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%BB%BA%E8%AE%AE%E5%B0%86https://github.com/angr/angr-doc%E9%87%8C%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E6%A1%A3%E4%BB%A5zip%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82">https://github.com/angr以及相关的文档信息，建议将https://github.com/angr/angr-doc里的所有文档以zip方式下载到本地。</a></p>
<p><strong>angr-doc里有各类Example</strong>，展示了Angr的用法，比如cmu_binary_bomb、simple_heap_overflow等二进制爆破、堆溢出等漏洞挖掘、软件分析的典型案例。<br>以<code>sym-write</code>为例子，来说明angr的用法：</p>
<ul>
<li>怎么使用angr?</li>
<li>使用angr能解决什么问题？</li>
</ul>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/8d7808fea34cb4a2948ce82d7b9caae8.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8d7808fea34cb4a2948ce82d7b9caae8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<blockquote>
<p>求解步骤：</p>
<p>变量符号化：将u符号化</p>
<p>动态符号执行：以具体的数值作为输入执行程序代码，在程序实际执行路径的基础上，用符号执行技术对路径进行分析，提取路径的约束表达式。</p>
<p>获取路径约束条件</p>
<p>约束求解</p>
</blockquote>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/c15f5e46ac34dfd704b079a29bce9369.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/c15f5e46ac34dfd704b079a29bce9369.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/9502f30d1f4942f2d6a2c8b0f52521e9.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/9502f30d1f4942f2d6a2c8b0f52521e9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>求解出的结果：<img src="/2023/03/15/lou-dong-wa-jue-pian/fd3767d35a6e163adfd6def63025b959.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/fd3767d35a6e163adfd6def63025b959.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p><img src="/2023/03/15/lou-dong-wa-jue-pian/6e6672b6fd61a47a3550aa647bf612b0.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/6e6672b6fd61a47a3550aa647bf612b0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/26e065167dc8754e89e739a0b183e507.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/26e065167dc8754e89e739a0b183e507.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h1 id="污点分析技术"><a href="#污点分析技术" class="headerlink" title="污点分析技术"></a>污点分析技术</h1><h2 id="污点分析基本原理"><a href="#污点分析基本原理" class="headerlink" title="污点分析基本原理"></a>污点分析基本原理</h2><p><strong>污点分析</strong>是信息流分析的一种实践技术：如果系统满足了用户定制的信息流策略，那么系统是信息流安全的。<br>污点分析标记程序中的数据（<strong>外部输入数据或者内部数据</strong>）为污点，通过<strong>对带污点数据的传播分析</strong>来达到保护数据完整性和保密性的目的。如果信息从被标记的污点数据传播给未标记的数据,那么需要将未标记的标记为污点数据；如果被标记的污点数据传递到<strong>重要数据区域或者信息泄露点</strong>，那就意味着<font color=red>信息流策略被违反</font>。<br>污点分析被广泛地应用在隐私数据泄露检测、漏洞挖掘等实际领域。</p>
<p>污点分析可以抽象成一个<strong>三元组（sources，sinks，sanitizers）</strong>的形式：source即<strong>污点源</strong>，代表直接引入不受信任的数据或者机密数据到系统中；sink即<strong>污点汇聚点</strong>，代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性)；<br>sanitizer即<strong>无害处理</strong>，代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害。</p>
<ul>
<li>污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理，而直接传播到污点汇聚点。如果不能，说明系统是信息流安全的；否则，说明系统产生了隐私数据泄露或危险数据操作等安全问题。</li>
<li>可以分成3个阶段：识别污点源和汇聚点、污点传播分析和无害处理。</li>
</ul>
<h3 id="识别污点源和汇聚点"><a href="#识别污点源和汇聚点" class="headerlink" title="识别污点源和汇聚点"></a>识别污点源和汇聚点</h3><p><strong>识别污点源和污点汇聚点是污点分析的前提</strong>。 目前，在不同的应用程序中识别污点源和汇聚点的方法各不相同，缺乏通用方法。现有的识别污点源和汇聚点的方法可以大致分成3类：</p>
<ol>
<li>使用启发式的策略进行标记，例如把来自程序外部输入的数据统称为“污点”数据，保守地认为这些数据有可能包含恶意的攻击数据；</li>
<li>根据具体应用程序调用的API或者重要的数据类型，手工标记源和汇聚；</li>
<li>使用统计或机器学习技术自动地识别和标记污点源及汇聚点。</li>
</ol>
<h3 id="污点传播分析"><a href="#污点传播分析" class="headerlink" title="污点传播分析"></a>污点传播分析</h3><p><strong>污点传播分析就是分析污点标记数据在程序中的传播途径</strong>。按照分析过程中关注的程序依赖关系的不同，可以将污点传播分析分为<strong>显式流分析</strong>和<strong>隐式流分析</strong>。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/b72864eb793070c0afc7aaf76c5b485e.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/b72864eb793070c0afc7aaf76c5b485e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>污点传播分析中的<strong>显式流分析</strong>就是分析污点标记如何随程序中变量之间的<strong>数据依赖关系</strong>传播。<br>左图很明显，在对sink点进行污点判定的时候，可以发现代码存在<strong>信息泄漏</strong>的问题，即通过sink点可以推测输入的值。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/db0fa85be4b5cbead863f276bdc0e25d.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/db0fa85be4b5cbead863f276bdc0e25d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>污点传播分析中的<strong>隐式流分析</strong>是分析污点标记如何随程序中变量之间的<strong>控制依赖关系</strong>传播，也就是分析污点标记如何从条件指令传播到其所控制的语句。</p>
<p>变量X是被污点标记的字符串类型变量，变量Y和变量X之间并没有直接或间接的数据依赖关系(显式流关系)，但<strong>X上的污点标记可以经过控制依赖隐式地传播到Y</strong>。最终，第12行的Y值和X值相同。但是，如果不进行隐式流污点传播分析，第12行的变量Y将不会被赋予污点标记。</p>
<p>隐式流污点传播一直以来都是一个重要的问题，如果不被正确处理，会使污点分析的结果不精确。<br><strong>欠污染</strong>：由于对隐式流污点传播处理不当导致本应被标记的变量没有被标记的问题称为欠污染(under-taint)问题。<br><strong>过污染</strong>：由于污点标记的数量过多而导致污点变量大量扩散的问题称为过污染(over-taint)问题。</p>
<p>目前，针对隐式流问题的研究重点是尽量减少欠污染和过污染的情况。</p>
<h3 id="无害处理"><a href="#无害处理" class="headerlink" title="无害处理"></a>无害处理</h3><p>污点数据在传播的过程中可能会经过无害处理模块，<strong>无害处理模块是指污点数据经过该模块的处理后，数据本身不再携带敏感信息或者针对该数据的操作不会再对系统产生危害。</strong> 换言之，带污点标记的数据在经过无害处理模块后，污点标记可以被移除。</p>
<p>正确地使用无害处理可以降低系统中污点标记的数量，提高污点分析的效率，并且避免由于污点扩散导致的分析结果不精确的问题。常数赋值是最直观的无害处理的方式；加密处理、程序验证等在一定程度上，可以认为是无害处理。</p>
<h2 id="污点分析方法"><a href="#污点分析方法" class="headerlink" title="污点分析方法"></a>污点分析方法</h2><h3 id="显示流分析"><a href="#显示流分析" class="headerlink" title="显示流分析"></a>显示流分析</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>静态污点传播分析(简称静态污点分析)是指在不运行且不修改代码的前提下，通过分析程序变量间的<strong>数据依赖关系</strong>来检测数据能否从污点源传播到污点汇聚点。</p>
<p>静态污点分析的对象一般是<strong>程序的源码或中间表示</strong>，可以将对污点传播中显式流的静态分析问题转化为对程序中静态数据依赖的分析:首先，根据程序中的函数调用关系<strong>构建调用图</strong>(call graph，简称CG)；然后，在函数内或者函数间根据不同的程序特性进行具体的<strong>数据流传播分析</strong>。</p>
<p>常见的显式流污点传播方式包括<u>直接赋值传播</u>、<u>通过函数(过程)调用传播</u>以及<u>通过别名(指针)传播</u>。</p>
<p><img src="/2023/03/15/lou-dong-wa-jue-pian/4d49dab246b1002b83c384bd107198e6.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/4d49dab246b1002b83c384bd107198e6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>由于foo的两个参数对象x和y都是对对象a的引用(Java程序)，二者之间存在<strong>别名</strong>，存在信息泄露。<br>利用数据流分析解决显式污点传播分析中的直接赋值传播和函数调用传播已经相当成熟，研究的重点是<strong>如何为别名传播的分析提供更精确、高效的解决方案</strong>。</p>
<h4 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h4><p>动态污点传播分析(简称动态污点分析)是指在程序运行过程中，通过<strong>实时监控程序的污点数据</strong>在系统程序中的传播来检测数据能否从污点源传播到污点汇聚点。</p>
<p>动态污点传播分析首先需要为污点数据扩展一个污点标记(tainted tag)的标签并将其存储在<strong>存储单元(内存、寄存器、缓存等)<strong>中，然后根据指令类型和指令操作数设计相应的</strong>传播逻辑</strong>传播污点标记。</p>
<p>动态污点传播分析按照实现层次被分为三类：</p>
<ul>
<li>基于<strong>硬件</strong>的污点传播分析需要定制的硬件支持，一般需要在原有体系结构上为寄存器或者内存扩展一个标记位，用来存储污点标记。</li>
<li>基于<strong>软件</strong>的污点传播分析通过修改程序的二进制代码来进行污点标记位的存储与传播。基于软件的污点传播的优点在于不必更改处理器等底层的硬件，并且可以支持更高的语义逻辑的安全策略，但缺点是使用插桩或代码重写修改程序往往会给分析系统带来巨大的开销。基于硬件的污点传播分析虽然可以利用定制硬件降低开销，但通常不能支持更高的语义逻辑的安全策略，并且需要对处理器结构进行重新设计。</li>
<li>混合型的污点分析是对上述两类方法的折中。</li>
</ul>
<p><font color=red>如何降低分析代价？</font></p>
<p>动态污点传播分析的一个研究重点是<u>如何降低分析代价</u>。基于硬件的分析技术需要定制硬件的支持，基于软件的技术由于程序插桩或代码重写会带来额外的性能开销。</p>
<ul>
<li>一类研究思路是<strong>有选择地对系统中的指令进行污点传播分析</strong>。例如，LIFT提出的快速路径(fast-path)优化技术通过提前判断一个模块的输入和输出是否是具有威胁的(如果没有威胁，则无需进行污点传播)以降低需要重写的代码的数量；</li>
<li>另外一类思路是<strong>使用低开销的机制代替高开销机制</strong>。例如，LIFT的快速切换(fast switch)优化使用低开销的lahf/sahf指令代替高开销的pushq/popq指令,以提高插桩代码与原始二进制文件之间的切换效率。</li>
</ul>
<h3 id="隐式流分析"><a href="#隐式流分析" class="headerlink" title="隐式流分析"></a>隐式流分析</h3><p>污点传播分析中的隐式流分析就是分析污点数据如何通过控制依赖进行传播，如果忽略了对隐式流污点传播的分析，则会导致欠污染的情况；如果对隐式流分析不当，那么除了欠污染之外，还可能出现过污染的情况。 </p>
<h4 id="静态隐式流分析"><a href="#静态隐式流分析" class="headerlink" title="静态隐式流分析"></a>静态隐式流分析</h4><p>面临的核心问题是<strong>精度与效率不可兼得</strong>的问题。<br>精确的隐式流污点传播分析需要分析每一个分支控制条件是否需要传播污点标记。路径敏感的数据流分析往往会产生<strong>路径爆炸</strong>问题，导致开销难以接受。<br>简单的静态传播(标记)分支语句的污点标记方法是将控制依赖于它的语句全部进行污点标记，但该方法会导致一些并不携带隐私数据的变量被标记，导致过污染情况的发生。</p>
<h4 id="动态隐式流分析"><a href="#动态隐式流分析" class="headerlink" title="动态隐式流分析"></a>动态隐式流分析</h4><p>有三个问题需要解决：</p>
<ul>
<li>如何确定污点控制条件下需要标记的语句的<strong>范围</strong>？<blockquote>
<p>动态执行轨迹并不能反映出被执行的指令之间的控制依赖关系</p>
</blockquote>
</li>
<li>由于部分泄漏导致的<strong>漏报</strong>如何解决？<blockquote>
<p>指污点信息通过动态未执行部分进行传播并泄漏</p>
</blockquote>
</li>
<li>如何选择合适的污点标记分支进行污点传播？<blockquote>
<p>鉴于单纯地将所有包含污点标记的分支进行传播会导致过污染的情况</p>
</blockquote>
</li>
</ul>
<h5 id="如何确定污控制条件下需要标记的语句的范围"><a href="#如何确定污控制条件下需要标记的语句的范围" class="headerlink" title="如何确定污控制条件下需要标记的语句的范围"></a>如何确定污控制条件下需要标记的语句的范围</h5><p><img src="/2023/03/15/lou-dong-wa-jue-pian/af07f140542ca315099a7f87ac101e1a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/af07f140542ca315099a7f87ac101e1a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><u>动态执行轨迹并不能反映出被执行的指令之间的控制依赖关系</u><br>目前的研究多采用<strong>离线的静态分析</strong>辅助判断动态污点传播中的隐式流标记范围。<br>利用离线静态分析得到的控制流图节点间的后支配关系来解决动态污点传播中的隐式流标记问题。</p>
<h5 id="如何解决部分泄露导致的误报"><a href="#如何解决部分泄露导致的误报" class="headerlink" title="如何解决部分泄露导致的误报"></a>如何解决部分泄露导致的误报</h5><p><img src="/2023/03/15/lou-dong-wa-jue-pian/bb4cdb9d8a3dcffa06f14d9cd72d7ff6.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/bb4cdb9d8a3dcffa06f14d9cd72d7ff6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>部分泄漏是指<strong>污点信息通过动态未执行部分进行传播并泄漏</strong>。</p>
<p>攻击者由第11行y等于false的条件能够反推出程序执行了第3行的分支条件，程序实际上存在信息泄漏的问题—cookie不是abc。</p>
<p>可以对污点分支控制范围内的所有赋值语句中的变量都进行标记？？-&gt;然而，过污染！！</p>
<h5 id="如何选择合适的污点标记分支进行污点传播"><a href="#如何选择合适的污点标记分支进行污点传播" class="headerlink" title="如何选择合适的污点标记分支进行污点传播"></a>如何选择合适的污点标记分支进行污点传播</h5><p><img src="/2023/03/15/lou-dong-wa-jue-pian/2205fda729b04cad2835da6e5b4ee744.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/2205fda729b04cad2835da6e5b4ee744.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>单纯地将所有包含污点标记的分支进行传播会导致过污染的情况</p>
<p>如果传播策略为只要分支指令中包含污点标记就对其进行传播，则三条分支语句后支配语句全部被标记。</p>
<p>a等于10的情况：攻击者可以根据第12行泄漏的x的值直接还原出污点源处a的值<br>a大于10且小于或等于13的情况：攻击者也只需要尝试3次就可以还原信息<br>a小于10的情况：还原信息的几率显著低于前两种，无需污点标记</p>
<blockquote>
<p>根据信息泄漏范围的不同，定量地设计污点标记分支的选择策略</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>道高一尺，魔高一丈。<br>符号执行、污点分析，依然在路上。</p>

      </div>
      <div class="post-tags-categories">
        
        <div class="tags">
          
            <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/" class="">
              软件漏洞
            </a>
          
        </div>
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Jan</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2023/03/15/lou-dong-wa-jue-pian/" target="_blank" title="漏洞挖掘篇">https://Jan-nku.github.io/2023/03/15/lou-dong-wa-jue-pian/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2023/03/16/wu-xian-wang-an-quan-xing/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">无线网安全性</div>
      </div>
      
      <!-- <div class="content">
        无线局域网标准无线局域网体系结构

两种体系结构

固定无线局域网：可与有线网相连
特定无线局域网（点对点）：不与任何固
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic1.zhimg.com/80/v2-03a22891ccba9bccf6424dfd7cbf4be7_1440w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-03a22891ccba9bccf6424dfd7cbf4be7_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">实用网络安全协议</div>
      </div>
      <!-- <div class="content">
        密码算法在网络各层中的部署网络安全协议的构造

加密和认证算法是构造网络安全协议的基本模块
在不同的层次实施加密算法具有
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-ctn"></div> 

<!-- 修改css与js文件如下即可-->
<!-- <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script> -->
<link rel='stylesheet' href='https://unpkg.com/gitment@0.0.3/style/default.css'>


<style>
  .gitment-comment-header {
    margin: 0;
    padding: 5px;
  }
</style>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  
<aside id='l_side'>
  
    
      
        <section class="widget side_blogger">
  <div class='content'>
    
    
      <div class='text'>
        
          <h2>NKU-Jan</h2>
        
        
          <p>CS Blog</p>

        
        
          <p><span id="jinrishici-sentence">Jan's Blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="/jan_nku@163.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="https://github.com/Jan-nku/Jan-nku.github.io"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=2643292013"
              class="social fab fa-qq flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
      </div>
    
  </div>
</section>

      
    
  
  
  
    
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-text">方法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-text">漏洞挖掘方法分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-text">静态分析技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-text">动态分析技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C"><span class="toc-text">符号执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">符号执行的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">符号执行的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C"><span class="toc-text">漏洞挖掘-检测是否数组越界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">污点分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0"><span class="toc-text">污点分析核心要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98"><span class="toc-text">漏洞挖掘实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E4%B8%80%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B"><span class="toc-text">实践一：基于词法分析和逆向分析的可执行代码静态检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%9F%BA%E4%BA%8EIDA-Pro%E5%88%86%E6%9E%90%E7%BB%99%E5%AE%9A%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-text">实验一：基于IDA Pro分析给定的可执行文件是否存在溢出漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E9%80%9A%E8%BF%87IDA%E6%89%93%E5%BC%80%E6%89%80%E7%94%9F%E6%88%90%E7%9A%84exe%E6%96%87%E4%BB%B6"><span class="toc-text">第一步：通过IDA打开所生成的exe文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%9A%E4%BD%8D%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0"><span class="toc-text">第二步：定位敏感函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Bugscam%E8%84%9A%E6%9C%AC%E6%9D%A5%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%B7%A5%E8%BF%87%E7%A8%8B%E5%AE%8C%E6%88%90%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98"><span class="toc-text">实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-text">数据流分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-text">数据流分析方法分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">程序代码模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">基于数据流的漏洞分析流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%A3%80%E6%B5%8B%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8"><span class="toc-text">示例一：检测指针变量的错误使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%A3%80%E6%B5%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-text">示例二：检测缓冲区溢出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-text">模糊测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="toc-text">模糊测试分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-text">基于生成的模糊测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%98%E5%BC%82%E7%9A%84%E8%BF%B7%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-text">基于变异的迷糊测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">模糊测试步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-text">智能模糊测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">智能模糊测试具体的实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">智能模糊测试的核心思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5"><span class="toc-text">模糊测试实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">使用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Fuzzer"><span class="toc-text">自己动手写Fuzzer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AFL%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-text">AFL模糊测试框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AFL%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-1"><span class="toc-text">AFL模糊测试框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AFL%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">AFL工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AFL%E5%AE%89%E8%A3%85"><span class="toc-text">AFL安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AFL%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-text">AFL模糊测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%AC%E6%AC%A1%E5%AE%9E%E9%AA%8C%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-text">创建本次实验的程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-text">创建测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-text">启动模糊测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90crash"><span class="toc-text">分析crash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87%E6%8A%80%E6%9C%AF"><span class="toc-text">程序切片技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87%E5%AE%9A%E4%B9%89"><span class="toc-text">程序切片定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE"><span class="toc-text">控制流图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E5%9B%BE"><span class="toc-text">程序依赖图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96%E5%9B%BE"><span class="toc-text">系统依赖图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95"><span class="toc-text">程序切片方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%8F%AF%E8%BE%BE%E7%AE%97%E6%B3%95"><span class="toc-text">图可达算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%87%E7%89%87"><span class="toc-text">动态切片</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF"><span class="toc-text">程序插桩技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%A1%A9%E6%A6%82%E5%BF%B5"><span class="toc-text">插桩概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%A1%A9%E5%88%86%E7%B1%BB"><span class="toc-text">插桩分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pin%E6%8F%92%E6%A1%A9%E7%A4%BA%E4%BE%8B"><span class="toc-text">Pin插桩示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8Pin"><span class="toc-text">安装及使用Pin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pin%E7%94%A8%E6%B3%95"><span class="toc-text">Pin用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Pintool"><span class="toc-text">使用Pintool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hook%E6%8A%80%E6%9C%AF"><span class="toc-text">Hook技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook%E6%A6%82%E5%BF%B5"><span class="toc-text">Hook概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AFHook"><span class="toc-text">消息Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AFHook%E7%9A%84DLL%E6%B3%A8%E5%85%A5"><span class="toc-text">基于消息Hook的DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E7%BC%96%E5%86%99DLL%E6%96%87%E4%BB%B6"><span class="toc-text">第一步：编写DLL文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E7%BC%96%E5%86%99DLL%E6%B3%A8%E5%85%A5%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-text">第二步：编写DLL注入功能的可执行文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%AE%9E%E9%AA%8C%E9%AA%8C%E8%AF%81"><span class="toc-text">第三步：实验验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API-Hook%E6%8A%80%E6%9C%AF"><span class="toc-text">API Hook技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Hook%E6%A6%82%E5%BF%B5"><span class="toc-text">API Hook概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%B5%B7%E5%A7%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">修改起始代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAT-Hook%E7%A4%BA%E4%BE%8B"><span class="toc-text">IAT Hook示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF"><span class="toc-text">符号执行技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">符号执行基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-text">程序执行状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E4%BC%A0%E6%92%AD"><span class="toc-text">符号传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%A0%91"><span class="toc-text">符号执行树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3"><span class="toc-text">约束求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-text">符号执行方法分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Z3%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E5%99%A8"><span class="toc-text">Z3约束求解器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Z3"><span class="toc-text">Z3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Z3%E5%B8%B8%E7%94%A8API"><span class="toc-text">Z3常用API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Angr%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">Angr应用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Angr%E7%A4%BA%E4%BE%8B"><span class="toc-text">Angr示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95"><span class="toc-text">其他解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-text">污点分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">污点分析基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E6%B1%A1%E7%82%B9%E6%BA%90%E5%92%8C%E6%B1%87%E8%81%9A%E7%82%B9"><span class="toc-text">识别污点源和汇聚点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90"><span class="toc-text">污点传播分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%AE%B3%E5%A4%84%E7%90%86"><span class="toc-text">无害处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">污点分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-text">显示流分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-text">静态分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-text">动态分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-text">隐式流分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%9A%90%E5%BC%8F%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-text">静态隐式流分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%9A%90%E5%BC%8F%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-text">动态隐式流分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%B1%A1%E6%8E%A7%E5%88%B6%E6%9D%A1%E4%BB%B6%E4%B8%8B%E9%9C%80%E8%A6%81%E6%A0%87%E8%AE%B0%E7%9A%84%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">如何确定污控制条件下需要标记的语句的范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%83%A8%E5%88%86%E6%B3%84%E9%9C%B2%E5%AF%BC%E8%87%B4%E7%9A%84%E8%AF%AF%E6%8A%A5"><span class="toc-text">如何解决部分泄露导致的误报</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%B1%A1%E7%82%B9%E6%A0%87%E8%AE%B0%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD"><span class="toc-text">如何选择合适的污点标记分支进行污点传播</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/20/ru-qin-jian-ce-xi-tong/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-20</span>
                
              </div>
              <a class="post-title" href="/2023/03/20/ru-qin-jian-ce-xi-tong/">入侵检测系统</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/19/kang-e-yi-ruan-jian/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-19</span>
                
              </div>
              <a class="post-title" href="/2023/03/19/kang-e-yi-ruan-jian/">抗恶意软件</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/18/wang-luo-bian-fang/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-18</span>
                
              </div>
              <a class="post-title" href="/2023/03/18/wang-luo-bian-fang/">网络边防</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/17/web-shen-tou-shi-zhan/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pica.zhimg.com/80/v2-573ac3e25de03fad9c32add5a05e5cfc_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-573ac3e25de03fad9c32add5a05e5cfc_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-17</span>
                
              </div>
              <a class="post-title" href="/2023/03/17/web-shen-tou-shi-zhan/">WEB渗透实战</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/17/yun-an-quan/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-5f7cb7e900b9dcf5354c3d4d2c5cc3c2_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-5f7cb7e900b9dcf5354c3d4d2c5cc3c2_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-17</span>
                
              </div>
              <a class="post-title" href="/2023/03/17/yun-an-quan/">云安全</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>


  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="/js/fancybox/jquery.fancybox.min.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script src='https://unpkg.com/gitment@0.0.3/dist/gitment.browser.js'></script>

<script>
comment_el = '#gitment-ctn';
load_gitment = function () {
  if ($(comment_el).length) {
    var gitment = new Gitment({
      id: "2023/03/15/lou-dong-wa-jue-pian/",
      owner: '',
      repo: '',
      oauth: {
        client_id: '',
        client_secret: '',
      },
    })
    gitment.render('gitment-ctn')
  }
}
$(document).ready(load_gitment);
document.addEventListener('pjax:complete', function () {
    load_gitment();
});
</script>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>