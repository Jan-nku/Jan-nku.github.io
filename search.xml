<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Protecting Poorly Chosen Secrets from Guessing Attacks</title>
      <link href="/2023/07/01/protecting-poorly-chosen-secrets-from-guessing-attacks/"/>
      <url>/2023/07/01/protecting-poorly-chosen-secrets-from-guessing-attacks/</url>
      
        <content type="html"><![CDATA[<p>In a security system that allows people to choose their own passwords, people tend to choose passwords that can be easily guessed. This weakness exists in practically all widely used systems. Instead of forcing users to choose secrets that are likely to be difficult for them to remember, solutions that maintain user convenience and a high level of security at the same time are proposed. The basic idea is to <strong>ensure that data available to the attacker is sufficiently unpredictable</strong> to prevent an offline verification of whether a guess is successful or not. Common forms of guessing attacks are examined, examples of cryptographic protocols that are immune to such attacks are developed, and <strong>a systematic way to examine protocols to detect vulnerabilities to such attacks</strong> is suggested.</p><span id="more"></span><h2 id="Guessing-Attacks"><a href="#Guessing-Attacks" class="headerlink" title="Guessing Attacks"></a>Guessing Attacks</h2><h3 id="The-UNIX-Password-System"><a href="#The-UNIX-Password-System" class="headerlink" title="The UNIX Password System"></a>The UNIX Password System</h3><p>UNIX使用的是一个口令文件<code>/etc/passwd</code>。这个文件对于每一个用户的口令$p$进行$hash$，每个口令进行$hash$时都有一个盐值$s$，盐值$s$和$hash$值$g(p, s)$都被存在口令文件中</p><p>攻击者可以猜测$p$的值然后进行$hash$，对于$hash$值进行验证来判断$p$的猜测是否正确</p><p>一种解决办法是限制<code>/etc/passwd</code>文件的访问权限</p><h3 id="SunOS-Secure-NFS"><a href="#SunOS-Secure-NFS" class="headerlink" title="SunOS Secure NFS"></a>SunOS Secure NFS</h3><p>去掉了<code>/etc/passwd</code>，转而使用公钥系统去加强安全性。SunOS-4.0引入了文件<code>/etc/publickey</code>，其中包括用户网络名称、用户的公钥和对应的私钥（私钥是用DES加密过的，DES的密钥由用户的口令派生）。用户登录时即可通过口令解密私钥，然后服务器<strong>验证私钥与公钥是否匹配</strong>即可验证口令的正确性。</p><p>因为<code>/etc/publickey</code>是公开的，攻击者依旧可以猜测口令$p$，然后解密私钥。再随意选取一段文本，利用已知的公钥和猜测出的私钥进行加密解密，观察结果是否一致即可验证$p$猜测的正确性。</p><p>一种解决方法是限制<code>/etc/publickey</code>的访问权限</p><p><strong>启示</strong>：对猜测攻击的脆弱性是具有传染性的</p><p><img src="image-20230702232636597.png" alt=""></p><h3 id="The-Kerberos-Authentication-System"><a href="#The-Kerberos-Authentication-System" class="headerlink" title="The Kerberos Authentication System"></a>The Kerberos Authentication System</h3><p>服务器最开始给用户返回的响应中包括一些可识别的信息比如说时间戳$t$和服务器$S$，而且这个响应是由用户的口令加密得到的。</p><p>所以攻击者可以对于截获的消息进行猜测攻击，解密后的数据可以通过对比，很明显地发现$t$是否是一个合理的时间或者$S$是否为合理的服务器名字符串，即可判断解密是否正确。</p><h2 id="Known-Plaintext-and-Verifiable-Text"><a href="#Known-Plaintext-and-Verifiable-Text" class="headerlink" title="Known Plaintext and Verifiable Text"></a>Known Plaintext and Verifiable Text</h2><p>攻击者发动猜测攻击时，往往需要一些验证性的信息来判断其猜测是否正确。已知明文攻击主要就是利用具有验证性的文本对其猜测攻击进行验证。</p><ul><li><p>已知明文攻击对于对称密码系统来说，可以通过猜测密钥对已知的密文进行解密，然后判断其对应的明文是否一致，从而进行攻击</p></li><li><p>对于非对称密码系统来说，猜测私钥是不现实的，所以可以猜测明文文本信息，然后利用公钥进行加密，来比对对应的密文是否一致，从而验证猜测是否正确</p></li></ul><h2 id="Protection-Techniques"><a href="#Protection-Techniques" class="headerlink" title="Protection Techniques"></a>Protection Techniques</h2><h3 id="simple-two-message-handshake-transaction"><a href="#simple-two-message-handshake-transaction" class="headerlink" title="simple two-message handshake transaction"></a>simple two-message handshake transaction</h3><p><img src="image-20230702233413467.png" alt=""></p><p>n是随机数，所以${\{n\}}_k$、${\{f(n)\}}_k$各自安全，但是如果被放在一起，则可以用f$()$验证，反而不安全</p><h3 id="Use-two-different-keys"><a href="#Use-two-different-keys" class="headerlink" title="Use two different keys"></a>Use two different keys</h3><p><img src="image-20230702233733378.png" alt=""></p><p>必须$k1$和$k2$都猜对才能攻击成功，可能需要多次验证，大大增加难度</p><p>如果$k1$已知（比如$k1$是公钥）、${\{n\}_{k1}}$已知，那么$k2$可能被比对出来结果。用$k2$解密得到$n’$，用${\{n’\}_{k1}}$与${\{n\}_{k1}}$比对。这种比对主要依赖f$()$，如果只是$f(n)=n+1$这种可逆的简单运算，攻击便可成功</p><h3 id="confounder-a-sufficiently-large-random-number"><a href="#confounder-a-sufficiently-large-random-number" class="headerlink" title="confounder(a sufficiently large random number)"></a>confounder(a sufficiently large random number)</h3><p><img src="image-20230702234447033.png" alt=""></p><p>引入大随机数作为公钥加密的干扰因子，从而避免公钥加密密文成为验证文本</p><p>随机数$c$的加入可以形成一次一密，但是$n$或$f(n)$可能并非严格的随机数，包含$recognizable$ $data$比如时间戳，会被用来验证</p><h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><p><img src="image-20230702234848244.png" alt=""></p><p>引入掩码从而掩盖住具有含义的信息，从而解决验证文本的问题</p><h2 id="Authentication-Protocols"><a href="#Authentication-Protocols" class="headerlink" title="Authentication Protocols"></a>Authentication Protocols</h2><h3 id="A-Mutual-Authentication-Protocol"><a href="#A-Mutual-Authentication-Protocol" class="headerlink" title="A Mutual Authentication Protocol"></a>A Mutual Authentication Protocol</h3><p>其中$K_a$和$K_b$是A、B与S的共享密钥，$k$是A、B之间的会话密钥，$K_s$是server的公钥，$t_a$和$t_b$代表两个时间戳</p><p><img src="image-20230702235024922.png" alt=""></p><ul><li>$Message1、3$：这两条消息对称，以$Message1$为例，包括三个随机数$na1$，$na2$，$ca$；一个只能由A产生的新鲜性消息$\{t_a\}_{K_a}$，声明A要与B进行通信</li><li><p>$Message4、5$：这两条消息对称，以$Message1$为例，$na1$代表对第一条消息的正确破解，$na1$和$na2$在多次通信中不能重用；$na2$用于隐藏$k$，防止外来攻击者（外部攻击）或者B（内部攻击）图谋不轨（没有$na2$，B可以用$k$验证对于$K_a$的猜测）。$ca$作为随机数干扰因子，也用于防止B的恶意（如果没有$ca$，一旦B截获了第四条消息，B可以去猜测$K_a$，然后B可以得到$na1$、$na2$、$k$，再加上公开的A、B、$K_s$，B可以恢复第一条消息验证是否相同，进而确认猜测是否正确）</p></li><li><p>$Message 6-8$：挑战应答机制</p></li></ul><h3 id="Reducing-the-Number-of-Messages"><a href="#Reducing-the-Number-of-Messages" class="headerlink" title="Reducing the Number of Messages"></a>Reducing the Number of Messages</h3><p><img src="image-20230703000209566.png" alt=""></p><p><strong>Enhanced Kerberos Protocol</strong></p><p><img src="image-20230703000255264.png" alt=""></p><p>由于B是服务器，因此它与服务器S共享的密钥$K_b$也可以被认为是经过精心选择的，不会造成猜测攻击</p><h3 id="Using-Nonces"><a href="#Using-Nonces" class="headerlink" title="Using Nonces"></a>Using Nonces</h3><p>在某些系统中，我们可能不希望假设同步时钟的可用性。相反，我们可以使用众所周知的挑战-响应技术来确定信息的及时性</p><p><img src="image-20230703000412931.png" alt=""></p><h3 id="Identification"><a href="#Identification" class="headerlink" title="Identification"></a>Identification</h3><p>像ATM卡、信用卡、通行卡、电子通行、电话卡等。这种情况下通信不需要会话密钥，也不需要双向认证，只需要简单的身份认证即可</p><p><img src="image-20230703000533886.png" alt=""></p><h3 id="Using-Secret-Public-Keys"><a href="#Using-Secret-Public-Keys" class="headerlink" title="Using Secret Public Keys"></a>Using Secret Public Keys</h3><p>无需记录公钥，由server发送</p><p>公钥要保密好，不然随意泄露出去会成为验证文本</p><p><img src="image-20230703000619804.png" alt=""></p><h3 id="Direct-Authentication"><a href="#Direct-Authentication" class="headerlink" title="Direct Authentication"></a>Direct Authentication</h3><p>A、B已经共享密钥$K_{ab}$，直接进行身份认证即可。$K_{ab1}$是公钥。</p><p><img src="image-20230703000741839.png" alt=""></p><h2 id="Detecting-Vulnerability"><a href="#Detecting-Vulnerability" class="headerlink" title="Detecting Vulnerability"></a>Detecting Vulnerability</h2><p>搜索可验证文本可以看作是图论中的寻径问题</p><p>一条找到的路径对应着一种可能的攻击方式，最短路径给出了成功攻击所需的最小努力的度量</p><h3 id="Compared-with-EKE-using-public-keys"><a href="#Compared-with-EKE-using-public-keys" class="headerlink" title="Compared with EKE using public keys"></a>Compared with EKE using public keys</h3><p><img src="image-20230703001246528.png" alt=""></p><p>由于我们使用了<strong>混淆和随机数</strong>，因此会话密钥$k$和初始选择不佳的密钥$p$是安全隔离的，这样泄露会话密钥的影响严格限于该会话的消息</p><p>然而，EKE协议中，泄露会话密钥$r$将使攻击者能够在未来的所有会话中重播$Message 2$并伪装成B。此外，它还允许猜测攻击，攻击者可以猜测$p$，解密$Message 1$获得k，并使用$p$、$k$、$r$重构$Message 2$以进行验证</p><h2 id="Advantages-amp-disadvantages"><a href="#Advantages-amp-disadvantages" class="headerlink" title="Advantages &amp; disadvantages"></a>Advantages &amp; disadvantages</h2><p>优点</p><ul><li>提出防范由于$Verifiable$ $Text$造成猜测攻击的方法：使用混淆和随机数</li><li>提出考虑到实际因素、适用于不同场景的认证协议及其变体</li><li>概述一种系统方法来检查协议对猜测攻击的脆弱性</li></ul><p>缺点/不足</p><ul><li>和EKE协议一样，都容易受到数论攻击</li><li><p>使一个协议对猜测攻击鲁棒需要增加多少成本，尚不清楚</p></li><li><p>目前还不清楚公钥加密技术的使用有多重要；如果用户不必保留巨大的常量（即使它们是公开的），那就太好了。</p></li><li><p>缺乏协议的安全性证明</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码协议 </tag>
            
            <tag> PAKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encrypted Key Exchange: Password-Based Protocols Secure Against Dictionary Attacks</title>
      <link href="/2023/07/01/encrypted-key-exchange-password-based-protocols-secure-against-dictionary-attacks/"/>
      <url>/2023/07/01/encrypted-key-exchange-password-based-protocols-secure-against-dictionary-attacks/</url>
      
        <content type="html"><![CDATA[<p>Classical cryptographic protocols based on user-chosen keys allow an attacker to mount password-guessing attacks. We introduce <strong>a novel combination of asymmetric (public-key) and symmetric (secret-key) cryptography</strong> that allow two parties sharing a common password to exchange confidential and authenticated information over an insecure network. These protocols are secure <strong>against active attacks</strong>, and have the property that the password is protected <strong>against off-line “dictionary”attacks</strong>. There are a number of other useful applications as well,including secure public telephones.</p><span id="more"></span><h2 id="Classical-key-negotiation"><a href="#Classical-key-negotiation" class="headerlink" title="Classical key negotiation"></a>Classical key negotiation</h2><p>预先共享password P，打算协商会话密钥R，T代表终端类型。用会话密钥加密返回一个终端类型表示会话密钥协商成功</p><p><img src="image-20230701142959098.png" alt=""></p><p><strong>attack</strong>：攻击者利用①消息解密$R’=P’^{-1}(P(R))$，再利用$R’$去测试②的消息$T’=R’^{-1}(R(T))$。由于$T$代表了终端类型，所以$T$本身是有含义的，攻击者即可通过观察$T’$是否具有代表终端类型的含义即可判断解密是否成功。</p><p><strong>idea</strong>：由于password本身的搜索空间要小，所以攻击者可以通过穷举进行破解，然后利用一些验证性的文本来确定其破解是否正确。</p><h2 id="EKE-using-public-keys"><a href="#EKE-using-public-keys" class="headerlink" title="EKE using public keys"></a>EKE using public keys</h2><h3 id="Basic-concepts"><a href="#Basic-concepts" class="headerlink" title="Basic concepts"></a>Basic concepts</h3><p>其中$E_{A}$代表公钥，$D_{A}$代表私钥。</p><p><img src="image-20230701143843414.png" alt=""></p><p><strong>advantages</strong></p><ul><li><p>R被公钥保护了起来，变得难以被破解</p></li><li><p>$E_{A’}=P’^{-1}(P(E_A)$，$E_A$本身是随机数，不能通过观察辨认出解密出的结果是否为公钥。determining whether $E_A$ is the public key used in the exchange amounts to determining whether there exists a secret key $R’$ such that $E_{A’}(R’)=E_{A}(R)$ and $R’^{-1}(R(Terminal$ $type:))$make sense</p></li><li><p>公钥是非对称的，只用公钥加密的文本和公钥本身，无法解密文本</p></li></ul><p><strong>disadvantages</strong></p><ul><li>缺少新鲜性验证，易受<code>replay attacks</code></li></ul><h3 id="A-complete-protocol"><a href="#A-complete-protocol" class="headerlink" title="A complete protocol"></a>A complete protocol</h3><p><img src="image-20230701145431802.png" alt=""></p><h2 id="Two-concrete-implementations"><a href="#Two-concrete-implementations" class="headerlink" title="Two concrete implementations"></a>Two concrete implementations</h2><h3 id="Implementing-EKE-using-RSA"><a href="#Implementing-EKE-using-RSA" class="headerlink" title="Implementing EKE using RSA"></a>Implementing EKE using RSA</h3><p>用RSA实现重点在于关注公钥<e, n>，目前尚不清楚如何有效地对一对<e, n>进行编码，使其与随机字符串无法区分</p><ul><li><p>$n$的注意细节</p><ul><li><p>$n$是不能够被$P$加密后进行发送的，只能通过明文发送。因为$n$本身要求是具有两个大素数因子，这个信息将成为用于验证的信息。攻击者解密$P(n)$得到的$n’$如果有小因子就可以说明$P$的猜测是错误的，这样攻击者就可以快速进行筛选。</p></li><li><p>如果$n$没被加密可能会被密码分析</p><blockquote><p>paper review: if n is available to the attacker,it could be factored;that in turn would disclose R and expose p to attack. Without knowing n,an enemy cryptanalyst would be reduced to solving a system where the only plaintext was random. That task is essentially impossible.</p></blockquote></li></ul></li><li><p>$e$的注意细节</p><ul><li>$e$要随机加1再进行加密，因为$e$一定是奇数，所以攻击者可以利用这个信息作为验证信息去进行筛选，只要$e$以1/2的几率加1，那么正常的接收方接到$e$后如果是偶数则减1即可，而攻击者则不知道这个解密出来的偶数结果本身就是错的，还是正确的奇数加1</li><li>$e$本身不会泄露信息，$e$只要与$(p-1)(q-1)$互素即可，而一般在选择$p$和$q$的时候，都要求$(p-1)/2$和$(q-1)/2$是素数，所以$e$的候选范围很大，不会暴露$P$的信息</li></ul></li></ul><p>如果e和n都是以明文发送的话，则可能会被<strong>仿冒攻击/e次剩余攻击</strong>。</p><ul><li><p>攻击者构造好e和n，其中e不满足与(p-1)(q-1)互素，则会导致整个的搜索空间坍缩。攻击者可以对消息②进行猜测P解密，然后得到密文$M’=E_{A}(R)=R^e(mod$ $n)$</p></li><li><p>此后只要验证$M’^{φ(n)/e}=1(mod$ $n)$只要满足的，就说明$P$猜测正确了</p></li><li>此方法需要依赖于e不满足基本条件$ed=1(mod(p-1)(q-1))$。因为一旦满足这个基本条件，那么$φ(n)/e$一定可以是一个整数的形式（e的逆元是d），那么对于任意的解密结果都满足等式（根据欧拉定理）</li></ul><p>防范这种攻击的话，接收公钥的接收方可以发送一个随机数然后用e加密，并等待发送方返回一个解密后的结果，一旦e本身不满足基本条件，那么发送方一定无法进行解密，则接收方可以防范此攻击。不过多一轮通信，代价也很大。</p><h3 id="Using-the-ElGamal-asymmetric-cryptosystem"><a href="#Using-the-ElGamal-asymmetric-cryptosystem" class="headerlink" title="Using the ElGamal asymmetric cryptosystem"></a>Using the ElGamal asymmetric cryptosystem</h3><ul><li>公钥$α^{R_{A}}$，私钥$R_{A}$，加密消息为$(α^{k}$, $mα^{R_{A}k})$</li><li><p>需要注意避免类型攻击</p></li><li><p>引入了新的秘密$k$，所以要保护好$k$</p></li></ul><p><img src="image-20230701173911615.png" alt="类型攻击推导"></p><p><strong>思考</strong>：RSA与ElGamal的区别（原文中这样提到），ElGamal可以根据新引入的秘密k和公钥恢复密文，即使在不知道密钥的情况下</p><p><img src="image-20230701174343173.png" alt=""></p><h2 id="Security-considerations"><a href="#Security-considerations" class="headerlink" title="Security considerations"></a>Security considerations</h2><h3 id="Partition-attacks"><a href="#Partition-attacks" class="headerlink" title="Partition attacks"></a>Partition attacks</h3><p>分区攻击的本质是利用了某些验证性信息。不难理解，在破解$P$所加密过的信息时，如果知道正确的结果是什么，那么在穷举的过程中可以排除所有错误的$password$。同理，哪怕是不能知道正确结果是什么，但是知道正确结果的某些验证性属性，比如说$e$一定是奇数，那么就可以排除将近一半的错误$password$，从而达到对数级别排除字典中不匹配的$password$。这就是分区攻击的主要思想。</p><p>可能被分区攻击的地方：</p><ul><li>使用$n$比特编码模数$p$，但如果$p$与$2^n$相差较大，解密出来大于$p$的可以排除掉</li><li>加密分组太大，导致分组高位有好多的0，这些位应该用随机数据填充</li></ul><p>可以通过直接加一定的模数$p$来进行防御，接收方知道$p$，可以很容易地将解密值减小到合适的范围。</p><p><img src="image-20230701182039892.png" alt=""></p><p><strong>思考</strong>：密码协议设计不能泄露正确结果的某些验证性属性，直接泄露验证项造成off-line attack容易被发现，但是像上述两种潜在的攻击风险，令人防不胜防！<font color="red">这些漏洞具有很强的掩蔽性和欺骗性，很难被发现，甚至你不会意识到这能被利用造成攻击。</font></p><h3 id="Tacit-assumptions"><a href="#Tacit-assumptions" class="headerlink" title="Tacit assumptions"></a>Tacit assumptions</h3><ul><li>对称或对称加密系统都不会泄露有用的信息</li><li>使用$E_{A}$对$R$加密，不会泄露公钥$E_{A}$和会话密钥$R$有用的信息</li></ul><h3 id="Strengthening-EKE-against-cryptanalytic-attacks"><a href="#Strengthening-EKE-against-cryptanalytic-attacks" class="headerlink" title="Strengthening EKE against cryptanalytic attacks"></a>Strengthening EKE against cryptanalytic attacks</h3><ul><li>会话密钥$R$一旦泄露，不具备前向安全性</li><li>在挑战响应中加入生成密钥的子密钥即可</li></ul><p>$R(challenge_{A}, S_{A})$和$R(challenge_{A}, challenge_{B}, S_{B})$，然后会话密钥通过$S=f(S_A, S_B)$得到</p><p><strong>思考</strong>：密钥独立性设计原则，$R$只用于<code>key exchange key</code>，$S$用于<code>all subsequent exchanges</code></p><p><img src="image-20230701184232434.png" alt=""></p><h2 id="EKE-using-exponential-key-exchange（DH-EKE）"><a href="#EKE-using-exponential-key-exchange（DH-EKE）" class="headerlink" title="EKE using exponential key exchange（DH-EKE）"></a>EKE using exponential key exchange（DH-EKE）</h2><p><img src="image-20230701184915219.png" alt=""></p><p>将挑战应答也加入其中，最终成功分配密钥$K ≡ α^{R_{A}R_{B}}(mod$ $β)$，注意攻击者选0作为指数使得$K=1$的情况（容易检测）</p><p>需要保管好$α^{R_{A}}$和$α^{R_{B}}$，否则会提供口令验证项</p><p>$α$和$β$的取值：<font color="red">a range of tradeoffs between cost and security</font></p><p>其中注意$α$必须是$GF(β)$的原根，$β=kp+1$，其中$p$是素数。这两个元素在<code>initial exchange</code>阶段生成并直接明文发送</p><h2 id="Advantages-amp-disadvantages"><a href="#Advantages-amp-disadvantages" class="headerlink" title="Advantages &amp; disadvantages"></a>Advantages &amp; disadvantages</h2><p>优点</p><ul><li>引入了非对称(公钥)和对称(密钥)加密的组合，允许共享公共密码（口令）的双方在不安全的网络上交换机密和经过身份验证的信息</li><li>提出一种依赖于使用密钥加密公钥反直觉概念的协议，能够抵御主动攻击、离线字典攻击</li><li>针对ElGamal公钥系统（$disclosing$ $encryption$ $system$）构建的EKE，提出类型攻击</li></ul><p>缺点/不足</p><ul><li>没有给出协议的安全性证明</li><li>host/server需要保存口令的明文，某些场景下不安全</li><li>两方协议，可以扩展到三方场景下</li><li>协议的效率有待提高</li><li>一些理论研究尚不充分，比如$disclosing$ $encryption$ $system$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码协议 </tag>
            
            <tag> PAKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proverif学习</title>
      <link href="/2023/06/30/proverif-xue-xi/"/>
      <url>/2023/06/30/proverif-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>ProVerif可以用来自动分析密码协议的Security性质，功能涵盖对称和非对称加密、数字签名、哈希函数、比特承诺、非交互式零知识证明。ProVerif可以证明可达性(reachability)，对应断言(correspondence assertion)，和可观察的等价性(observational equivalence)。这个能力使得它能对计算机安全领域中的机密性和认证性质进行分析，也可以考虑一些新兴的性质，如隐私性(privacy)、可追溯性(traceability)、可验证性(verifiability)。它还具有攻击重构的功能，如果某个性质不能被证明，ProVerif就会尝试构造一个反例trace。</p><span id="more"></span><h2 id="Proverif"><a href="#Proverif" class="headerlink" title="Proverif"></a>Proverif</h2><p>Proverif用来验证密码协议，密码协议是利用互联网等公共通信渠道进行交互以实现一些与安全相关的目标的并发程序。Proverif是在Dolev-Yao模型下进行密码协议验证的。在Dolev-Yao模型下，攻击者可以完全控制通信信道，可以读取、修改、删除以及注入消息，攻击者还可以操纵数据，例如：计算元组的莫个参数，使用密钥解密信息。Proverif还将检测不诚实的参与者行为，只有诚实的参与者会被建模。</p><p>Proverif允许密码术语和相关安全性目标以形式化的方式输入，允许自动验证声明的安全性目标。假设密码是完美的，只有攻击者拥有所需的密钥才能执行密码操作。运用对等原理或者重写规则来获取密码术语之间的关系。</p><p>使用Proverif语言，需要分三步，第一步声明；第二步进程宏；第三步主进程。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>ProVerif依赖于符号化的Dolev-Yao密码学模型，所以结果不能应用于计算模型，如果要用计算模型可以考虑<a href="https://prosecco.gforge.inria.fr/personal/bblanche/cryptoverif/">CryptoVerif</a>等其它工具。</p><blockquote><p>ProVerif使用符号执行技术和Dolev-Yao模型对协议进行分析和验证。由于这种模型的抽象性质，ProVerif的结果在某些情况下可能无法直接应用于具体的计算模型。</p><p>Dolev-Yao模型假设通信网络是可信的，并且攻击者无法干扰、篡改或拦截通信。这种理想化的假设在现实世界中并不成立，因为真实的网络环境中存在各种攻击和安全威胁。</p><p>因此，尽管ProVerif可以对协议在Dolev-Yao模型下的安全性进行形式化验证，但在实际应用中，需要将结果与具体的计算模型和网络环境结合起来进行综合评估。这意味着ProVerif的结果可能需要在实际环境中进行进一步的验证和测试，以确保协议在现实的计算模型下的安全性。</p><p>另外，ProVerif的符号执行技术也存在一定的局限性，例如对于复杂的协议和大规模系统的分析可能效率较低。因此，在使用ProVerif时，需要谨慎考虑其适用性和局限性，并结合其他验证方法和实验结果进行综合评估和决策。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/18a10c3e271f">win10下使用doskey在cmd中建立类似于linux中alias的宏 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/SHU15121856/article/details/107927165">(140条消息) 【ProVerif学习笔记】1：基本使用流程_LauZyHou的博客-CSDN博客</a></p><p><a href="https://lauzyhou.blog.csdn.net/article/details/107937590">(140条消息) 【ProVerif学习笔记】2：协议建模中的声明_LauZyHou的博客-CSDN博客</a></p><p><a href="https://lauzyhou.blog.csdn.net/article/details/107952903">(140条消息) 【ProVerif学习笔记】3：进程宏和进程书写的语法规则_LauZyHou的博客-CSDN博客</a></p><p><a href="https://lauzyhou.blog.csdn.net/article/details/107971240">(140条消息) 【ProVerif学习笔记】4：信息安全性质(Security Property)_proveif信息安全_LauZyHou的博客-CSDN博客</a></p><p><a href="https://lauzyhou.blog.csdn.net/article/details/107996703">(140条消息) 【ProVerif学习笔记】5：理解验证后的输出_LauZyHou的博客-CSDN博客</a></p><p><a href="https://lauzyhou.blog.csdn.net/article/details/116376508">(140条消息) 【ProVerif学习笔记】6：握手协议（handshake protocol）建模_protocol handshake_LauZyHou的博客-CSDN博客</a></p><p><a href="https://lauzyhou.blog.csdn.net/article/details/116421746">(140条消息) 【ProVerif学习笔记】7：基本建模特性_proverif const_LauZyHou的博客-CSDN博客</a></p><p><a href="https://lauzyhou.blog.csdn.net/article/details/116866480">(140条消息) 【ProVerif学习笔记】8：更多密码学特性_LauZyHou的博客-CSDN博客</a></p><p><a href="https://github.com/nitrogl/speke-verification">Symbolic verification of SPEKE protocols</a></p>]]></content>
      
      
      <categories>
          
          <category> 密码协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码协议 </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于RSA的网关口令认证密钥交换协议的分析与改进</title>
      <link href="/2023/06/28/ji-yu-rsa-de-wang-guan-kou-ling-ren-zheng-mi-yao-jiao-huan-xie-yi-de-fen-xi-yu-gai-jin/"/>
      <url>/2023/06/28/ji-yu-rsa-de-wang-guan-kou-ling-ren-zheng-mi-yao-jiao-huan-xie-yi-de-fen-xi-yu-gai-jin/</url>
      
        <content type="html"><![CDATA[<p>2011 年 Wei 等学者首次提出了一个基于 RSA 的可证明安全的网关口令认证密钥交换协议，并声称在随机预言模型下基于大整数素因子分解的困难性证明了协议的安全性。利用该协议中服务器端提供的预言机服务，提出一 种分离攻击，攻击者只需发起几十次假冒会话便可恢复出用户的口令。攻击结果表明，该协议无法实现所声称的口令保护这一基本安全目标，突出显示了分离攻击是针对基于 RSA 的口令认证密钥交换协议的一种严重安全威胁。进一步指出了协议形式化安全证明中的失误，给出一个改进方案。分析结果表明，改进方案在提高安全性的同时保持了较高效率，更适于移动通信环境。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Partition-Attack"><a href="#Partition-Attack" class="headerlink" title="Partition Attack"></a>Partition Attack</h3><p>PAKE 协议易遭字典攻击。依据攻击者对所猜测口令的验证方式，字典攻击主要分为离线字典攻击、在线字典攻击。</p><p>基于 RSA 的 PAKE 协议易遭受一类特殊的字典攻击——<strong>分割攻击(Partition Attack)</strong>。这种攻击将离线字典攻击和在线字典攻击结合起来</p><ol><li>通过仿冒合法用户参与协议运行来收集口令相关信息</li><li>离线地从口令字典中过滤掉非潜在口令</li></ol><p>重复步骤 1、2 直到剩下最后一个潜在口令，这个口令便是受害者所使用的口令，攻击成功。需要指出的是，攻击者通过步骤 1 收集的信息，可在步骤 2 中一次过滤掉两个以上口令，这是分割攻击与在线字典攻击的本质区别。</p><p>针对基于 RSA 的 PAKE 协议最典型两种分割攻击是 e 次剩余攻击 (e-Residue Attack) 和分离攻击 (Separation Attack)</p><h3 id="Flaws-in-RSA-GPAKE"><a href="#Flaws-in-RSA-GPAKE" class="headerlink" title="Flaws in RSA-GPAKE"></a>Flaws in RSA-GPAKE</h3><p>2011 年，Wei 等学者<sup><a href="#fn_1" id="reffn_1">1</a></sup>指出现有基于网关的口令认证密钥协商 (Gateway-oriented PAKE, GPAKE) 协议都存在这样或那样的安全缺陷，首次提出了基于 RSA 的安全高效的 GPAKE 协议 (简称 RSA-GPAKE)， 并宣称在随机预言机模型 (Random Oracle Model, ROM)<sup><a href="#fn_2" id="reffn_2">2</a></sup>下证明了协议的安全性。</p><p>但本文分析发现，RSA-GPAKE 协议对分离攻击是脆弱的，主动攻击者可在非常有限的交互次数内恢复出合法用户的口令。因此，RSA-GPAKE 协议存在严重安全缺陷，无法实现所宣称的安全性，在对该缺陷进行修正前不适于实际应用。</p><p><strong>一个被形式化证明 “安全”了的协议为什么结果是不安全的？</strong>为解释这一矛盾现象，本文进一步分析了原协议形式化安全证明中的失误之处。为克服 RSA-GPAKE 协议中的上述严重安全缺陷，本文借鉴文献<sup><a href="#fn_3" id="reffn_3">3</a></sup>中 PEKEP 协议防御”有用信息泄露“的思想，提出一个改进方案，并在 ROM 模型下给出了相应的严格归约证明 (Rigorous Reduction Proof)。分析结果表明，改进方案在提高安全性的同时，保持了较高的效率，更适用实际移动应用环境。</p><h2 id="GPAKE协议的安全模型"><a href="#GPAKE协议的安全模型" class="headerlink" title="GPAKE协议的安全模型"></a>GPAKE协议的安全模型</h2><h3 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h3><p>网关口令认证密钥交换 (GPAKE) 协议是一个由用户、网关和服务器参与的三方协议，协议的目 标是用户和网关在服务器的帮助下建立一个认证的会话密钥。</p><p>用户和网关之间的通信信道是不安全的公开信道，由敌手完全控制，可以窃听、阻断、删除和窜改流经公开网络中的任何消息，也可以插入伪造的消息；网关和服务器之间的通信则存在安全通道。</p><p>假设用户和服务器间事先共享一个低信息熵的口令，并且网关不知道口令的信息。GPAKE 协议的主要安全目标是通过服务器的参与，在用户和网关建立一个安全的会话密钥，并且实现用户口令对网关的私密性、会话密钥对服务器的私密性。</p><h3 id="攻击者能力"><a href="#攻击者能力" class="headerlink" title="攻击者能力"></a>攻击者能力</h3><ul><li>Execute($C^i$, $G^j$)：模拟攻击者的被动攻击(窃听)的能力</li><li>Send($U^i$, m)：模拟攻击者的主动攻击</li><li>Test($U^i$)：用来定义会话密钥的语义安全性，只对 “新鲜”的会话有效。如果实例$U^i$的会话密钥尚没有定义，返回⊥。 否则，随机选择一个比特 b，如果 b=1，向攻击者返回会话密钥 sk；如果 b=0，向攻击者返回一个等长的随机串。</li><li>Test($C^i$, $G^j$)：刻画会话密钥对于服务器的私密性。如果用户实例$C^i$和网关实例$G^j$之间还没有建立共享的会话密钥，返回⊥。 否则，随机选择一个比特 b，如果 b=1，向攻击者返回会话密钥 sk；如果 b=0，向攻击者返回一个等长的随机串。</li></ul><p>RSA-GPAKE 协议会话密钥的语义安全性通过 Real-Or-Random (ROR) 攻击游戏<sup><a href="#fn_4" id="reffn_4">4</a></sup> 而非传统的 Find-Then-Guess (FTG)来模型化。在 ROR 攻击游戏中, 敌手可以进行多次 Test 查询，ROR 模型下攻击者的攻击能力要比 FTG 模型下强，关于二者的更详细比较可参见文献<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</p><h3 id="安全目标"><a href="#安全目标" class="headerlink" title="安全目标"></a>安全目标</h3><p>Abdalla 等人<sup><a href="#fn_4" id="reffn_4">4</a></sup>的 GPAKE 协议安全模型中有四个安全目标，前两项是所有 PAKE 协议所应实现的基本目标<sup><a href="#fn_2" id="reffn_2">2</a></sup> , 后两项是 GPAKE 协议所独有的目标。</p><ul><li><p>语义安全性：一个外部攻击者不能够多项式时间内将真实的会话密钥和与之等长的随机串区分开来</p></li><li><p>认证性：攻击者不能仿冒协议中的真实实体</p></li><li><p>密钥私密性：用户和网关之间建立的会话密钥对于诚实而好奇的服务器是不可区分的(专门针对服务器)</p></li><li><p>口令保护： 恶意网关通过协议运行不能得到用户口令的任何信息(专门针对网关)</p></li></ul><h2 id="RSA-GPAKE-协议的安全性分析"><a href="#RSA-GPAKE-协议的安全性分析" class="headerlink" title="RSA-GPAKE 协议的安全性分析"></a>RSA-GPAKE 协议的安全性分析</h2><h3 id="RSA-GPAKE"><a href="#RSA-GPAKE" class="headerlink" title="RSA-GPAKE"></a>RSA-GPAKE</h3><p><img src="image-20230701070745990.png" alt=""></p><h3 id="分离攻击"><a href="#分离攻击" class="headerlink" title="分离攻击"></a>分离攻击</h3><p>分离攻击针对的是 RSA-GPAKE 协议的“口令保护”这一基本安全目标，该攻击只需要攻击者 (外部攻击者或内部恶意网关) 有如下两种能力</p><ol><li>可以窃听、阻断、删除和窜改流经公开网络中的任何消息，也可以插入伪造的消息</li><li>可以多项式时间内穷举搜索口令空间</li></ol><p>上述两个攻击者能力假设是分析 PAKE 协议安全性的基本假设，也是所有 PAKE 协议面临的共同难题</p><p><img src="image-20230701071040849.png" alt=""></p><p>在上述攻击的步骤 4)中，攻击者收到来自网关G的响应消息意味着$gcd(α{^<em>}, n_{A} = 1)$，因此攻击者可以在步骤 7) 中通过检验$gcd(α{^</em>}, n_{A} = 1)$是否成立来验证所猜测的口令的正确性。</p><p><img src="image-20230701071908527.png" alt=""></p><p><img src="image-20230701071942112.png" alt=""></p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li><p>禁止 n 含小因子</p></li><li><p>限制攻击者发起假冒会话的次数</p><ul><li>通过限制假冒会话总次数的方式</li><li>通过限制连续假冒会话次数的方式</li></ul></li></ul><font color="red">这些方案均不可行</font><h3 id="协议形式化安全证明中的失误"><a href="#协议形式化安全证明中的失误" class="headerlink" title="协议形式化安全证明中的失误"></a>协议形式化安全证明中的失误</h3><p>RSA-GPAKE在证明其“口令保护”这一目标时，并没有采用严格的推理将攻击者对口令的猜测攻击归约到求解数学难题上 (如 RSA-GPAKE 所基于的 RSA 困难性假设)，而是在关键点下了轻率的结论——“恶意网关想要成功进行不可检测在线字典攻击，必须返回一个有效的认证值$μ$。如果恶意网关不知道 a，那么成功的概率至多为 $2^k$.”</p><p>RSA-GPAKE在阐述其“口令保护”这一安全目标的证明思想时，宣称可以直接利用 PEKEP 协议<sup><a href="#fn_3" id="reffn_3">3</a></sup>的证明得到——“由 PEKEP 协议的证明可知，恶意网关每次和服务器进行交互至多排除掉一个口令.”</p><p>我们进一步分析了 PEKEP 协议<sup><a href="#fn_3" id="reffn_3">3</a></sup>的安全性证明，发现 PEKEP 协议的“口令保护”这一 安全目标的相关证明并不直接适用于 RSA-GPAKE 协议。<font color="red">这表明 RSA-GPAKE 协议的“口令保护”这一安全目标的证明思想存在失误</font>，而这一失误正是导致文献<sup><a href="#fn_6" id="reffn_6">6</a></sup>形式化证明失效的根本原因。</p><p><img src="image-20230701073118770.png" alt=""></p><p><img src="image-20230701073502878.png" alt="image-20230701073502878"></p><p><strong>警告：</strong>对协议进行形式化证明只是手段而不是结果，<font color="red">对潜在攻击的忽视和非紧致的归约常导致证明结果的失效</font>，又由于证明过程的复杂性和证明方法的技巧性，这种失效的结果往往具有很强的隐蔽性和欺骗性，只有通过具体的攻击才能使协议的脆弱性得以显现。</p><p>虽然形式化方法已被很多密码学者认为是确保密码协议安全性的核心(甚至唯一)手段，但启发式分析(即传统的攻击分析)在建立和保持对密码协议的信任方面仍然具有不可替代的作用。</p><h2 id="改进方案-RSA-GPAKE"><a href="#改进方案-RSA-GPAKE" class="headerlink" title="改进方案 RSA-GPAKE+"></a>改进方案 RSA-GPAKE+</h2><p><img src="image-20230701074037149.png" alt=""></p><h2 id="Advantages-amp-disadvantages"><a href="#Advantages-amp-disadvantages" class="headerlink" title="Advantages &amp; disadvantages"></a>Advantages &amp; disadvantages</h2><p>优点</p><ul><li>指出 RSA-GPAKE 协议容易受到分离攻击，无法实现所声称的口令保护这一基本安全目标。</li><li>进一步分析了 RSA-GPAKE 协议形式化安全证明中的疏漏之处，指出协议失误的根本原因，提出 一个改进方案，在未增加计算量和通信量的情况下修正了原协议的缺陷，并基于 ROM 模型给出了严格的归约证明</li><li>给协议设计者的启示：对协议进行形式化证明只是手段而不是结果，<font color="red">对潜在攻击的忽视和非紧致的归约常导致证明结果的失效</font></li></ul><p>缺点/不足</p><ul><li><p>在显示协议的完备性方面没有建树，如何确保此类协议完备性将是下一步重点工作</p></li><li><p>GPAKE 协议适用于移动通信环境，而移动环境中用户的隐私是重要的关注对象，因此设计具有匿名性的安全高效的基于 RSA 体制的 GPAKE 协议，也是值得进一步研究的方向</p></li><li><p>协议假设字典空间服从均匀分布（现实场景下口令基于Zipf分布）、安全性基于 RSA 困难性假设（RSA至少要4096bit才能保障安全），低估攻击者的攻击能力？</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:魏福山, 马传贵, 程庆丰. 基于RSA的网关口令认证密钥交换协议[J]. 计算机学报, 2011, 34(1): 38–46.<br><sup><a href="#fn_2" id="reffn_2">2</a></sup>:Bellare M, Pointcheval D, Rogaway P: Authenticated key exchange secure against dictionary attacks[A]. Proceedings of Eurocrypt 2000[C]. Berlin : SpringerVerlag,LNCS, Vol. 1807, 2000:139–155.<br><sup><a href="#fn_3" id="reffn_3">3</a></sup>:Zhang Mu-Xiang. New approaches to password authenticated key exchange based on RSA[A]. Proceedings of Asiacrypt 2004[C]. Berlin: Springer-Verlag, LNCS, Vol.3329, 2004: 230–244.<br><sup><a href="#fn_4" id="reffn_4">4</a></sup>:Abdalla M., Chevass O., Fouque P., Pointcheval D. A simple threshold authenticated key exchange from short secrets[A]. Proceedings of Asiacrypt 2005. Berlin: Springer-Verlag, LNCS, Vol.3788, 2005: 566–584.<br><sup><a href="#fn_5" id="reffn_5">5</a></sup>:Abdalla M., Fouque P. , and Pointcheval D. Passwordbased authenticated key exchange in the three-party setting[A]. Proceedings of PKC 2005[C]. Berlin: Springer-Verlag, LNCS, Vol. 3386, 2005:65–84.<br><sup><a href="#fn_6" id="reffn_6">6</a></sup>:Wei Fu-Shan, Ma Chuan-Gui, Cheng Qing-Feng. Anonymous gateway-riented password-based authenticated key exchange based on RSA[J]. EURASIP Journal on Wireless Communications and Networking, 2012, Doi: <a href="http://dx.doi.org/10.1186/1687-1499-2011–162">http://dx.doi.org/10.1186/1687-1499-2011–162</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 密码协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码协议 </tag>
            
            <tag> PAKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two Birds with One Stone: Two-Factor Authentication with Security Beyond Conventional Bound</title>
      <link href="/2023/06/26/two-birds-with-one-stone-two-factor-authentication-with-security-beyond-conventional-bound/"/>
      <url>/2023/06/26/two-birds-with-one-stone-two-factor-authentication-with-security-beyond-conventional-bound/</url>
      
        <content type="html"><![CDATA[<p>阅读论文《Two Birds with One Stone: Two-Factor Authentication with Security Beyond Conventional Bound》<br><span id="more"></span></p>]]></content>
      
      
      <categories>
          
          <category> 密码协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码协议 </tag>
            
            <tag> PAKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analysing and Patching SPEKE in ISO/IEC</title>
      <link href="/2023/06/26/analysing-and-patching-speke-in-iso-iec/"/>
      <url>/2023/06/26/analysing-and-patching-speke-in-iso-iec/</url>
      
        <content type="html"><![CDATA[<p>In this paper, we analyse the SPEKE protocol as specified in the ISO/IEC and IEEE standards. We identify that the protocol is vulnerable to two new attacks</p><ul><li><p><strong>impersonation attack</strong></p><p>allows an attacker to impersonate a user without knowing the password by launching two parallel sessions with the victim</p></li><li><p><strong>key-malleability attack</strong></p><p>allows a man-in-the-middle (MITM) to manipulate the session key without being detected by the end users</p></li></ul><p>We propose a patched SPEKE called P-SPEKE and present a formal analysis in the Applied Pi Calculus using ProVerif to show that the proposed patch prevents both attacks.</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>password-authenticated key exchange (PAKE) protocol</p><p><font color="red">purpose:</font> a low-entropy secret password known to both -&gt; establish a high-entropy session key for secure communication</p></li><li><p>EKE protocol</p><p><font color="red">question:</font> password leakage</p></li><li><p>SPEKE1996</p><p>We first observe that <strong>the original SPEKE protocol is subtly different from those defined in the standards</strong>. The difference has significant security implications, which are not explained in the standards.</p></li></ul><p><strong>contributions</strong></p><ul><li>find two new attacks on SPEKE</li><li>To address the identified problems, we propose a patched SPEKE, called P-SPEKE, which prevents both attacks by <strong>including the user identities in the key derivation function without altering the symmetry of the original SPEKE protocol.</strong></li><li>We build a formal model in the Applied Pi Calculus using ProVerif and apply it to formally analyse P-SPEKE. Our analysis confirms that the proposed patch is immune to the attacks.</li><li>Finally, we <strong>identify an efficiency problem with the key confirmation procedure</strong> specified in both the ISO/IEC and IEEE standards and accordingly propose an improved procedure.</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Password-Authenticated-Key-Exchange"><a href="#Password-Authenticated-Key-Exchange" class="headerlink" title="Password Authenticated Key Exchange"></a>Password Authenticated Key Exchange</h3><p><code>A PAKE protocol serves to provide two functions: authentication and key exchange.</code></p><font color="red">three protocols happen to represent three different ways of constructing a PAKE</font><ul><li>EKE: using the shared password as a symmetric key to encrypt Diffie-Hellman key exchange items</li></ul><blockquote><p>Variants of EKE (e.g., SPAKE2) often differ only in how the symmetric cipher is instantiated.</p><p><img src="image-20230626194151439.png" alt=""></p></blockquote><ul><li>SPEKE: using the shared password to <strong>derive a secret group generator</strong> for performing Diffie-Hellman key exchange</li></ul><blockquote><p>There are variants of SPEKE, such as Dragonfly and PACE, which use different methods to derive the secret generator from the password.</p></blockquote><ul><li>J-PAKE: using the password to randomize the secret exponents in order to achieve a cancellation effect</li></ul><blockquote><p>A distinctive feature of J-PAKE as compared to the other two is its use of Zero Knowledge Proof (ZKP) to enforce participants to follow the protocol specification.</p><p>By comparison, the use of ZKP is considered incompatible with the design of EKE and SPEKE.</p></blockquote><p><strong>common properties of a secure PAKE</strong></p><ul><li>Correctness</li><li>Secrecy of the pre-shared password</li><li>Implicit key authentication </li><li>Explicit key authentication</li><li>Weak and strong entity authentication</li><li>Perfect forward secrecy</li></ul><h3 id="The-original-SPEKE"><a href="#The-original-SPEKE" class="headerlink" title="The original SPEKE"></a>The original SPEKE</h3><ul><li>Upon receiving g^y, Alice verifies that its value is between 2 and p − 2. This is to prevent the small subgroup confinement attack</li><li>The key-exchange phase is completely symmetric. The symmetry in the design helps <font color="red">simplify the security analysis and reduce the communication rounds especially in a mesh network</font></li><li>The key confirmation method has two subtle issues<ul><li>it is ambiguous which party should send H(H(k)) first</li><li>from a theoretical perspective, <font color="red">the direct use of the session key in the key confirmation process renders the session key no longer indistinguishable from random</font> after the key confirmation is finished, hence breaking the session-key indistinguishability requirement in a formal model</li></ul></li></ul><p><img src="image-20230626202513913.png" alt=""></p><h3 id="Previous-attacks"><a href="#Previous-attacks" class="headerlink" title="Previous attacks"></a>Previous attacks</h3><ul><li><p>exponential-equivalence attack</p><ul><li>two different passwords s and s′ may have the relation that s′ = s^r mod p where r is an arbitrary integer(r != 1). By exploiting this relation, an active attacker can rule out two passwords in one go</li><li>As a countermeasure, Zhang proposed to hash the password before taking the square operation: in other words, <font color="red">redefining the password mapping function to f(s) = (H(s))^2 mod p</font></li></ul></li><li><p>unilateral Unknown Key-Share (UKS) attack</p></li><li>sessions swap attack</li></ul><h3 id="Specification-in-standards"><a href="#Specification-in-standards" class="headerlink" title="Specification in standards"></a>Specification in standards</h3><ul><li><p>the generator is obtained from g = (H(s))^2 mod p instead of g = s^2 mod p as in the original 1996 paper</p></li><li><p>the key confirmation procedure of SPEKE defined in the standards is also different from that in the original SPEKE paper</p><p><img src="image-20230626211604729.png" alt=""></p><p>the fact that g^x comes before g^y in the definition of key confirmation implies there is an order during the key exchange phase</p></li></ul><p><strong>key point:</strong> original SPEKE specifies that “Alice” sends the first confirmation message H(H(k)). <font color="red">Given the symmetric nature of the protocol, it is ambiguous which party is “Alice”</font>.</p><h2 id="New-attacks"><a href="#New-attacks" class="headerlink" title="New attacks"></a>New attacks</h2><h3 id="Impersonation-attack"><a href="#Impersonation-attack" class="headerlink" title="Impersonation attack"></a>Impersonation attack</h3><p><img src="image-20230626213050407.png" alt=""></p><p>This confusion of identities in the key establishment can cause problems in some scenarios.</p><h3 id="Key-malleability-attack"><a href="#Key-malleability-attack" class="headerlink" title="Key-malleability attack"></a>Key-malleability attack</h3><p><img src="image-20230626213937128.png" alt=""></p><p>In the original SPEKE paper, the protocol has no security proofs; it is heuristically argued that the security of the session key in SPEKE <font color="red">depends on either the Computational DiffieHellman assumption (i.e., an attacker is unable to compute the session key) or the Decisional Diffie-Hellman assumption (i.e., an attacker is unable to distinguish the session key from random).</font> </p><p>The existence of such a key-malleability attack suggests that <font color="red">a clean reduction to CDH or DDH is not possible</font>. As an example, z can be a result of an arbitrary function f (·) with the incepted inputs, i.e., z = f (g^x, g^y). Because of the correlation of values on the exponent, standard CHD and DDH assumptions are not applicable since they require <font color="red">the secret values on the exponent be independent</font>.</p><h3 id="Discussion-on-standards"><a href="#Discussion-on-standards" class="headerlink" title="Discussion on standards"></a>Discussion on standards</h3><ul><li>Explicit key confirmation<ul><li>Do not affect Impersonation attack, Key-malleability attack can also work in the implicitly authenticated version</li></ul></li><li>Definition of shared secret<ul><li>the definition of the shared secret in ISO/IEC 11770-4:2006 seems to include the “identifiers for one or more entities” as part of the shared secret. However, the standard does not provide any formula about π. It is not even clear if one or both entities’ identifiers should be included, and if only one identifier is to be included, which one and how.</li><li>In the latest revision in ISO/IEC 11770-4:2017, the definition of the shared secret has been revised to follow the same as in IEEE P1363.2 (D26). In this revision, the two reported attacks are addressed by making technical changes to the SPEKE specification</li></ul></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Patched-SPEKE"><a href="#Patched-SPEKE" class="headerlink" title="Patched SPEKE"></a>Patched SPEKE</h3><font color="red">There are several reasons to explain the cause of the two attacks.</font><ul><li>First, there is no reliable method in SPEKE to prevent a sent message being relayed back to the sender.</li><li>Second, there is no mechanism in the protocol to verify the integrity of the message, i.e., whether they have been altered during the transit.</li><li>Third, no user identifiers are included in the key exchange process.</li></ul><p>The session key computation is defined below. <strong>the hash output has a fixed bit length</strong>, which makes it easier to implement the max and min function.</p><p><img src="image-20230626222815838.png" alt=""></p><h3 id="Improved-key-confirmation"><a href="#Improved-key-confirmation" class="headerlink" title="Improved key confirmation"></a>Improved key confirmation</h3><p>we propose an improved key confirmation method which preserves the symmetry of the protocol and hence allows the key confirmation to be completed within one round.</p><p><img src="image-20230626222910516.png" alt=""></p><h2 id="Advantages-amp-disadvantages"><a href="#Advantages-amp-disadvantages" class="headerlink" title="Advantages &amp; disadvantages"></a>Advantages &amp; disadvantages</h2><p>优点</p><ul><li>提出两种针对ISO/IEC SPEKE的攻击，并分析造成攻击的根本原因</li><li>提出patched-SPEKE，安全性、协议对称性、round-efficiency都有所提高</li><li>使用proverif进行形式化分析，将传统人类密码分析与使用现代自动证明技术相结合，给改进安全协议提供新思路</li></ul><p>缺点/不足</p><ul><li><p>和原始SPEKE一样，缺乏完整安全证明</p></li><li><p>未证明 SPEKE 能否抵抗基于标准安全假设（例如 DDH 或 CDH）的离线字典攻击</p></li><li><p>协议计算$s_A$、$s_B$应使用意定通信方的身份</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码协议 </tag>
            
            <tag> PAKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码协议</title>
      <link href="/2023/06/22/mi-ma-xie-yi/"/>
      <url>/2023/06/22/mi-ma-xie-yi/</url>
      
        <content type="html"><![CDATA[<p>2023spring 密码协议课程笔记<br>授课老师：汪定<br><span id="more"></span></p><h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h3><h4 id="针对RSA的中间人相遇攻击"><a href="#针对RSA的中间人相遇攻击" class="headerlink" title="针对RSA的中间人相遇攻击"></a>针对RSA的中间人相遇攻击</h4><ul><li>破坏IND-CPA安全性</li><li>利用RSA的可乘特性，明文分解等于密文分解</li></ul><h3 id="构造可实用RSA"><a href="#构造可实用RSA" class="headerlink" title="构造可实用RSA"></a>构造可实用RSA</h3><p>RSA-OAEP（RSA最优非对称加密填充）</p><ul><li>非满足IND-CCA2的加密方案，几乎都不实用</li><li>几乎所有密码学教科书式算法（如RSA，Elgamal，AES），都不满足IND-CCA，直接使用会带来致命安全问题</li></ul><p><a href="https://blog.csdn.net/qq_39743001/article/details/116856051">(137条消息) “完全或无”、IND-CPA、IND-CCA1、IND-CCA2的详细说明_AnWen~的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/max1z/p/15992505.html">密码学之安全模型总结 - Max1z - 博客园 (cnblogs.com)</a></p><h2 id="消息认证（Message-Authentication）"><a href="#消息认证（Message-Authentication）" class="headerlink" title="消息认证（Message Authentication）"></a>消息认证（Message Authentication）</h2><ul><li><p>认证：消息的接收者对消息进行的验证</p><ul><li><p>真实性：消息确实来自于其真正的发送者，而非假冒；</p></li><li><p>完整性：消息的内容没有被篡改。</p></li></ul></li><li><p>是一个证实收到的消息来自可信的源点且未被篡改的过程。</p><ul><li>它也可以验证消息的顺序和及时性</li></ul></li></ul><p>认证函数分为三类：</p><ul><li>消息加密函数(Message encryption)<ul><li>用完整信息的密文作为对信息的认证。</li></ul></li><li>消息认证码MAC (Message Authentication Code)<ul><li>是对信源消息的一个编码函数。</li></ul></li><li>散列函数 (Hash Function)<ul><li>是一个公开的函数，它将任意长的信息映射成一个固定长度的信息</li></ul></li></ul><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><ul><li>$E_K(M)$​提供保密，提供认证，不提供签名</li><li>$E_{K_a}(M)$提供保密，不提供认证</li><li>$E_{K’_b}(M)$提供认证</li><li>$E_{K_a}(D_{k’_b}(M))$先签名后加密，提供认证，提供保密性</li><li>$D_{K’_b}(E_{K_a}(M))$先加密后签名，提供保密性，不提供认证性</li></ul><h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><ul><li>$M||C_k(M)$提供认证</li><li>$E_{k_2}(M||C_{k_1}(M))$提供认证，提供保密</li><li>$E_{k_2}(M)||C_{k_1}(E_{k_2}(M))$​提供认证，提供保密</li></ul><h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><ul><li>$E_k(M||H(M))$提供认证，提供保密</li><li>$M||E_k(H(M))$提供认证</li><li>$M||D_{K’_b}(H(M))$提供认证</li><li>$E_k(M||D_{K’_b}(H(M))$提供认证，提供保密</li><li>$M||H(M||K)$提供认证</li><li>$E_k(M||H(M||S)$​提供认证，提供保密</li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ul><li>直接数字签名方案（direct digital signature）<ul><li>$S_a(M)$直接签名</li><li>$E_b(S_a(M))$加密+签名</li><li>$M,S_a(H(M))$hash+签名</li><li>$E_b(M,S_a(H(M)))$加密+hash+签名</li><li>$M,(E_k(H(M)))$hash+签名</li></ul></li><li>基于仲裁的数字签名方案（arbitrated digital signature）<ul><li>对称密钥 + 明文传送<ul><li>$M,E_{at}(ID_a,H(M))$</li><li>$E_{bt}(ID_{a},M,E_{at}(ID_a,H(M),T))$</li></ul></li><li>对称密码＋密文传送<ul><li>$E_{ab}(M),E_{at}(ID_{a},E_{ab}(H(M)))$</li><li>$E_{bt}(ID_a,E_{ab}(M),E_{at}(ID_a,Eab(H(M),T)))$</li></ul></li><li>公钥密码＋密文传送<ul><li>$ID_a,S_a(ID_a,E_b(S_a(M)))$</li><li>$S_t(ID_a,E_b(S_a(M)),T)$</li></ul></li></ul></li></ul><h3 id="RSA数字签名体制"><a href="#RSA数字签名体制" class="headerlink" title="RSA数字签名体制"></a>RSA数字签名体制</h3><ul><li>一般攻击</li></ul><p><img src="image-20230618150928805.png" alt=""></p><ul><li>选择消息攻击</li></ul><p><img src="image-20230618151002207.png" alt=""></p><ul><li>利用签名进行攻击从而获得明文</li></ul><p><img src="image-20230618151029566.png" alt=""></p><ul><li><p>对先加密后签名方案的攻击</p><ul><li>攻击方法一</li></ul><p><img src="image-20230618151202925.png" alt=""></p><ul><li>攻击方法二</li></ul><p><img src="image-20230618151331091.png" alt=""></p></li></ul><p>RSA数字签名的安全性——小结</p><ul><li>不直接对消息进行签名，而应该对消息的Hash值进行签名</li><li>要采用先签名后加密的方式，而不要采用先加密后签名的方式</li></ul><h4 id="可实用的RSA数字签名方案RSA-PSS"><a href="#可实用的RSA数字签名方案RSA-PSS" class="headerlink" title="可实用的RSA数字签名方案RSA-PSS"></a>可实用的RSA数字签名方案RSA-PSS</h4><h3 id="数字签名标准-DSS-Digital-Signature-Standard"><a href="#数字签名标准-DSS-Digital-Signature-Standard" class="headerlink" title="数字签名标准 DSS: Digital Signature Standard"></a>数字签名标准 DSS: Digital Signature Standard</h3><ul><li>DSS中所采用算法通常称为DSA(Digital Signature Algorithm)</li><li>DSS中规定使用了安全散列函数(SHA-1)，DSA可以看作是ElGamal数字签名体制的一个变体</li></ul><p><img src="image-20230618151713192.png" alt=""></p><ul><li>基于椭圆曲线密码的数字签名算法ECDSA<ul><li>椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟</li></ul></li></ul><p><img src="image-20230618151846791.png" alt=""></p><h2 id="Woo-Lam身份认证协议"><a href="#Woo-Lam身份认证协议" class="headerlink" title="Woo-Lam身份认证协议"></a>Woo-Lam身份认证协议</h2><p><img src="image-20230618154009936.png" alt=""></p><p>缺陷：Trent-&gt;Bob返回的信息中不包含验证方”Alice“的身份，容易受到交错攻击</p><h1 id="认证协议"><a href="#认证协议" class="headerlink" title="认证协议"></a>认证协议</h1><h2 id="安全协议概述"><a href="#安全协议概述" class="headerlink" title="安全协议概述"></a>安全协议概述</h2><p><strong>协议的安全性质</strong></p><ul><li>认证性</li><li>机密性</li><li>完整性</li><li>不可否认性</li></ul><p><strong>安全协议的攻击者模型</strong></p><p><img src="image-20230618155621526.png" alt=""></p><p><img src="image-20230618155638806.png" alt=""></p><p><strong>安全协议设计和分析的困难性</strong></p><ul><li><p>困难的原因</p><ul><li><p>安全协议的功能越来越多样复杂</p></li><li><p>安全功能目标本身的微妙复杂性</p><blockquote><p>比如，表面上十分简单的“身份认证” ，实际上十分复杂微妙。</p></blockquote></li><li><p>协议运行环境的复杂性</p><ul><li>安全协议往往运行在开放、多方、并发、移动环境中。</li></ul></li><li><p>攻击者模型的复杂性</p><ul><li>我们必须充分考虑攻击者的能力，考虑各种各样的攻击，而如何准确地描述攻击者的能力，特别是如何形式化地对攻击者和攻击行为进行建模和形式化的分析迄今仍是公开难题。</li></ul></li></ul></li></ul><h2 id="认证协议-1"><a href="#认证协议-1" class="headerlink" title="认证协议"></a>认证协议</h2><p><strong>认证协议</strong>：是一个有序的过程，通过这个过程，一个实体可以向另一个实体证明某种声称的属性。</p><ul><li>消息发送者身份的真实性 -&gt; 实体认证（或称身份认证）</li><li><p>消息的完整性，新鲜性 -&gt; 消息认证（也称数据源认证）</p><ul><li>确认消息发送者(Bob)身份的真实性</li><li>确认在原消息离开消息发送者之后的数据完整性</li><li>确认传输过来的消息的“新鲜性”</li></ul></li><li><p>构建安全信道（从身份认证派生） -&gt; 带认证的密钥建立</p></li></ul><p><strong>消息认证 vs 数据完整性</strong></p><p>消息认证：验证消息是否真实、是否新鲜；数据完整性：验证消息在传输、存储过程中未经非法修改</p><ul><li>消息认证必然需要通信，数据完整性则不一定包含通信过程，例如存储数据的完整性</li><li>消息认证必然需要识别消息源，而数据完整性则不一定涉及该过程，例如无源识别的数据完整性技术</li><li>最重要的，消息认证必然需要确认消息的新鲜性，而数据完整性却无此必要：一组老的数据可能有完善的数据完整性</li></ul><p><strong>消息认证 vs 身份认证</strong></p><p><img src="image-20230618154922028.png" alt=""></p><p><strong>密钥建立</strong></p><p><img src="image-20230618154959763.png" alt=""></p><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>身份认证是确认主体之间通信的真实性，或通信双方或多方身份的真实性</p><h4 id="挑战应答机制"><a href="#挑战应答机制" class="headerlink" title="挑战应答机制"></a>挑战应答机制</h4><p><img src="image-20230618183841809.png" alt=""></p><p><img src="image-20230618183919075.png" alt=""></p><p><img src="image-20230618183944464.png" alt=""></p><p><img src="image-20230618184040159.png" alt=""></p><p><img src="image-20230618184118502.png" alt=""></p><p>基于对称密码的实体认证</p><ul><li>MAP1协议</li></ul><p><img src="image-20230618184247594.png" alt=""></p><ul><li>EVE1协议</li></ul><p><img src="image-20230618184307157.png" alt=""></p><font color='red'>在实现消息完整性时，只保留意定通信方身份</font><p><img src="image-20230618184427377.png" alt=""></p><p><img src="image-20230618184606647.png" alt=""></p><h4 id="时间戳机制"><a href="#时间戳机制" class="headerlink" title="时间戳机制"></a>时间戳机制</h4><p><img src="image-20230618184735337.png" alt=""></p><p><img src="image-20230618184821775.png" alt=""></p><h3 id="密钥建立"><a href="#密钥建立" class="headerlink" title="密钥建立"></a>密钥建立</h3><p>会话密钥，即临时秘密，<strong>被严格限制在一小段时间内使用</strong>，如一次单独的通信会话，其推出的动机：</p><ul><li>限制使用固定密钥的密文数量，以阻止选择明文/密文攻击</li><li>限制因意外泄露会话密钥而造成的相关保密数据的暴露数量</li><li>避免长期存储大量不同的秘密密钥(在一个实体可能与大量其他实体通信的情况下)，而仅在实际需要时建立密钥</li><li>产生不同通信会话和应用的相互独立性</li></ul><p>密钥建立协议主要包含两类</p><ul><li>密钥分配协议：如何使一个参与方可以生成或获得一个秘密值，并将它安全地传给其他参与方</li><li>密钥协商协议：两个(多个)参与方共同提供信息，推导出一个共享密钥，并且任何一方不能预先估计结果</li></ul><h4 id="密钥分配协议"><a href="#密钥分配协议" class="headerlink" title="密钥分配协议"></a>密钥分配协议</h4><p>密钥分配协议通常需要一个可信服务器的参与，常称之为密钥服务器（Key Server，KS），亦称为密钥分发中心（Key Distribution Center，KDC）等</p><ul><li>主要用于初始化系统设置和其他一些目的</li></ul><p>协议参与的双方都希望：</p><ul><li>能够确定是谁在和他进行密钥建立</li><li>能够防止未经授权的其他人推导出分配的密钥</li></ul><p>密钥分配协议通常和认证协议联合使用</p><p><img src="image-20230618185919388.png" alt=""></p><p><img src="image-20230618185943685.png" alt=""></p><p><img src="image-20230618190041066.png" alt=""></p><p><strong>大嘴青蛙协议</strong></p><p><img src="image-20230618202753499.png" alt=""></p><p><strong>NSSK协议</strong></p><p><img src="image-20230618202909576.png" alt=""></p><p><img src="image-20230618202932366.png" alt=""></p><p><img src="image-20230618203004484.png" alt=""></p><h4 id="密钥协商协议"><a href="#密钥协商协议" class="headerlink" title="密钥协商协议"></a>密钥协商协议</h4><p><img src="image-20230618203124144.png" alt=""></p><p><strong>基于公钥的密钥协商协议——Diffie-Hellman协议</strong></p><p><img src="image-20230618203207018.png" alt=""></p><p><img src="image-20230618203222699.png" alt=""></p><p><strong>基于口令的密钥协商协议</strong></p><p><img src="image-20230618203300238.png" alt=""></p><p><img src="image-20230618203319037.png" alt=""></p><p><img src="image-20230618203334069.png" alt=""></p><p><img src="image-20230618203438251.png" alt=""></p><p><img src="image-20230618203455081.png" alt=""></p><p><a href="https://blog.csdn.net/qq_44249020/article/details/113829031">(137条消息) 【EKE协议】Encrypted Key Exchange: Password-Based Protocols Secure Against Dictionary Attacks论文笔记_愚者上钩的博客-CSDN博客</a></p><p><img src="image-20230618203513109.png" alt=""></p><p><img src="image-20230618203526798.png" alt=""></p><p><img src="image-20230618203552340.png" alt=""></p><p><img src="image-20230618203601659.png" alt=""></p><h4 id="秘密共享"><a href="#秘密共享" class="headerlink" title="秘密共享"></a>秘密共享</h4><p><img src="image-20230618203639413.png" alt=""></p><p><img src="image-20230618203653562.png" alt=""></p><h1 id="从SSL1-0到TLS1-3"><a href="#从SSL1-0到TLS1-3" class="headerlink" title="从SSL1.0到TLS1.3"></a>从SSL1.0到TLS1.3</h1><p><img src="image-20230618190554012.png" alt=""></p><p><img src="image-20230618191002260.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 密码协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码协议 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
